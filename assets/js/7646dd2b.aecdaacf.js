"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[5830],{2633:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>t,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"isaac-platform/navigation","title":"Isaac Navigation - Autonomous Navigation and Path Planning","description":"Learning Objectives","source":"@site/docs/isaac-platform/navigation.md","sourceDirName":"isaac-platform","slug":"/isaac-platform/navigation","permalink":"/Physical-Ai-Humanoid-Robotics-Book/docs/isaac-platform/navigation","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/isaac-platform/navigation.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Perception Pipeline Integration with Navigation System","permalink":"/Physical-Ai-Humanoid-Robotics-Book/docs/isaac-platform/perception-navigation-integration"},"next":{"title":"Navigation Validation Guide","permalink":"/Physical-Ai-Humanoid-Robotics-Book/docs/isaac-platform/navigation-validation-guide"}}');var o=a(4848),s=a(7074);const t={sidebar_position:3},r="Isaac Navigation - Autonomous Navigation and Path Planning",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Conceptual Overview",id:"conceptual-overview",level:2},{value:"Navigation Stack Components",id:"navigation-stack-components",level:3},{value:"Key Navigation Concepts",id:"key-navigation-concepts",level:3},{value:"Isaac Navigation Features",id:"isaac-navigation-features",level:3},{value:"Hands-On Implementation",id:"hands-on-implementation",level:2},{value:"Installing Navigation Packages",id:"installing-navigation-packages",level:3},{value:"Basic Navigation Setup",id:"basic-navigation-setup",level:3},{value:"Creating a Navigation Configuration Package",id:"creating-a-navigation-configuration-package",level:4},{value:"Costmap Configuration",id:"costmap-configuration",level:4},{value:"Creating Navigation Launch Files",id:"creating-navigation-launch-files",level:3},{value:"Creating a Navigation Controller Node",id:"creating-a-navigation-controller-node",level:3},{value:"Creating a SLAM Integration Node",id:"creating-a-slam-integration-node",level:3},{value:"Isaac-Specific Navigation Features",id:"isaac-specific-navigation-features",level:3},{value:"Visual SLAM Integration",id:"visual-slam-integration",level:4},{value:"Testing &amp; Verification",id:"testing--verification",level:2},{value:"Running Navigation System",id:"running-navigation-system",level:3},{value:"Useful Navigation Commands",id:"useful-navigation-commands",level:3},{value:"Navigation Tuning Parameters",id:"navigation-tuning-parameters",level:3},{value:"Common Issues",id:"common-issues",level:2},{value:"Issue: Robot oscillates or cannot reach goal",id:"issue-robot-oscillates-or-cannot-reach-goal",level:3},{value:"Issue: Navigation fails with &quot;No valid path found&quot;",id:"issue-navigation-fails-with-no-valid-path-found",level:3},{value:"Issue: Robot gets stuck in local minima",id:"issue-robot-gets-stuck-in-local-minima",level:3},{value:"Issue: Localization drifts during navigation",id:"issue-localization-drifts-during-navigation",level:3},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Next Steps",id:"next-steps",level:2}];function _(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"isaac-navigation---autonomous-navigation-and-path-planning",children:"Isaac Navigation - Autonomous Navigation and Path Planning"})}),"\n",(0,o.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,o.jsx)(e.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Understand the navigation stack in ROS 2 and Isaac ecosystem"}),"\n",(0,o.jsx)(e.li,{children:"Implement SLAM (Simultaneous Localization and Mapping) systems"}),"\n",(0,o.jsx)(e.li,{children:"Create navigation pipelines for autonomous robot movement"}),"\n",(0,o.jsx)(e.li,{children:"Integrate perception data with navigation for obstacle avoidance"}),"\n",(0,o.jsx)(e.li,{children:"Configure and tune navigation parameters for optimal performance"}),"\n",(0,o.jsx)(e.li,{children:"Implement recovery behaviors and safety mechanisms"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,o.jsx)(e.p,{children:"Before starting this chapter, you should:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Have ROS 2 Humble Hawksbill installed and configured"}),"\n",(0,o.jsx)(e.li,{children:"Understand ROS 2 nodes, topics, and the navigation stack"}),"\n",(0,o.jsx)(e.li,{children:"Completed the perception chapter for sensor integration"}),"\n",(0,o.jsx)(e.li,{children:"Basic knowledge of SLAM concepts and path planning algorithms"}),"\n",(0,o.jsx)(e.li,{children:"Experience with URDF modeling and simulation"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"conceptual-overview",children:"Conceptual Overview"}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Navigation"})," in robotics refers to the ability of a robot to move autonomously from one location to another while avoiding obstacles and localizing itself within its environment. The Isaac Navigation system builds upon the ROS 2 Navigation2 stack with additional optimizations and features."]}),"\n",(0,o.jsx)(e.h3,{id:"navigation-stack-components",children:"Navigation Stack Components"}),"\n",(0,o.jsx)(e.p,{children:"The navigation stack typically consists of:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Localization"}),": Determining the robot's position in the environment"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Mapping"}),": Creating a representation of the environment"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Path Planning"}),": Finding a route from start to goal"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Path Execution"}),": Following the planned path while avoiding obstacles"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Recovery"}),": Handling situations where the robot gets stuck"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"key-navigation-concepts",children:"Key Navigation Concepts"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"SLAM (Simultaneous Localization and Mapping)"}),": Building a map while localizing"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"AMCL (Adaptive Monte Carlo Localization)"}),": Probabilistic localization in known maps"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Costmaps"}),": 2D/3D representations of the environment with obstacle information"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Path Planners"}),": Global and local planners for route computation"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Controllers"}),": Low-level systems to execute planned paths"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"isaac-navigation-features",children:"Isaac Navigation Features"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"GPU Acceleration"}),": Optimized algorithms for NVIDIA hardware"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Deep Learning Integration"}),": ML-based perception and planning"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Multi-Sensor Fusion"}),": Integration of various sensor types"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Real-time Performance"}),": Optimized for real-time applications"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Simulation Integration"}),": Seamless transition from sim to real hardware"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"hands-on-implementation",children:"Hands-On Implementation"}),"\n",(0,o.jsx)(e.h3,{id:"installing-navigation-packages",children:"Installing Navigation Packages"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"# Install Navigation2 packages\nsudo apt update\nsudo apt install ros-humble-navigation2 ros-humble-nav2-bringup\nsudo apt install ros-humble-slam-toolbox ros-humble-navigation-msgs\nsudo apt install ros-humble-robot-localization ros-humble-interactive-markers\n\n# For Isaac-specific navigation\ncd ~/isaac_ros_ws/src\ngit clone -b ros2-humble https://github.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam.git\ngit clone -b ros2-humble https://github.com/NVIDIA-ISAAC-ROS/isaac_ros_occupancy_grid_localizer.git\n\n# Build the workspace\ncd ~/isaac_ros_ws\nrosdep install --from-paths src --ignore-src -r -y\ncolcon build\n"})}),"\n",(0,o.jsx)(e.h3,{id:"basic-navigation-setup",children:"Basic Navigation Setup"}),"\n",(0,o.jsx)(e.h4,{id:"creating-a-navigation-configuration-package",children:"Creating a Navigation Configuration Package"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"cd ~/ros2_ws/src\nros2 pkg create --build-type ament_python navigation_config\n"})}),"\n",(0,o.jsx)(e.h4,{id:"costmap-configuration",children:"Costmap Configuration"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Create navigation_config/config/costmap_common_params.yaml:"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-yaml",children:"# Common costmap parameters\nmap_topic: /map\ntrack_unknown_space: true\nuse_dijkstra: true\nuse_grid_path: false\n\nalways_send_full_costmap: true\n\nunknown_cost_value: 255\nlethal_cost_threshold: 254\n\n# Robot footprint\nrobot_radius: 0.3  # For circular robots\n# footprint: [[x1, y1], [x2, y2], ...]  # For polygonal robots\n\n# Obstacle parameters\nobstacle_layer:\n  enabled: true\n  obstacle_range: 3.0\n  raytrace_range: 4.0\n  observation_sources: laser_scan\n  laser_scan:\n    topic: /scan\n    sensor_frame: laser_link\n    observation_persistence: 0.0\n    max_obstacle_height: 2.0\n    min_obstacle_height: 0.0\n    inf_is_valid: true\n    clearing: true\n    marking: true\n\n# Inflation layer\ninflation_layer:\n  enabled: true\n  cost_scaling_factor: 3.0\n  inflation_radius: 0.55\n"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Create navigation_config/config/local_costmap_params.yaml:"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-yaml",children:'local_costmap:\n  global_frame: odom\n  robot_base_frame: base_link\n  update_frequency: 10.0\n  publish_frequency: 10.0\n  static_map: false\n  rolling_window: true\n  width: 3\n  height: 3\n  resolution: 0.05\n  origin_x: 0.0\n  origin_y: 0.0\n  plugins:\n    - {name: obstacle_layer, type: "nav2_costmap_2d::ObstacleLayer"}\n    - {name: inflation_layer, type: "nav2_costmap_2d::InflationLayer"}\n'})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Create navigation_config/config/global_costmap_params.yaml:"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-yaml",children:'global_costmap:\n  global_frame: map\n  robot_base_frame: base_link\n  update_frequency: 1.0\n  publish_frequency: 1.0\n  static_map: true\n  rolling_window: false\n  plugins:\n    - {name: static_layer, type: "nav2_costmap_2d::StaticLayer"}\n    - {name: obstacle_layer, type: "nav2_costmap_2d::ObstacleLayer"}\n    - {name: inflation_layer, type: "nav2_costmap_2d::InflationLayer"}\n'})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Create navigation_config/config/nav2_params.yaml:"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-yaml",children:'amcl:\n  ros__parameters:\n    use_sim_time: False\n    alpha1: 0.2\n    alpha2: 0.2\n    alpha3: 0.2\n    alpha4: 0.2\n    alpha5: 0.2\n    base_frame_id: "base_link"\n    beam_skip_distance: 0.5\n    beam_skip_error_threshold: 0.9\n    beam_skip_threshold: 0.3\n    do_beamskip: false\n    global_frame_id: "map"\n    lambda_short: 0.1\n    laser_likelihood_max_dist: 2.0\n    laser_max_range: 100.0\n    laser_min_range: -1.0\n    laser_model_type: "likelihood_field"\n    max_beams: 60\n    max_particles: 2000\n    min_particles: 500\n    odom_frame_id: "odom"\n    pf_err: 0.05\n    pf_z: 0.99\n    recovery_alpha_fast: 0.0\n    recovery_alpha_slow: 0.0\n    resample_interval: 1\n    robot_model_type: "nav2_amcl::DifferentialMotionModel"\n    save_pose_rate: 0.5\n    sigma_hit: 0.2\n    tf_broadcast: true\n    transform_tolerance: 1.0\n    update_min_a: 0.2\n    update_min_d: 0.25\n    z_hit: 0.5\n    z_max: 0.05\n    z_rand: 0.5\n    z_short: 0.05\n    scan_topic: scan\n\namcl_map_client:\n  ros__parameters:\n    use_sim_time: False\n\namcl_rclcpp_node:\n  ros__parameters:\n    use_sim_time: False\n\nbt_navigator:\n  ros__parameters:\n    use_sim_time: False\n    global_frame: map\n    robot_base_frame: base_link\n    odom_topic: /odom\n    bt_loop_duration: 10\n    default_server_timeout: 20\n    enable_groot_monitoring: True\n    groot_zmq_publisher_port: 1666\n    groot_zmq_server_port: 1667\n    default_nav_through_poses_bt_xml: nav2_bt_navigator/nav_through_poses_w_replanning_and_recovery.xml\n    default_nav_to_pose_bt_xml: nav2_bt_navigator/nav_to_pose_w_replanning_and_recovery.xml\n    plugin_lib_names:\n    - nav2_compute_path_to_pose_action_bt_node\n    - nav2_compute_path_through_poses_action_bt_node\n    - nav2_smooth_path_action_bt_node\n    - nav2_follow_path_action_bt_node\n    - nav2_spin_action_bt_node\n    - nav2_wait_action_bt_node\n    - nav2_assisted_teleop_action_bt_node\n    - nav2_back_up_action_bt_node\n    - nav2_drive_on_heading_bt_node\n    - nav2_clear_costmap_service_bt_node\n    - nav2_is_stuck_condition_bt_node\n    - nav2_goal_reached_condition_bt_node\n    - nav2_goal_updated_condition_bt_node\n    - nav2_initial_pose_received_condition_bt_node\n    - nav2_reinitialize_global_localization_service_bt_node\n    - nav2_rate_controller_bt_node\n    - nav2_distance_controller_bt_node\n    - nav2_speed_controller_bt_node\n    - nav2_truncate_path_action_bt_node\n    - nav2_truncate_path_local_action_bt_node\n    - nav2_goal_updater_node_bt_node\n    - nav2_recovery_node_bt_node\n    - nav2_pipeline_sequence_bt_node\n    - nav2_round_robin_node_bt_node\n    - nav2_transform_available_condition_bt_node\n    - nav2_time_expired_condition_bt_node\n    - nav2_path_expiring_timer_condition\n    - nav2_distance_traveled_condition_bt_node\n    - nav2_single_trigger_bt_node\n    - nav2_is_battery_low_condition_bt_node\n    - nav2_navigate_through_poses_action_bt_node\n    - nav2_navigate_to_pose_action_bt_node\n    - nav2_remove_passed_goals_action_bt_node\n    - nav2_planner_selector_bt_node\n    - nav2_controller_selector_bt_node\n    - nav2_goal_checker_selector_bt_node\n    - nav2_controller_cancel_bt_node\n    - nav2_path_longer_on_approach_bt_node\n    - nav2_wait_cancel_bt_node\n    - nav2_spin_cancel_bt_node\n    - nav2_back_up_cancel_bt_node\n    - nav2_assisted_teleop_cancel_bt_node\n    - nav2_drive_on_heading_cancel_bt_node\n\nbt_navigator_rclcpp_node:\n  ros__parameters:\n    use_sim_time: False\n\ncontroller_server:\n  ros__parameters:\n    use_sim_time: False\n    controller_frequency: 20.0\n    min_x_velocity_threshold: 0.001\n    min_y_velocity_threshold: 0.5\n    min_theta_velocity_threshold: 0.001\n    failure_tolerance: 0.3\n    progress_checker_plugin: "progress_checker"\n    goal_checker_plugins: ["general_goal_checker"] # "precise_goal_checker"\n    controller_plugins: ["FollowPath"]\n\n    # Progress checker parameters\n    progress_checker:\n      plugin: "nav2_controller::SimpleProgressChecker"\n      required_movement_radius: 0.5\n      movement_time_allowance: 10.0\n\n    # Goal checker parameters\n    general_goal_checker:\n      plugin: "nav2_controller::SimpleGoalChecker"\n      xy_goal_tolerance: 0.25\n      yaw_goal_tolerance: 0.25\n      stateful: True\n\n    # Controller parameters\n    FollowPath:\n      plugin: "nav2_rotation_shim::RotationShimController"\n      rotational_scaler: 1.5\n      velocity_deadband: 0.05\n      velocity_scale_to_min: 0.25\n      velocity_scaling_type: 0 # 0: Disabled, 1: Time, 2: Distance\n      min_approach_velocity: 0.05\n      max_allowed_time_to_collision: 1.0\n      carrot_planner:\n        plugin: "nav2_navfn_planner::NavfnPlanner"\n        tolerance: 0.5\n        use_astar: false\n        allow_unknown: true\n\nlocal_costmap:\n  local_costmap:\n    ros__parameters:\n      update_frequency: 5.0\n      publish_frequency: 2.0\n      global_frame: odom\n      robot_base_frame: base_link\n      use_sim_time: False\n      rolling_window: true\n      width: 3\n      height: 3\n      resolution: 0.05\n      robot_radius: 0.22\n      plugins: ["obstacle_layer", "inflation_layer"]\n      inflation_layer:\n        plugin: "nav2_costmap_2d::InflationLayer"\n        cost_scaling_factor: 3.0\n        inflation_radius: 0.55\n      obstacle_layer:\n        plugin: "nav2_costmap_2d::ObstacleLayer"\n        enabled: True\n        observation_sources: scan\n        scan:\n          topic: /scan\n          max_obstacle_height: 2.0\n          clearing: True\n          marking: True\n          data_type: "LaserScan"\n          raytrace_max_range: 3.0\n          raytrace_min_range: 0.0\n          obstacle_max_range: 2.5\n          obstacle_min_range: 0.0\n      always_send_full_costmap: True\n\nglobal_costmap:\n  global_costmap:\n    ros__parameters:\n      update_frequency: 1.0\n      publish_frequency: 1.0\n      global_frame: map\n      robot_base_frame: base_link\n      use_sim_time: False\n      robot_radius: 0.22\n      resolution: 0.05\n      track_unknown_space: true\n      plugins: ["static_layer", "obstacle_layer", "inflation_layer"]\n      obstacle_layer:\n        plugin: "nav2_costmap_2d::ObstacleLayer"\n        enabled: True\n        observation_sources: scan\n        scan:\n          topic: /scan\n          max_obstacle_height: 2.0\n          clearing: True\n          marking: True\n          data_type: "LaserScan"\n          raytrace_max_range: 3.0\n          raytrace_min_range: 0.0\n          obstacle_max_range: 2.5\n          obstacle_min_range: 0.0\n      static_layer:\n        plugin: "nav2_costmap_2d::StaticLayer"\n        map_subscribe_transient_local: True\n      inflation_layer:\n        plugin: "nav2_costmap_2d::InflationLayer"\n        cost_scaling_factor: 3.0\n        inflation_radius: 0.55\n      always_send_full_costmap: True\n\nmap_server:\n  ros__parameters:\n    use_sim_time: False\n    yaml_filename: "turtlebot3_world.yaml"\n\nmap_saver:\n  ros__parameters:\n    use_sim_time: False\n    save_map_timeout: 5.0\n    free_thresh_default: 0.25\n    occupied_thresh_default: 0.65\n\nplanner_server:\n  ros__parameters:\n    expected_planner_frequency: 20.0\n    use_sim_time: False\n    planner_plugins: ["GridBased"]\n    GridBased:\n      plugin: "nav2_navfn_planner::NavfnPlanner"\n      tolerance: 0.5\n      use_astar: false\n      allow_unknown: true\n\nsmoother_server:\n  ros__parameters:\n    use_sim_time: False\n    smoother_plugins: ["simple_smoother"]\n    simple_smoother:\n      plugin: "nav2_smoother::SimpleSmoother"\n      tolerance: 0.01\n      max_its: 1000\n      do_refinement: True\n\nbehavior_server:\n  ros__parameters:\n    costmap_topic: local_costmap/costmap_raw\n    footprint_topic: local_costmap/published_footprint\n    cycle_frequency: 10.0\n    behavior_plugins: ["spin", "backup", "wait"]\n    spin:\n      plugin: "nav2_behaviors::Spin"\n      spin_dist: 1.57\n    backup:\n      plugin: "nav2_behaviors::BackUp"\n      backup_dist: 0.15\n      backup_speed: 0.025\n    wait:\n      plugin: "nav2_behaviors::Wait"\n      wait_duration: 1.0\n\nwaypoint_follower:\n  ros__parameters:\n    loop_rate: 20\n    stop_on_failure: false\n    waypoint_task_executor_plugin: "wait_at_waypoint"\n    wait_at_waypoint:\n      plugin: "nav2_waypoint_follower::WaitAtWaypoint"\n      enabled: true\n      wait_time: 1\n'})}),"\n",(0,o.jsx)(e.h3,{id:"creating-navigation-launch-files",children:"Creating Navigation Launch Files"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Create navigation_config/launch/navigation_launch.py:"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\n\n\ndef generate_launch_description():\n    # Declare launch arguments\n    use_sim_time = DeclareLaunchArgument(\n        'use_sim_time',\n        default_value='false',\n        description='Use simulation time if true'\n    )\n\n    params_file = DeclareLaunchArgument(\n        'params_file',\n        default_value=PathJoinSubstitution([\n            FindPackageShare('navigation_config'),\n            'config',\n            'nav2_params.yaml'\n        ]),\n        description='Full path to params file for navigation nodes'\n    )\n\n    # Navigation server\n    navigation_server = Node(\n        package='nav2_controller',\n        executable='controller_server',\n        name='controller_server',\n        parameters=[LaunchConfiguration('params_file'), {'use_sim_time': LaunchConfiguration('use_sim_time')}],\n        remappings=[('/cmd_vel', '/cmd_vel_nav')]\n    )\n\n    # Planner server\n    planner_server = Node(\n        package='nav2_planner',\n        executable='planner_server',\n        name='planner_server',\n        parameters=[LaunchConfiguration('params_file'), {'use_sim_time': LaunchConfiguration('use_sim_time')}],\n        remappings=[('~/global_costmap/costmap', 'global_costmap/costmap'),\n                   ('~/global_costmap/costmap_updates', 'global_costmap/costmap_updates'),\n                   ('~/local_costmap/costmap', 'local_costmap/costmap'),\n                   ('~/local_costmap/costmap_updates', 'local_costmap/costmap_updates')]\n    )\n\n    # Recoveries server\n    recoveries_server = Node(\n        package='nav2_recoveries',\n        executable='recoveries_server',\n        name='recoveries_server',\n        parameters=[LaunchConfiguration('params_file'), {'use_sim_time': LaunchConfiguration('use_sim_time')}]\n    )\n\n    # BT navigator\n    bt_navigator = Node(\n        package='nav2_bt_navigator',\n        executable='bt_navigator',\n        name='bt_navigator',\n        parameters=[LaunchConfiguration('params_file'), {'use_sim_time': LaunchConfiguration('use_sim_time')}],\n        remappings=[('~/local_costmap/costmap', 'local_costmap/costmap'),\n                   ('~/local_costmap/costmap_updates', 'local_costmap/costmap_updates'),\n                   ('~/global_costmap/costmap', 'global_costmap/costmap'),\n                   ('~/global_costmap/costmap_updates', 'global_costmap/costmap_updates')]\n    )\n\n    # Lifecycle manager for navigation\n    lifecycle_manager = Node(\n        package='nav2_lifecycle_manager',\n        executable='lifecycle_manager',\n        name='lifecycle_manager_navigation',\n        parameters=[{'use_sim_time': LaunchConfiguration('use_sim_time')},\n                   {'autostart': True},\n                   {'node_names': ['controller_server',\n                                  'planner_server',\n                                  'recoveries_server',\n                                  'bt_navigator']}]\n    )\n\n    return LaunchDescription([\n        use_sim_time,\n        params_file,\n        navigation_server,\n        planner_server,\n        recoveries_server,\n        bt_navigator,\n        lifecycle_manager\n    ])\n"})}),"\n",(0,o.jsx)(e.h3,{id:"creating-a-navigation-controller-node",children:"Creating a Navigation Controller Node"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\n\n\"\"\"\nNavigation controller node that sends goals to the navigation system.\n\"\"\"\n\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.action import ActionClient\nfrom geometry_msgs.msg import PoseStamped\nfrom nav2_msgs.action import NavigateToPose\nfrom std_msgs.msg import String\nimport random\n\n\nclass NavigationController(Node):\n    \"\"\"\n    Node to control navigation by sending goals to the navigation system.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('navigation_controller')\n\n        # Create action client for navigation\n        self.nav_client = ActionClient(self, NavigateToPose, 'navigate_to_pose')\n\n        # Create publisher for status\n        self.status_pub = self.create_publisher(String, 'navigation_status', 10)\n\n        # Wait for navigation server\n        self.get_logger().info('Waiting for navigation server...')\n        self.nav_client.wait_for_server()\n\n        # Timer to send goals periodically\n        self.timer = self.create_timer(10.0, self.send_goal)\n\n        # Goal counter\n        self.goal_count = 0\n\n        self.get_logger().info('Navigation controller initialized')\n\n    def send_goal(self):\n        \"\"\"Send a random goal to the navigation system.\"\"\"\n        # Wait for server\n        if not self.nav_client.wait_for_server(timeout_sec=1.0):\n            self.get_logger().error('Navigation server not available')\n            return\n\n        # Create a goal message\n        goal_msg = NavigateToPose.Goal()\n        goal_msg.pose.header.frame_id = 'map'\n        goal_msg.pose.header.stamp = self.get_clock().now().to_msg()\n\n        # Set a random goal position (in a real scenario, these would be meaningful coordinates)\n        goal_msg.pose.pose.position.x = random.uniform(-5.0, 5.0)\n        goal_msg.pose.pose.position.y = random.uniform(-5.0, 5.0)\n        goal_msg.pose.pose.position.z = 0.0\n\n        # Set orientation (pointing along positive x-axis)\n        goal_msg.pose.pose.orientation.x = 0.0\n        goal_msg.pose.pose.orientation.y = 0.0\n        goal_msg.pose.pose.orientation.z = 0.0\n        goal_msg.pose.pose.orientation.w = 1.0\n\n        # Send the goal\n        self.get_logger().info(f'Sending navigation goal #{self.goal_count}: '\n                              f'({goal_msg.pose.pose.position.x:.2f}, {goal_msg.pose.pose.position.y:.2f})')\n\n        send_goal_future = self.nav_client.send_goal_async(\n            goal_msg,\n            feedback_callback=self.feedback_callback\n        )\n\n        send_goal_future.add_done_callback(self.goal_response_callback)\n        self.goal_count += 1\n\n    def goal_response_callback(self, future):\n        \"\"\"Handle the response from the navigation server.\"\"\"\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().info('Goal rejected')\n            return\n\n        self.get_logger().info('Goal accepted')\n        get_result_future = goal_handle.get_result_async()\n        get_result_future.add_done_callback(self.get_result_callback)\n\n    def get_result_callback(self, future):\n        \"\"\"Handle the result from the navigation server.\"\"\"\n        result = future.result().result\n        status = future.result().status\n        self.get_logger().info(f'Navigation completed with status: {status}')\n\n        status_msg = String()\n        if status == 3:  # SUCCEEDED\n            status_msg.data = 'Navigation succeeded'\n        elif status == 4:  # CANCELED\n            status_msg.data = 'Navigation canceled'\n        else:\n            status_msg.data = f'Navigation failed with status: {status}'\n\n        self.status_pub.publish(status_msg)\n\n    def feedback_callback(self, feedback_msg):\n        \"\"\"Handle feedback from the navigation server.\"\"\"\n        feedback = feedback_msg.feedback\n        # In a real implementation, you might process feedback here\n        self.get_logger().debug('Received feedback')\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = NavigationController()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        node.get_logger().info('Navigation controller stopped by user')\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,o.jsx)(e.h3,{id:"creating-a-slam-integration-node",children:"Creating a SLAM Integration Node"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n\n"""\nSLAM integration node that combines mapping with navigation.\n"""\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import LaserScan\nfrom nav_msgs.msg import OccupancyGrid, Odometry\nfrom geometry_msgs.msg import PoseWithCovarianceStamped\nfrom tf2_ros import TransformBroadcaster\nimport numpy as np\n\n\nclass SLAMIntegrationNode(Node):\n    """\n    Node to integrate SLAM with navigation.\n    """\n\n    def __init__(self):\n        super().__init__(\'slam_integration_node\')\n\n        # Create subscribers\n        self.scan_sub = self.create_subscription(\n            LaserScan,\n            \'/scan\',\n            self.scan_callback,\n            10\n        )\n\n        self.odom_sub = self.create_subscription(\n            Odometry,\n            \'/odom\',\n            self.odom_callback,\n            10\n        )\n\n        # Create publishers\n        self.map_pub = self.create_publisher(\n            OccupancyGrid,\n            \'/map\',\n            10\n        )\n\n        self.initial_pose_pub = self.create_publisher(\n            PoseWithCovarianceStamped,\n            \'/initialpose\',\n            10\n        )\n\n        # Initialize variables\n        self.current_pose = None\n        self.map_resolution = 0.05  # meters per cell\n        self.map_width = 400  # cells\n        self.map_height = 400  # cells\n        self.map_origin_x = -10.0  # meters\n        self.map_origin_y = -10.0  # meters\n\n        # Create empty map\n        self.map_data = np.full(self.map_width * self.map_height, -1, dtype=np.int8)  # -1 = unknown\n\n        self.get_logger().info(\'SLAM integration node initialized\')\n\n    def scan_callback(self, msg):\n        """Process laser scan data for mapping."""\n        if self.current_pose is None:\n            return\n\n        # Convert laser scan to map coordinates and update map\n        # This is a simplified approach - real SLAM would be more complex\n        robot_x = self.current_pose.pose.pose.position.x\n        robot_y = self.current_pose.pose.pose.position.y\n        robot_yaw = self.get_yaw_from_quaternion(self.current_pose.pose.pose.orientation)\n\n        # Process each laser reading\n        for i, range_val in enumerate(msg.ranges):\n            if not (msg.range_min < range_val < msg.range_max):\n                continue  # Skip invalid ranges\n\n            # Calculate angle of this reading\n            angle = msg.angle_min + i * msg.angle_increment + robot_yaw\n\n            # Calculate end point of this laser beam\n            end_x = robot_x + range_val * np.cos(angle)\n            end_y = robot_y + range_val * np.sin(angle)\n\n            # Convert to map coordinates\n            map_x = int((end_x - self.map_origin_x) / self.map_resolution)\n            map_y = int((end_y - self.map_origin_y) / self.map_resolution)\n\n            # Check bounds\n            if 0 <= map_x < self.map_width and 0 <= map_y < self.map_height:\n                # Mark as occupied (value 100)\n                idx = map_y * self.map_width + map_x\n                self.map_data[idx] = 100\n\n    def odom_callback(self, msg):\n        """Process odometry data."""\n        self.current_pose = msg\n        # Could also update robot pose in map frame here\n\n    def get_yaw_from_quaternion(self, quat):\n        """Extract yaw from quaternion."""\n        siny_cosp = 2 * (quat.w * quat.z + quat.x * quat.y)\n        cosy_cosp = 1 - 2 * (quat.y * quat.y + quat.z * quat.z)\n        return np.arctan2(siny_cosp, cosy_cosp)\n\n    def publish_map(self):\n        """Publish the occupancy grid map."""\n        if self.map_data is None:\n            return\n\n        # Create occupancy grid message\n        map_msg = OccupancyGrid()\n        map_msg.header.stamp = self.get_clock().now().to_msg()\n        map_msg.header.frame_id = \'map\'\n\n        map_msg.info.resolution = self.map_resolution\n        map_msg.info.width = self.map_width\n        map_msg.info.height = self.map_height\n        map_msg.info.origin.position.x = self.map_origin_x\n        map_msg.info.origin.position.y = self.map_origin_y\n        map_msg.info.origin.position.z = 0.0\n        map_msg.info.origin.orientation.x = 0.0\n        map_msg.info.origin.orientation.y = 0.0\n        map_msg.info.origin.orientation.z = 0.0\n        map_msg.info.origin.orientation.w = 1.0\n\n        # Convert numpy array to list for message\n        map_msg.data = self.map_data.tolist()\n\n        # Publish map\n        self.map_pub.publish(map_msg)\n\n        self.get_logger().info(f\'Published map with {len(self.map_data)} cells\')\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = SLAMIntegrationNode()\n\n    # Timer to publish map periodically\n    node.create_timer(2.0, node.publish_map)\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        node.get_logger().info(\'SLAM integration node stopped by user\')\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,o.jsx)(e.h3,{id:"isaac-specific-navigation-features",children:"Isaac-Specific Navigation Features"}),"\n",(0,o.jsx)(e.h4,{id:"visual-slam-integration",children:"Visual SLAM Integration"}),"\n",(0,o.jsx)(e.p,{children:"Isaac provides advanced visual SLAM capabilities:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n\n"""\nIsaac Visual SLAM integration node.\n"""\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import Image, CameraInfo\nfrom geometry_msgs.msg import PoseStamped\nfrom nav_msgs.msg import Odometry\nfrom cv_bridge import CvBridge\nimport numpy as np\n\n\nclass IsaacVisualSLAMNode(Node):\n    """\n    Node to demonstrate Isaac Visual SLAM concepts.\n    """\n\n    def __init__(self):\n        super().__init__(\'isaac_visual_slam_node\')\n\n        # Create subscribers for stereo camera or RGB-D\n        self.left_image_sub = self.create_subscription(\n            Image,\n            \'/camera/left/image_rect_color\',\n            self.left_image_callback,\n            10\n        )\n\n        self.right_image_sub = self.create_subscription(\n            Image,\n            \'/camera/right/image_rect_color\',\n            self.right_image_callback,\n            10\n        )\n\n        self.camera_info_sub = self.create_subscription(\n            CameraInfo,\n            \'/camera/left/camera_info\',\n            self.camera_info_callback,\n            10\n        )\n\n        # Create publisher for visual odometry\n        self.odom_pub = self.create_publisher(\n            Odometry,\n            \'/visual_odom\',\n            10\n        )\n\n        # Initialize variables\n        self.bridge = CvBridge()\n        self.left_image = None\n        self.right_image = None\n        self.camera_info = None\n        self.previous_pose = None\n\n        self.get_logger().info(\'Isaac Visual SLAM node initialized\')\n\n    def left_image_callback(self, msg):\n        """Process left camera image."""\n        try:\n            self.left_image = self.bridge.imgmsg_to_cv2(msg, "bgr8")\n            self.process_stereo_pair()\n        except Exception as e:\n            self.get_logger().error(f\'Error processing left image: {e}\')\n\n    def right_image_callback(self, msg):\n        """Process right camera image."""\n        try:\n            self.right_image = self.bridge.imgmsg_to_cv2(msg, "bgr8")\n            self.process_stereo_pair()\n        except Exception as e:\n            self.get_logger().error(f\'Error processing right image: {e}\')\n\n    def camera_info_callback(self, msg):\n        """Process camera information."""\n        self.camera_info = msg\n\n    def process_stereo_pair(self):\n        """Process stereo images for visual SLAM."""\n        if self.left_image is None or self.right_image is None or self.camera_info is None:\n            return\n\n        # In a real implementation, you would use Isaac\'s visual SLAM pipeline\n        # This is a simplified example showing the concept\n\n        # Compute stereo disparity (simplified)\n        # In practice, Isaac uses optimized GPU-accelerated algorithms\n        gray_left = cv2.cvtColor(self.left_image, cv2.COLOR_BGR2GRAY)\n        gray_right = cv2.cvtColor(self.right_image, cv2.COLOR_BGR2GRAY)\n\n        # Use OpenCV\'s stereo matcher as an example\n        stereo = cv2.StereoSGBM_create(\n            minDisparity=0,\n            numDisparities=16*10,  # Must be divisible by 16\n            blockSize=5,\n            P1=8*3*5**2,\n            P2=32*3*5**2,\n            disp12MaxDiff=1,\n            uniquenessRatio=15,\n            speckleWindowSize=0,\n            speckleRange=2,\n            preFilterCap=63,\n            mode=cv2.STEREO_SGBM_MODE_SGBM_3WAY\n        )\n\n        disparity = stereo.compute(gray_left, gray_right).astype(np.float32) / 16.0\n\n        # Convert disparity to 3D points and estimate motion\n        # This would integrate with the navigation system in a real implementation\n\n        # Publish odometry estimate\n        odom_msg = Odometry()\n        odom_msg.header.stamp = self.get_clock().now().to_msg()\n        odom_msg.header.frame_id = \'odom\'\n        odom_msg.child_frame_id = \'base_link\'\n\n        # Set pose (simplified - would come from actual SLAM algorithm)\n        if self.previous_pose is None:\n            # Initial pose\n            odom_msg.pose.pose.position.x = 0.0\n            odom_msg.pose.pose.position.y = 0.0\n            odom_msg.pose.pose.position.z = 0.0\n            odom_msg.pose.pose.orientation.w = 1.0\n            self.previous_pose = odom_msg.pose.pose\n        else:\n            # Update based on estimated motion\n            odom_msg.pose.pose.position.x = self.previous_pose.position.x + 0.01\n            odom_msg.pose.pose.position.y = self.previous_pose.position.y + 0.01\n            odom_msg.pose.pose.orientation.w = 1.0\n            self.previous_pose = odom_msg.pose.pose\n\n        # Set velocity (simplified)\n        odom_msg.twist.twist.linear.x = 0.1\n        odom_msg.twist.twist.angular.z = 0.05\n\n        self.odom_pub.publish(odom_msg)\n\n        self.get_logger().info(\'Processed stereo pair for visual SLAM\')\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = IsaacVisualSLAMNode()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        node.get_logger().info(\'Visual SLAM node stopped by user\')\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,o.jsx)(e.h2,{id:"testing--verification",children:"Testing & Verification"}),"\n",(0,o.jsx)(e.h3,{id:"running-navigation-system",children:"Running Navigation System"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.strong,{children:"Start your robot with sensors:"})}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"# This could be a real robot or simulation\n# Make sure you have /scan, /odom, /tf topics available\n"})}),"\n",(0,o.jsxs)(e.ol,{start:"2",children:["\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.strong,{children:"Launch navigation:"})}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"cd ~/ros2_ws\nsource install/setup.bash\nros2 launch navigation_config navigation_launch.py\n"})}),"\n",(0,o.jsxs)(e.ol,{start:"3",children:["\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.strong,{children:"Send navigation goals:"})}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:'# Using navigation controller node\nros2 run navigation_config navigation_controller\n\n# Or manually with RViz2\nros2 run rviz2 rviz2\n# Then use the "Navigation 2" plugin to send goals\n'})}),"\n",(0,o.jsxs)(e.ol,{start:"4",children:["\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.strong,{children:"Monitor navigation performance:"})}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"# Check navigation status\nros2 topic echo /navigation_status\n\n# Monitor costmaps\nros2 run rviz2 rviz2  # Add costmap displays\n\n# Check robot position\nros2 topic echo /amcl_pose\n"})}),"\n",(0,o.jsx)(e.h3,{id:"useful-navigation-commands",children:"Useful Navigation Commands"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.strong,{children:"Check navigation topics:"})}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:'ros2 topic list | grep -E "(nav|costmap|localization)"\n'})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.strong,{children:"Send a goal programmatically:"})}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"ros2 action send_goal /navigate_to_pose nav2_msgs/action/NavigateToPose \"{pose: {header: {frame_id: 'map'}, pose: {position: {x: 1.0, y: 1.0, z: 0.0}, orientation: {w: 1.0}}}}\"\n"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.strong,{children:"Reset navigation:"})}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"ros2 service call /global_costmap/clear_entirely_global_costmap std_srvs/srv/Empty\n"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:(0,o.jsx)(e.strong,{children:"Monitor navigation performance:"})}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"# Use navigation tools\nros2 run nav2_util navigation_metrics\n"})}),"\n",(0,o.jsx)(e.h3,{id:"navigation-tuning-parameters",children:"Navigation Tuning Parameters"}),"\n",(0,o.jsx)(e.p,{children:"Navigation performance can be tuned by adjusting parameters in the config files:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Costmap resolution"}),": Higher resolution = more precise but slower"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Inflation radius"}),": Larger radius = safer but more conservative paths"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Controller frequency"}),": Higher frequency = more responsive but more CPU usage"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Goal tolerances"}),": Smaller values = more precise goal achievement"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"common-issues",children:"Common Issues"}),"\n",(0,o.jsx)(e.h3,{id:"issue-robot-oscillates-or-cannot-reach-goal",children:"Issue: Robot oscillates or cannot reach goal"}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Solution"}),":"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Check costmap inflation parameters"}),"\n",(0,o.jsx)(e.li,{children:"Verify robot footprint is correctly configured"}),"\n",(0,o.jsx)(e.li,{children:"Adjust controller parameters (XY goal tolerance, yaw goal tolerance)"}),"\n",(0,o.jsx)(e.li,{children:"Check that the goal is in a navigable area"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"issue-navigation-fails-with-no-valid-path-found",children:'Issue: Navigation fails with "No valid path found"'}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Solution"}),":"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Verify map quality and resolution"}),"\n",(0,o.jsx)(e.li,{children:"Check that obstacles are properly detected"}),"\n",(0,o.jsx)(e.li,{children:"Ensure global planner can find a path"}),"\n",(0,o.jsx)(e.li,{children:"Verify robot can physically navigate to the goal"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"issue-robot-gets-stuck-in-local-minima",children:"Issue: Robot gets stuck in local minima"}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Solution"}),":"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Improve local planner parameters"}),"\n",(0,o.jsx)(e.li,{children:"Add recovery behaviors"}),"\n",(0,o.jsx)(e.li,{children:"Use more sophisticated path planning algorithms"}),"\n",(0,o.jsx)(e.li,{children:"Check for proper obstacle inflation"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"issue-localization-drifts-during-navigation",children:"Issue: Localization drifts during navigation"}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Solution"}),":"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Improve sensor quality and calibration"}),"\n",(0,o.jsx)(e.li,{children:"Use more robust localization methods"}),"\n",(0,o.jsx)(e.li,{children:"Add landmark-based relocalization"}),"\n",(0,o.jsx)(e.li,{children:"Verify odometry quality"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Navigation combines localization, mapping, path planning, and control"}),"\n",(0,o.jsx)(e.li,{children:"Costmaps are crucial for obstacle avoidance and path planning"}),"\n",(0,o.jsx)(e.li,{children:"Parameter tuning is essential for optimal navigation performance"}),"\n",(0,o.jsx)(e.li,{children:"Isaac provides GPU-accelerated navigation algorithms"}),"\n",(0,o.jsx)(e.li,{children:"Integration with perception systems enables robust autonomous navigation"}),"\n",(0,o.jsx)(e.li,{children:"Recovery behaviors are important for handling edge cases"}),"\n",(0,o.jsx)(e.li,{children:"Simulation testing is crucial before real-world deployment"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,o.jsx)(e.p,{children:"In the next chapter, you'll learn about Vision-Language-Action (VLA) systems, which integrate computer vision, natural language processing, and robotic action for advanced human-robot interaction."})]})}function m(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(_,{...n})}):_(n)}},7074:(n,e,a)=>{a.d(e,{R:()=>t,x:()=>r});var i=a(6540);const o={},s=i.createContext(o);function t(n){const e=i.useContext(s);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:t(n.components),i.createElement(s.Provider,{value:e},n.children)}}}]);