"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[272],{3058:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"isaac-platform/sim-to-real-transfer-jetson-guide","title":"Sim-to-Real Transfer Guide for Jetson Deployment","description":"This document provides a comprehensive guide for transferring models and systems from simulation to real-world deployment on NVIDIA Jetson hardware platforms.","source":"@site/docs/isaac-platform/sim-to-real-transfer-jetson-guide.md","sourceDirName":"isaac-platform","slug":"/isaac-platform/sim-to-real-transfer-jetson-guide","permalink":"/./docs/isaac-platform/sim-to-real-transfer-jetson-guide","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/isaac-platform/sim-to-real-transfer-jetson-guide.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Voice Command Processing System","permalink":"/./docs/isaac-platform/voice-command-processing-system"},"next":{"title":"Edge Device Optimization Techniques for Robotics","permalink":"/./docs/isaac-platform/edge-device-optimization-techniques"}}');var i=r(4848),s=r(7074);const a={},o="Sim-to-Real Transfer Guide for Jetson Deployment",l={},d=[{value:"Overview",id:"overview",level:2},{value:"Jetson Hardware Overview",id:"jetson-hardware-overview",level:2},{value:"Supported Platforms",id:"supported-platforms",level:3},{value:"Key Specifications",id:"key-specifications",level:3},{value:"Simulation to Real-World Challenges",id:"simulation-to-real-world-challenges",level:2},{value:"1. Domain Gap",id:"1-domain-gap",level:3},{value:"2. Hardware Limitations",id:"2-hardware-limitations",level:3},{value:"3. System Integration",id:"3-system-integration",level:3},{value:"Transfer Strategies",id:"transfer-strategies",level:2},{value:"1. Domain Randomization",id:"1-domain-randomization",level:3},{value:"2. System Identification",id:"2-system-identification",level:3},{value:"3. Robust Control Design",id:"3-robust-control-design",level:3},{value:"Jetson Deployment Considerations",id:"jetson-deployment-considerations",level:2},{value:"1. Model Optimization",id:"1-model-optimization",level:3},{value:"2. Jetson Deployment Pipeline",id:"2-jetson-deployment-pipeline",level:3},{value:"3. Real-World Testing Framework",id:"3-real-world-testing-framework",level:3},{value:"Jetson-Specific Optimization Guide",id:"jetson-specific-optimization-guide",level:2},{value:"1. Power Management",id:"1-power-management",level:3},{value:"2. Thermal Management",id:"2-thermal-management",level:3},{value:"3. Memory Optimization",id:"3-memory-optimization",level:3},{value:"Testing and Validation",id:"testing-and-validation",level:2},{value:"1. Gradual Deployment Strategy",id:"1-gradual-deployment-strategy",level:3},{value:"2. Safety Mechanisms",id:"2-safety-mechanisms",level:3},{value:"Resources and Further Reading",id:"resources-and-further-reading",level:2}];function m(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"sim-to-real-transfer-guide-for-jetson-deployment",children:"Sim-to-Real Transfer Guide for Jetson Deployment"})}),"\n",(0,i.jsx)(n.p,{children:"This document provides a comprehensive guide for transferring models and systems from simulation to real-world deployment on NVIDIA Jetson hardware platforms."}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"Sim-to-real transfer involves adapting models, algorithms, and systems developed in simulation environments for deployment on physical hardware. This guide focuses on NVIDIA Jetson platforms, which are popular for edge AI and robotics applications."}),"\n",(0,i.jsx)(n.h2,{id:"jetson-hardware-overview",children:"Jetson Hardware Overview"}),"\n",(0,i.jsx)(n.h3,{id:"supported-platforms",children:"Supported Platforms"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Jetson Nano"}),": Entry-level, 5W-10W power consumption"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Jetson TX2"}),": Mid-range, 7W-15W power consumption"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Jetson Xavier NX"}),": High-performance, 10W-25W power consumption"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Jetson AGX Xavier"}),": High-end, 10W-30W power consumption"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Jetson AGX Orin"}),": Latest generation, 15W-60W power consumption"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"key-specifications",children:"Key Specifications"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"GPU: NVIDIA CUDA-capable GPU"}),"\n",(0,i.jsx)(n.li,{children:"CPU: ARM-based multi-core processor"}),"\n",(0,i.jsx)(n.li,{children:"Memory: 4GB-64GB LPDDR4/LPDDR5"}),"\n",(0,i.jsx)(n.li,{children:"Storage: eMMC or microSD"}),"\n",(0,i.jsx)(n.li,{children:"Power: 5V-19V DC input depending on model"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"simulation-to-real-world-challenges",children:"Simulation to Real-World Challenges"}),"\n",(0,i.jsx)(n.h3,{id:"1-domain-gap",children:"1. Domain Gap"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reality Gap"}),": Differences between simulated and real physics"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Sensor Noise"}),": Real sensors have noise, drift, and limitations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Actuator Dynamics"}),": Real actuators have delays, friction, and power limits"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Environmental Conditions"}),": Lighting, temperature, and atmospheric differences"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"2-hardware-limitations",children:"2. Hardware Limitations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Computational Power"}),": Jetson has limited compute compared to workstations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Memory Constraints"}),": Limited RAM and storage"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Power Consumption"}),": Battery life considerations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Thermal Management"}),": Heat dissipation in enclosed systems"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"3-system-integration",children:"3. System Integration"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Hardware Abstraction"}),": Different interfaces for real hardware"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Timing Constraints"}),": Real-time requirements"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Safety Considerations"}),": Physical safety in real environments"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Calibration"}),": Sensor and actuator calibration requirements"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"transfer-strategies",children:"Transfer Strategies"}),"\n",(0,i.jsx)(n.h3,{id:"1-domain-randomization",children:"1. Domain Randomization"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# domain_randomization.py\r\nimport numpy as np\r\nimport random\r\n\r\nclass DomainRandomizer:\r\n    \"\"\"\r\n    Apply domain randomization during simulation to improve sim-to-real transfer\r\n    \"\"\"\r\n    def __init__(self):\r\n        self.randomization_params = {\r\n            'lighting': {\r\n                'brightness_range': (0.5, 2.0),\r\n                'color_temperature_range': (3000, 8000),\r\n                'shadow_intensity_range': (0.1, 1.0)\r\n            },\r\n            'physics': {\r\n                'friction_range': (0.1, 1.0),\r\n                'mass_multiplier_range': (0.8, 1.2),\r\n                'damping_range': (0.01, 0.1)\r\n            },\r\n            'sensor_noise': {\r\n                'camera_noise_std': (0.0, 0.05),\r\n                'imu_noise_std': (0.001, 0.01),\r\n                'lidar_noise_std': (0.01, 0.1)\r\n            }\r\n        }\r\n\r\n    def randomize_environment(self, sim_env):\r\n        \"\"\"\r\n        Apply randomization to simulation environment\r\n        \"\"\"\r\n        # Randomize lighting conditions\r\n        brightness = np.random.uniform(\r\n            self.randomization_params['lighting']['brightness_range'][0],\r\n            self.randomization_params['lighting']['brightness_range'][1]\r\n        )\r\n        sim_env.set_lighting_brightness(brightness)\r\n\r\n        # Randomize physics parameters\r\n        friction = np.random.uniform(\r\n            self.randomization_params['physics']['friction_range'][0],\r\n            self.randomization_params['physics']['friction_range'][1]\r\n        )\r\n        sim_env.set_friction_coefficient(friction)\r\n\r\n        # Randomize sensor noise\r\n        camera_noise = np.random.uniform(\r\n            self.randomization_params['sensor_noise']['camera_noise_std'][0],\r\n            self.randomization_params['sensor_noise']['camera_noise_std'][1]\r\n        )\r\n        sim_env.add_camera_noise(camera_noise)\r\n\r\n        return sim_env\r\n\r\n    def get_randomization_stats(self):\r\n        \"\"\"\r\n        Get statistics about randomization parameters\r\n        \"\"\"\r\n        return self.randomization_params\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-system-identification",children:"2. System Identification"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# system_identification.py\r\nimport numpy as np\r\nfrom scipy.optimize import minimize\r\nfrom typing import Dict, Tuple, List\r\n\r\nclass SystemIdentifier:\r\n    \"\"\"\r\n    Identify system parameters from real-world data for better simulation\r\n    \"\"\"\r\n    def __init__(self):\r\n        self.model_params = {}\r\n        self.identification_data = []\r\n\r\n    def collect_identification_data(self, robot, input_sequence: List[np.ndarray],\r\n                                  sampling_time: float = 0.01) -> Dict:\r\n        \"\"\"\r\n        Collect input-output data for system identification\r\n        \"\"\"\r\n        states = []\r\n        inputs = []\r\n        outputs = []\r\n\r\n        for input_cmd in input_sequence:\r\n            # Apply input to robot\r\n            robot.apply_control(input_cmd)\r\n\r\n            # Sample state and output\r\n            state = robot.get_state()\r\n            output = robot.get_sensor_output()\r\n\r\n            states.append(state)\r\n            inputs.append(input_cmd)\r\n            outputs.append(output)\r\n\r\n            # Wait for sampling time\r\n            import time\r\n            time.sleep(sampling_time)\r\n\r\n        return {\r\n            'inputs': np.array(inputs),\r\n            'outputs': np.array(outputs),\r\n            'states': np.array(states)\r\n        }\r\n\r\n    def identify_dynamics_model(self, data: Dict) -> Dict:\r\n        \"\"\"\r\n        Identify dynamics model parameters from collected data\r\n        \"\"\"\r\n        inputs = data['inputs']\r\n        outputs = data['outputs']\r\n        states = data['states']\r\n\r\n        # Example: Linear system identification (A, B, C, D matrices)\r\n        # dx/dt = Ax + Bu\r\n        # y = Cx + Du\r\n\r\n        # For a simple first-order system: tau*dx/dt = -x + Ku\r\n        def objective_function(params):\r\n            tau, K = params\r\n\r\n            # Simulate the model\r\n            x_sim = np.zeros_like(states[:, 0])\r\n            x_sim[0] = states[0, 0]\r\n\r\n            dt = 0.01  # Assume fixed time step\r\n            for i in range(1, len(states)):\r\n                dx_dt = (-x_sim[i-1] + K * inputs[i-1, 0]) / tau\r\n                x_sim[i] = x_sim[i-1] + dx_dt * dt\r\n\r\n            # Calculate error\r\n            error = np.sum((x_sim - states[:, 0])**2)\r\n            return error\r\n\r\n        # Optimize parameters\r\n        result = minimize(objective_function, [1.0, 1.0], method='BFGS')\r\n        tau_opt, K_opt = result.x\r\n\r\n        return {\r\n            'tau': tau_opt,\r\n            'gain': K_opt,\r\n            'error': result.fun\r\n        }\r\n\r\n    def tune_simulation_parameters(self, real_params: Dict, sim_env):\r\n        \"\"\"\r\n        Tune simulation parameters to match real system\r\n        \"\"\"\r\n        # Update simulation with identified parameters\r\n        sim_env.set_parameter('system_time_constant', real_params['tau'])\r\n        sim_env.set_parameter('system_gain', real_params['gain'])\r\n\r\n        return sim_env\n"})}),"\n",(0,i.jsx)(n.h3,{id:"3-robust-control-design",children:"3. Robust Control Design"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# robust_control.py\r\nimport numpy as np\r\nfrom scipy import signal\r\nimport control  # python-control package\r\n\r\nclass RobustController:\r\n    \"\"\"\r\n    Design robust controllers that work in both simulation and reality\r\n    \"\"\"\r\n    def __init__(self, nominal_model, uncertainty_bounds):\r\n        self.nominal_model = nominal_model\r\n        self.uncertainty_bounds = uncertainty_bounds\r\n        self.controller = None\r\n\r\n    def design_robust_controller(self, method='hinf'):\r\n        \"\"\"\r\n        Design a robust controller using H-infinity or other methods\r\n        \"\"\"\r\n        if method == 'hinf':\r\n            return self._design_hinf_controller()\r\n        elif method == 'pid':\r\n            return self._design_robust_pid()\r\n        else:\r\n            raise ValueError(f\"Unknown method: {method}\")\r\n\r\n    def _design_hinf_controller(self):\r\n        \"\"\"\r\n        Design H-infinity controller for robustness\r\n        \"\"\"\r\n        # This is a simplified example\r\n        # In practice, you'd use more sophisticated tools\r\n\r\n        # Create augmented plant with uncertainty\r\n        A = self.nominal_model['A']\r\n        B1 = self.nominal_model['B1']  # disturbance input\r\n        B2 = self.nominal_model['B2']  # control input\r\n        C1 = self.nominal_model['C1']  # error output\r\n        C2 = self.nominal_model['C2']  # measurement output\r\n        D11 = self.nominal_model['D11']\r\n        D12 = self.nominal_model['D12']\r\n        D21 = self.nominal_model['D21']\r\n        D22 = self.nominal_model['D22']\r\n\r\n        # For this example, we'll create a simple PID controller with robustness considerations\r\n        # Calculate robust PID gains\r\n        Kp = self._calculate_robust_pid_gain('proportional')\r\n        Ki = self._calculate_robust_pid_gain('integral')\r\n        Kd = self._calculate_robust_pid_gain('derivative')\r\n\r\n        return {\r\n            'type': 'robust_pid',\r\n            'Kp': Kp,\r\n            'Ki': Ki,\r\n            'Kd': Kd,\r\n            'uncertainty_margin': self.uncertainty_bounds\r\n        }\r\n\r\n    def _calculate_robust_pid_gain(self, gain_type):\r\n        \"\"\"\r\n        Calculate PID gain with robustness considerations\r\n        \"\"\"\r\n        # Base gain from nominal model\r\n        base_gain = self._get_base_gain(gain_type)\r\n\r\n        # Apply uncertainty margin\r\n        uncertainty_factor = 1.0 - (self.uncertainty_bounds / 100.0)  # Reduce gain for robustness\r\n\r\n        robust_gain = base_gain * uncertainty_factor\r\n\r\n        return robust_gain\r\n\r\n    def _get_base_gain(self, gain_type):\r\n        \"\"\"\r\n        Get base PID gain from nominal model\r\n        \"\"\"\r\n        # This would typically involve system identification or model-based design\r\n        # For this example, return a default value\r\n        gains = {\r\n            'proportional': 1.0,\r\n            'integral': 0.1,\r\n            'derivative': 0.05\r\n        }\r\n        return gains.get(gain_type, 1.0)\r\n\r\n    def adapt_controller(self, real_performance):\r\n        \"\"\"\r\n        Adapt controller based on real-world performance\r\n        \"\"\"\r\n        # Monitor performance and adjust gains\r\n        if real_performance['error'] > real_performance['target_error'] * 1.5:\r\n            # Increase gains if performance is poor\r\n            self.controller['Kp'] *= 1.1\r\n            self.controller['Ki'] *= 1.1\r\n        elif real_performance['error'] < real_performance['target_error'] * 0.8:\r\n            # Decrease gains if too aggressive\r\n            self.controller['Kp'] *= 0.95\r\n            self.controller['Ki'] *= 0.95\r\n\r\n        return self.controller\n"})}),"\n",(0,i.jsx)(n.h2,{id:"jetson-deployment-considerations",children:"Jetson Deployment Considerations"}),"\n",(0,i.jsx)(n.h3,{id:"1-model-optimization",children:"1. Model Optimization"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# jetson_model_optimizer.py\r\nimport tensorrt as trt\r\nimport pycuda.driver as cuda\r\nimport pycuda.autoinit\r\nimport numpy as np\r\nfrom typing import Dict, Any\r\n\r\nclass JetsonModelOptimizer:\r\n    """\r\n    Optimize models for Jetson deployment\r\n    """\r\n    def __init__(self):\r\n        self.trt_logger = trt.Logger(trt.Logger.WARNING)\r\n\r\n    def optimize_with_tensorrt(self, model_path: str, precision: str = "fp16") -> str:\r\n        """\r\n        Optimize model using TensorRT for Jetson\r\n        """\r\n        # Create TensorRT builder\r\n        builder = trt.Builder(self.trt_logger)\r\n        network = builder.create_network(1 << int(trt.NetworkDefinitionCreationFlag.EXPLICIT_BATCH))\r\n        parser = trt.OnnxParser(network, self.trt_logger)\r\n\r\n        # Parse ONNX model\r\n        with open(model_path, \'rb\') as model_file:\r\n            if not parser.parse(model_file.read()):\r\n                for error in range(parser.num_errors):\r\n                    print(parser.get_error(error))\r\n                raise ValueError("Failed to parse ONNX model")\r\n\r\n        # Configure builder\r\n        config = builder.create_builder_config()\r\n\r\n        # Set precision\r\n        if precision == "fp16":\r\n            config.set_flag(trt.BuilderFlag.FP16)\r\n        elif precision == "int8":\r\n            config.set_flag(trt.BuilderFlag.INT8)\r\n            # Add calibration here for INT8\r\n\r\n        # Set memory limit (important for Jetson)\r\n        config.set_memory_pool_limit(trt.MemoryPoolType.WORKSPACE, 1 << 30)  # 1GB\r\n\r\n        # Build engine\r\n        serialized_engine = builder.build_serialized_network(network, config)\r\n\r\n        # Save optimized model\r\n        optimized_path = model_path.replace(\'.onnx\', f\'_trt_{precision}.engine\')\r\n        with open(optimized_path, \'wb\') as f:\r\n            f.write(serialized_engine)\r\n\r\n        return optimized_path\r\n\r\n    def quantize_model(self, model, calibration_data=None):\r\n        """\r\n        Quantize model for reduced memory and compute requirements\r\n        """\r\n        import torch\r\n        import torch.quantization as quant\r\n\r\n        # Set model to evaluation mode\r\n        model.eval()\r\n\r\n        # Specify quantization configuration\r\n        model.qconfig = quant.get_default_qconfig(\'fbgemm\')\r\n\r\n        # Prepare model for quantization\r\n        quant_model = quant.prepare(model)\r\n\r\n        # If calibration data provided, run calibration\r\n        if calibration_data:\r\n            with torch.no_grad():\r\n                for data in calibration_data:\r\n                    quant_model(data)\r\n\r\n        # Convert to quantized model\r\n        quant_model = quant.convert(quant_model)\r\n\r\n        return quant_model\r\n\r\n    def optimize_for_jetson(self, model_path: str, target_jetson: str) -> Dict[str, Any]:\r\n        """\r\n        Apply Jetson-specific optimizations\r\n        """\r\n        optimizations = {\r\n            \'tensorrt_optimized\': self.optimize_with_tensorrt(model_path, "fp16"),\r\n            \'model_size_mb\': self._get_model_size(model_path),\r\n            \'inference_time_ms\': self._benchmark_model(model_path),\r\n            \'memory_usage_mb\': self._estimate_memory_usage(model_path)\r\n        }\r\n\r\n        return optimizations\r\n\r\n    def _get_model_size(self, model_path: str) -> float:\r\n        """\r\n        Get model size in MB\r\n        """\r\n        import os\r\n        size_bytes = os.path.getsize(model_path)\r\n        return size_bytes / (1024 * 1024)\r\n\r\n    def _benchmark_model(self, model_path: str) -> float:\r\n        """\r\n        Benchmark model inference time\r\n        """\r\n        # This would involve actual benchmarking\r\n        # For this example, return a placeholder\r\n        return 10.0  # ms\n'})}),"\n",(0,i.jsx)(n.h3,{id:"2-jetson-deployment-pipeline",children:"2. Jetson Deployment Pipeline"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# jetson_deployment.py\r\nimport subprocess\r\nimport os\r\nimport sys\r\nimport json\r\nfrom typing import Dict, List, Optional\r\n\r\nclass JetsonDeployer:\r\n    """\r\n    Deploy models and applications to Jetson platforms\r\n    """\r\n    def __init__(self, jetson_ip: str, username: str = "jetson", password: str = "jetson"):\r\n        self.jetson_ip = jetson_ip\r\n        self.username = username\r\n        self.password = password\r\n\r\n    def setup_jetson_environment(self) -> bool:\r\n        """\r\n        Setup Jetson environment with required packages\r\n        """\r\n        setup_commands = [\r\n            "sudo apt update",\r\n            "sudo apt install -y python3-pip python3-dev",\r\n            "pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118",\r\n            "pip3 install numpy scipy matplotlib",\r\n            "pip3 install opencv-python",\r\n            "pip3 install pycuda",  # For TensorRT\r\n        ]\r\n\r\n        for command in setup_commands:\r\n            try:\r\n                result = subprocess.run(\r\n                    command.split(),\r\n                    capture_output=True,\r\n                    text=True,\r\n                    timeout=300\r\n                )\r\n                if result.returncode != 0:\r\n                    print(f"Command failed: {command}")\r\n                    print(f"Error: {result.stderr}")\r\n                    return False\r\n            except subprocess.TimeoutExpired:\r\n                print(f"Command timed out: {command}")\r\n                return False\r\n\r\n        return True\r\n\r\n    def deploy_model_to_jetson(self, model_path: str, destination_path: str = "/home/jetson/models/") -> bool:\r\n        """\r\n        Deploy optimized model to Jetson\r\n        """\r\n        # Use scp to copy model to Jetson\r\n        scp_command = [\r\n            "scp",\r\n            "-o", "StrictHostKeyChecking=no",\r\n            model_path,\r\n            f"{self.username}@{self.jetson_ip}:{destination_path}"\r\n        ]\r\n\r\n        try:\r\n            result = subprocess.run(scp_command, capture_output=True, text=True, timeout=600)\r\n            if result.returncode != 0:\r\n                print(f"SCP failed: {result.stderr}")\r\n                return False\r\n            return True\r\n        except subprocess.TimeoutExpired:\r\n            print("SCP timed out")\r\n            return False\r\n\r\n    def deploy_application(self, app_files: List[str], destination: str = "/home/jetson/app/") -> bool:\r\n        """\r\n        Deploy application files to Jetson\r\n        """\r\n        # Create directory on Jetson\r\n        mkdir_command = [\r\n            "ssh",\r\n            "-o", "StrictHostKeyChecking=no",\r\n            f"{self.username}@{self.jetson_ip}",\r\n            f"mkdir -p {destination}"\r\n        ]\r\n\r\n        result = subprocess.run(mkdir_command, capture_output=True, text=True)\r\n        if result.returncode != 0:\r\n            print(f"Failed to create directory: {result.stderr}")\r\n            return False\r\n\r\n        # Copy each file\r\n        for file_path in app_files:\r\n            scp_command = [\r\n                "scp",\r\n                "-o", "StrictHostKeyChecking=no",\r\n                file_path,\r\n                f"{self.username}@{self.jetson_ip}:{destination}"\r\n            ]\r\n\r\n            result = subprocess.run(scp_command, capture_output=True, text=True, timeout=300)\r\n            if result.returncode != 0:\r\n                print(f"Failed to copy {file_path}: {result.stderr}")\r\n                return False\r\n\r\n        return True\r\n\r\n    def start_jetson_service(self, service_name: str) -> bool:\r\n        """\r\n        Start a service on the Jetson\r\n        """\r\n        start_command = [\r\n            "ssh",\r\n            "-o", "StrictHostKeyChecking=no",\r\n            f"{self.username}@{self.jetson_ip}",\r\n            f"cd /home/jetson/app && python3 {service_name}.py"\r\n        ]\r\n\r\n        try:\r\n            # Run in background using nohup\r\n            full_command = " ".join(start_command) + " > /tmp/service.log 2>&1 &"\r\n            result = subprocess.run(\r\n                ["ssh", f"{self.username}@{self.jetson_ip}", full_command],\r\n                capture_output=True,\r\n                text=True\r\n            )\r\n            return result.returncode == 0\r\n        except Exception as e:\r\n            print(f"Failed to start service: {e}")\r\n            return False\n'})}),"\n",(0,i.jsx)(n.h3,{id:"3-real-world-testing-framework",children:"3. Real-World Testing Framework"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# real_world_tester.py\r\nimport time\r\nimport numpy as np\r\nfrom typing import Dict, List, Callable, Any\r\nimport logging\r\n\r\nclass RealWorldTester:\r\n    """\r\n    Framework for testing sim-to-real transfer in real environments\r\n    """\r\n    def __init__(self, robot_interface):\r\n        self.robot_interface = robot_interface\r\n        self.logger = logging.getLogger(__name__)\r\n        self.test_results = []\r\n\r\n    def run_transfer_validation_test(self, sim_model, real_robot, test_scenarios: List[Dict]) -> Dict:\r\n        """\r\n        Run validation tests to compare sim vs real performance\r\n        """\r\n        results = {\r\n            \'tests_run\': len(test_scenarios),\r\n            \'sim_performance\': [],\r\n            \'real_performance\': [],\r\n            \'transfer_gap\': [],\r\n            \'success_rate\': 0.0\r\n        }\r\n\r\n        successful_tests = 0\r\n\r\n        for i, scenario in enumerate(test_scenarios):\r\n            self.logger.info(f"Running test scenario {i+1}/{len(test_scenarios)}")\r\n\r\n            # Run in simulation\r\n            sim_result = self._run_scenario_in_simulation(sim_model, scenario)\r\n\r\n            # Run in real world\r\n            real_result = self._run_scenario_on_real_robot(real_robot, scenario)\r\n\r\n            # Compare results\r\n            performance_gap = self._calculate_performance_gap(sim_result, real_result)\r\n\r\n            results[\'sim_performance\'].append(sim_result)\r\n            results[\'real_performance\'].append(real_result)\r\n            results[\'transfer_gap\'].append(performance_gap)\r\n\r\n            if performance_gap < 0.2:  # If gap is less than 20%, consider successful\r\n                successful_tests += 1\r\n\r\n        results[\'success_rate\'] = successful_tests / len(test_scenarios) if test_scenarios else 0.0\r\n\r\n        return results\r\n\r\n    def _run_scenario_in_simulation(self, model, scenario: Dict) -> Dict:\r\n        """\r\n        Run a scenario in simulation\r\n        """\r\n        # Reset simulation to scenario start state\r\n        self._setup_scenario_state(scenario[\'start_state\'])\r\n\r\n        # Execute the task\r\n        start_time = time.time()\r\n        success = self._execute_task(model, scenario[\'task\'])\r\n        end_time = time.time()\r\n\r\n        return {\r\n            \'success\': success,\r\n            \'execution_time\': end_time - start_time,\r\n            \'trajectory_error\': self._calculate_trajectory_error(scenario[\'expected_trajectory\']),\r\n            \'energy_consumption\': self._calculate_energy_consumption()\r\n        }\r\n\r\n    def _run_scenario_on_real_robot(self, robot, scenario: Dict) -> Dict:\r\n        """\r\n        Run a scenario on the real robot\r\n        """\r\n        # Set initial state\r\n        self._set_robot_initial_state(robot, scenario[\'start_state\'])\r\n\r\n        # Execute the task\r\n        start_time = time.time()\r\n        success = self._execute_real_task(robot, scenario[\'task\'])\r\n        end_time = time.time()\r\n\r\n        return {\r\n            \'success\': success,\r\n            \'execution_time\': end_time - start_time,\r\n            \'trajectory_error\': self._calculate_real_trajectory_error(scenario[\'expected_trajectory\']),\r\n            \'energy_consumption\': self._calculate_real_energy_consumption()\r\n        }\r\n\r\n    def _calculate_performance_gap(self, sim_result: Dict, real_result: Dict) -> float:\r\n        """\r\n        Calculate the performance gap between simulation and real results\r\n        """\r\n        # Calculate normalized difference in key metrics\r\n        time_gap = abs(sim_result[\'execution_time\'] - real_result[\'execution_time\']) / sim_result[\'execution_time\']\r\n        success_gap = 0.0 if sim_result[\'success\'] == real_result[\'success\'] else 1.0\r\n\r\n        # Weighted average of gaps\r\n        weighted_gap = 0.5 * time_gap + 0.5 * success_gap\r\n\r\n        return weighted_gap\r\n\r\n    def adaptive_transfer_tuning(self, initial_model, test_results: Dict) -> Any:\r\n        """\r\n        Adapt the model based on real-world test results\r\n        """\r\n        # Analyze the transfer gap\r\n        avg_gap = np.mean(test_results[\'transfer_gap\'])\r\n\r\n        if avg_gap > 0.3:  # High gap, significant adaptation needed\r\n            self.logger.info("High transfer gap detected, applying significant adaptations")\r\n            adapted_model = self._apply_major_adaptations(initial_model, test_results)\r\n        elif avg_gap > 0.1:  # Moderate gap, minor adaptations\r\n            self.logger.info("Moderate transfer gap detected, applying minor adaptations")\r\n            adapted_model = self._apply_minor_adaptations(initial_model, test_results)\r\n        else:  # Low gap, minimal changes needed\r\n            self.logger.info("Low transfer gap, minimal adaptations required")\r\n            adapted_model = initial_model\r\n\r\n        return adapted_model\r\n\r\n    def _apply_minor_adaptations(self, model, test_results: Dict) -> Any:\r\n        """\r\n        Apply minor adaptations to improve sim-to-real transfer\r\n        """\r\n        # Adjust control gains based on performance differences\r\n        # Tune sensor noise models based on real sensor data\r\n        # Minor adjustments to dynamics parameters\r\n\r\n        # For this example, we\'ll adjust a simple gain\r\n        adaptation_factor = 1.0 + np.mean(test_results[\'transfer_gap\']) * 0.1\r\n        adapted_model = self._adjust_model_gains(model, adaptation_factor)\r\n\r\n        return adapted_model\r\n\r\n    def _apply_major_adaptations(self, model, test_results: Dict) -> Any:\r\n        """\r\n        Apply major adaptations for significant transfer gaps\r\n        """\r\n        # Retrain with real-world data\r\n        # Update dynamics models significantly\r\n        # Implement domain adaptation techniques\r\n\r\n        # For this example, we\'ll implement a more comprehensive adaptation\r\n        real_data = self._collect_real_world_data(test_results)\r\n        adapted_model = self._retrain_with_real_data(model, real_data)\r\n\r\n        return adapted_model\r\n\r\n    def generate_transfer_report(self, test_results: Dict, model_path: str) -> str:\r\n        """\r\n        Generate a comprehensive transfer validation report\r\n        """\r\n        report = f"""\r\n# Sim-to-Real Transfer Validation Report\r\n\r\n## Model Information\r\n- Model Path: {model_path}\r\n- Transfer Date: {time.strftime(\'%Y-%m-%d %H:%M:%S\')}\r\n- Test Scenarios: {test_results[\'tests_run\']}\r\n\r\n## Performance Metrics\r\n- Success Rate: {test_results[\'success_rate\']:.2%}\r\n- Average Transfer Gap: {np.mean(test_results[\'transfer_gap\']):.2%}\r\n- Max Transfer Gap: {np.max(test_results[\'transfer_gap\']):.2%}\r\n- Min Transfer Gap: {np.min(test_results[\'transfer_gap\']):.2%}\r\n\r\n## Recommendations\r\n"""\r\n\r\n        avg_gap = np.mean(test_results[\'transfer_gap\'])\r\n        if avg_gap > 0.3:\r\n            report += "- Significant model adaptations required\\n"\r\n            report += "- Consider additional domain randomization\\n"\r\n            report += "- Collect more real-world training data\\n"\r\n        elif avg_gap > 0.1:\r\n            report += "- Minor model adaptations recommended\\n"\r\n            report += "- Fine-tune control parameters\\n"\r\n            report += "- Verify sensor calibration\\n"\r\n        else:\r\n            report += "- Model ready for deployment\\n"\r\n            report += "- Transfer performance is acceptable\\n"\r\n\r\n        report += "\\n## Detailed Results\\n"\r\n        for i, (sim_perf, real_perf, gap) in enumerate(zip(\r\n            test_results[\'sim_performance\'],\r\n            test_results[\'real_performance\'],\r\n            test_results[\'transfer_gap\']\r\n        )):\r\n            report += f"Test {i+1}: Gap = {gap:.2%}, Sim Success = {sim_perf[\'success\']}, Real Success = {real_perf[\'success\']}\\n"\r\n\r\n        # Save report\r\n        report_path = f"transfer_validation_report_{int(time.time())}.md"\r\n        with open(report_path, \'w\') as f:\r\n            f.write(report)\r\n\r\n        return report_path\n'})}),"\n",(0,i.jsx)(n.h2,{id:"jetson-specific-optimization-guide",children:"Jetson-Specific Optimization Guide"}),"\n",(0,i.jsx)(n.h3,{id:"1-power-management",children:"1. Power Management"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Jetson power management settings\r\n# Set to maximum performance mode\r\nsudo nvpmodel -m 0\r\n\r\n# Enable all CPU cores\r\necho 0-3 > /sys/devices/system/cpu/online  # For 4-core Jetson\r\n\r\n# Set CPU governor to performance\r\necho performance | sudo tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-thermal-management",children:"2. Thermal Management"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Monitor temperature: ",(0,i.jsx)(n.code,{children:"cat /sys/class/thermal/thermal_zone*/temp"})]}),"\n",(0,i.jsx)(n.li,{children:"Implement thermal throttling protection"}),"\n",(0,i.jsx)(n.li,{children:"Use heatsinks and fans for sustained performance"}),"\n",(0,i.jsxs)(n.li,{children:["Monitor GPU utilization: ",(0,i.jsx)(n.code,{children:"sudo tegrastats"})]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"3-memory-optimization",children:"3. Memory Optimization"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Use TensorRT for model optimization"}),"\n",(0,i.jsx)(n.li,{children:"Implement memory pooling"}),"\n",(0,i.jsx)(n.li,{children:"Optimize data loading pipelines"}),"\n",(0,i.jsx)(n.li,{children:"Use appropriate precision (FP16 instead of FP32 when possible)"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"testing-and-validation",children:"Testing and Validation"}),"\n",(0,i.jsx)(n.h3,{id:"1-gradual-deployment-strategy",children:"1. Gradual Deployment Strategy"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Simulation Testing"}),": Verify model in simulation with domain randomization"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Hardware-in-the-Loop"}),": Test with real sensors but simulated actuators"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Limited Real Testing"}),": Start with safe, limited movements"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Full Deployment"}),": Gradual increase in complexity and range of motion"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"2-safety-mechanisms",children:"2. Safety Mechanisms"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Implement hardware safety limits"}),"\n",(0,i.jsx)(n.li,{children:"Use software watchdog timers"}),"\n",(0,i.jsx)(n.li,{children:"Implement emergency stop procedures"}),"\n",(0,i.jsx)(n.li,{children:"Monitor system health continuously"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"resources-and-further-reading",children:"Resources and Further Reading"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://docs.nvidia.com/jetson/",children:"NVIDIA Jetson Documentation"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://docs.nvidia.com/deeplearning/tensorrt/developer-guide/index.html",children:"TensorRT Optimization Guide"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/dusty-nv/jetson-containers",children:"ROS on Jetson"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/NVIDIA-ISAAC-ROS",children:"Isaac ROS for Jetson"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://arxiv.org/abs/1703.06907",children:"Domain Randomization for Robotics"})}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(m,{...e})}):m(e)}},7074:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>o});var t=r(6540);const i={},s=t.createContext(i);function a(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);