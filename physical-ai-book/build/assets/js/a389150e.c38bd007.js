"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[785],{4135:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>i,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>a,toc:()=>g});const a=JSON.parse('{"id":"isaac-platform/goal-sending-interface","title":"Goal Sending Interface for Navigation Testing","description":"Overview","source":"@site/docs/isaac-platform/goal-sending-interface.md","sourceDirName":"isaac-platform","slug":"/isaac-platform/goal-sending-interface","permalink":"/docs/isaac-platform/goal-sending-interface","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/isaac-platform/goal-sending-interface.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Navigation Validation Guide","permalink":"/docs/isaac-platform/navigation-validation-guide"},"next":{"title":"Perception Pipeline Performance Benchmark Guide","permalink":"/docs/isaac-platform/perception-performance-benchmark"}}');var l=n(4848),t=n(7074);const o={},s="Goal Sending Interface for Navigation Testing",i={},g=[{value:"Overview",id:"overview",level:2},{value:"Understanding Goal Sending Interface",id:"understanding-goal-sending-interface",level:2},{value:"Components of Goal Sending Interface",id:"components-of-goal-sending-interface",level:3},{value:"Key Features",id:"key-features",level:3},{value:"Basic Goal Sending Implementation",id:"basic-goal-sending-implementation",level:2},{value:"1. Simple Goal Publisher Node",id:"1-simple-goal-publisher-node",level:3},{value:"2. Advanced Goal Manager Node",id:"2-advanced-goal-manager-node",level:3},{value:"RViz2 Goal Interface",id:"rviz2-goal-interface",level:2},{value:"1. RViz2 Goal Tool Configuration",id:"1-rviz2-goal-tool-configuration",level:3},{value:"2. Goal Visualization Node",id:"2-goal-visualization-node",level:3},{value:"Test Scenario Implementation",id:"test-scenario-implementation",level:2},{value:"1. Navigation Test Scenarios",id:"1-navigation-test-scenarios",level:3},{value:"Command Line Interface",id:"command-line-interface",level:2},{value:"1. Goal Command Line Tool",id:"1-goal-command-line-tool",level:3},{value:"Integration Launch Files",id:"integration-launch-files",level:2},{value:"1. Complete Goal Interface Launch",id:"1-complete-goal-interface-launch",level:3},{value:"Testing and Validation",id:"testing-and-validation",level:2},{value:"1. Goal Interface Testing Script",id:"1-goal-interface-testing-script",level:3},{value:"Best Practices and Tips",id:"best-practices-and-tips",level:2},{value:"1. Goal Interface Best Practices",id:"1-goal-interface-best-practices",level:3},{value:"2. Performance Considerations",id:"2-performance-considerations",level:3},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(r.header,{children:(0,l.jsx)(r.h1,{id:"goal-sending-interface-for-navigation-testing",children:"Goal Sending Interface for Navigation Testing"})}),"\n",(0,l.jsx)(r.h2,{id:"overview",children:"Overview"}),"\n",(0,l.jsx)(r.p,{children:"This guide provides comprehensive instructions for implementing a goal sending interface for navigation testing. The interface allows users to send navigation goals to the robot, supports batch testing, and provides feedback on goal execution status. This is essential for validating navigation performance and testing different scenarios."}),"\n",(0,l.jsx)(r.h2,{id:"understanding-goal-sending-interface",children:"Understanding Goal Sending Interface"}),"\n",(0,l.jsx)(r.h3,{id:"components-of-goal-sending-interface",children:"Components of Goal Sending Interface"}),"\n",(0,l.jsxs)(r.ol,{children:["\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:"Goal Publisher"}),": Sends navigation goals to the navigation system"]}),"\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:"Goal Manager"}),": Manages multiple goals, sequences, and priorities"]}),"\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:"Feedback Monitor"}),": Tracks goal execution status and results"]}),"\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:"Test Sequencer"}),": Runs predefined test sequences automatically"]}),"\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:"Visualization Interface"}),": Shows goals and progress in RViz2"]}),"\n"]}),"\n",(0,l.jsx)(r.h3,{id:"key-features",children:"Key Features"}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsx)(r.li,{children:"Single goal sending"}),"\n",(0,l.jsx)(r.li,{children:"Batch goal processing"}),"\n",(0,l.jsx)(r.li,{children:"Goal sequence execution"}),"\n",(0,l.jsx)(r.li,{children:"Real-time feedback monitoring"}),"\n",(0,l.jsx)(r.li,{children:"Test result recording"}),"\n",(0,l.jsx)(r.li,{children:"Integration with navigation stack"}),"\n"]}),"\n",(0,l.jsx)(r.h2,{id:"basic-goal-sending-implementation",children:"Basic Goal Sending Implementation"}),"\n",(0,l.jsx)(r.h3,{id:"1-simple-goal-publisher-node",children:"1. Simple Goal Publisher Node"}),"\n",(0,l.jsxs)(r.p,{children:["Create a basic goal publisher node ",(0,l.jsx)(r.code,{children:"simple_goal_publisher.py"}),":"]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\"\"\"\r\nSimple Goal Publisher for Navigation Testing\r\n\"\"\"\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import PoseStamped, Point\r\nfrom nav2_msgs.action import NavigateToPose\r\nfrom rclpy.action import ActionClient\r\nfrom std_msgs.msg import String\r\nimport time\r\nimport math\r\n\r\n\r\nclass SimpleGoalPublisher(Node):\r\n    def __init__(self):\r\n        super().__init__('simple_goal_publisher')\r\n\r\n        # Navigation action client\r\n        self.nav_client = ActionClient(self, NavigateToPose, 'navigate_to_pose')\r\n\r\n        # Publishers\r\n        self.goal_status_pub = self.create_publisher(String, '/goal_status', 10)\r\n\r\n        # Subscriptions\r\n        self.goal_command_sub = self.create_subscription(\r\n            String, '/goal_command', self.goal_command_callback, 10)\r\n\r\n        # Internal state\r\n        self.current_goal_id = 0\r\n        self.goal_queue = []\r\n        self.is_executing = False\r\n\r\n        self.get_logger().info('Simple Goal Publisher initialized')\r\n\r\n    def goal_command_callback(self, msg):\r\n        \"\"\"Handle goal commands\"\"\"\r\n        command = msg.data.strip()\r\n\r\n        if command.startswith('send_goal:'):\r\n            # Parse goal coordinates: send_goal:x,y,yaw\r\n            try:\r\n                parts = command.split(':')[1].split(',')\r\n                x = float(parts[0])\r\n                y = float(parts[1])\r\n                yaw = float(parts[2]) if len(parts) > 2 else 0.0\r\n\r\n                self.send_single_goal(x, y, yaw)\r\n            except (ValueError, IndexError):\r\n                self.get_logger().error(f'Invalid goal command format: {command}')\r\n        elif command == 'cancel_goal':\r\n            self.cancel_current_goal()\r\n        elif command.startswith('queue_goal:'):\r\n            # Queue a goal for later execution\r\n            try:\r\n                parts = command.split(':')[1].split(',')\r\n                x = float(parts[0])\r\n                y = float(parts[1])\r\n                yaw = float(parts[2]) if len(parts) > 2 else 0.0\r\n\r\n                self.queue_goal(x, y, yaw)\r\n            except (ValueError, IndexError):\r\n                self.get_logger().error(f'Invalid queue command format: {command}')\r\n\r\n    def send_single_goal(self, x, y, yaw):\r\n        \"\"\"Send a single navigation goal\"\"\"\r\n        if not self.nav_client.wait_for_server(timeout_sec=5.0):\r\n            self.get_logger().error('Navigation server not available')\r\n            return\r\n\r\n        goal_msg = NavigateToPose.Goal()\r\n        goal_msg.pose.header.frame_id = 'map'\r\n        goal_msg.pose.header.stamp = self.get_clock().now().to_msg()\r\n        goal_msg.pose.pose.position.x = x\r\n        goal_msg.pose.pose.position.y = y\r\n        goal_msg.pose.pose.position.z = 0.0\r\n\r\n        # Convert yaw to quaternion\r\n        goal_msg.pose.pose.orientation.z = math.sin(yaw / 2.0)\r\n        goal_msg.pose.pose.orientation.w = math.cos(yaw / 2.0)\r\n\r\n        self.is_executing = True\r\n        self.current_goal_id += 1\r\n\r\n        self.get_logger().info(f'Sending goal {self.current_goal_id}: ({x}, {y}, {yaw})')\r\n\r\n        future = self.nav_client.send_goal_async(goal_msg)\r\n        future.add_done_callback(self.goal_response_callback)\r\n\r\n    def goal_response_callback(self, future):\r\n        \"\"\"Handle goal response\"\"\"\r\n        goal_handle = future.result()\r\n        if not goal_handle.accepted:\r\n            self.get_logger().error('Goal was rejected')\r\n            self.is_executing = False\r\n            return\r\n\r\n        self.get_logger().info('Goal accepted, waiting for result...')\r\n        result_future = goal_handle.get_result_async()\r\n        result_future.add_done_callback(self.result_callback)\r\n\r\n    def result_callback(self, future):\r\n        \"\"\"Handle navigation result\"\"\"\r\n        result = future.result().result\r\n        status = future.result().status\r\n\r\n        if result is not None and status == 3:  # STATUS_SUCCEEDED\r\n            self.get_logger().info('Goal reached successfully')\r\n            status_msg = String()\r\n            status_msg.data = 'GOAL_SUCCEEDED'\r\n            self.goal_status_pub.publish(status_msg)\r\n        else:\r\n            self.get_logger().error(f'Goal failed with status: {status}')\r\n            status_msg = String()\r\n            status_msg.data = 'GOAL_FAILED'\r\n            self.goal_status_pub.publish(status_msg)\r\n\r\n        self.is_executing = False\r\n\r\n        # Process next queued goal if available\r\n        if self.goal_queue:\r\n            next_goal = self.goal_queue.pop(0)\r\n            self.send_single_goal(next_goal[0], next_goal[1], next_goal[2])\r\n\r\n    def queue_goal(self, x, y, yaw):\r\n        \"\"\"Add a goal to the queue\"\"\"\r\n        self.goal_queue.append((x, y, yaw))\r\n        self.get_logger().info(f'Goal queued: ({x}, {y}, {yaw}). Queue size: {len(self.goal_queue)}')\r\n\r\n        # If not currently executing, start processing\r\n        if not self.is_executing and len(self.goal_queue) == 1:\r\n            next_goal = self.goal_queue.pop(0)\r\n            self.send_single_goal(next_goal[0], next_goal[1], next_goal[2])\r\n\r\n    def cancel_current_goal(self):\r\n        \"\"\"Cancel the current goal\"\"\"\r\n        self.get_logger().info('Canceling current goal')\r\n        # In a real implementation, you would cancel the goal here\r\n        self.is_executing = False\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    goal_publisher = SimpleGoalPublisher()\r\n\r\n    try:\r\n        rclpy.spin(goal_publisher)\r\n    except KeyboardInterrupt:\r\n        goal_publisher.get_logger().info('Goal publisher stopped by user')\r\n    finally:\r\n        goal_publisher.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,l.jsx)(r.h3,{id:"2-advanced-goal-manager-node",children:"2. Advanced Goal Manager Node"}),"\n",(0,l.jsxs)(r.p,{children:["Create a more sophisticated goal manager ",(0,l.jsx)(r.code,{children:"advanced_goal_manager.py"}),":"]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\"\"\"\r\nAdvanced Goal Manager for Navigation Testing\r\n\"\"\"\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import PoseStamped, PoseWithCovarianceStamped\r\nfrom nav2_msgs.action import NavigateToPose, NavigateThroughPoses\r\nfrom rclpy.action import ActionClient\r\nfrom std_msgs.msg import String, Int32, Float32\r\nfrom builtin_interfaces.msg import Time\r\nimport time\r\nimport math\r\nimport json\r\nfrom enum import Enum\r\nfrom dataclasses import dataclass\r\nfrom typing import List, Dict, Tuple\r\n\r\n\r\nclass GoalStatus(Enum):\r\n    PENDING = 0\r\n    ACTIVE = 1\r\n    SUCCEEDED = 2\r\n    FAILED = 3\r\n    CANCELLED = 4\r\n\r\n\r\n@dataclass\r\nclass NavigationGoal:\r\n    id: int\r\n    x: float\r\n    y: float\r\n    yaw: float\r\n    priority: int = 1\r\n    timeout: float = 30.0\r\n    created_time: float = 0.0\r\n    status: GoalStatus = GoalStatus.PENDING\r\n    execution_time: float = 0.0\r\n    result: str = \"\"\r\n\r\n\r\nclass AdvancedGoalManager(Node):\r\n    def __init__(self):\r\n        super().__init__('advanced_goal_manager')\r\n\r\n        # Parameters\r\n        self.declare_parameter('max_goals', 50)\r\n        self.declare_parameter('default_timeout', 60.0)\r\n        self.declare_parameter('goal_tolerance', 0.25)\r\n        self.declare_parameter('min_goal_spacing', 0.1)\r\n\r\n        self.max_goals = self.get_parameter('max_goals').value\r\n        self.default_timeout = self.get_parameter('default_timeout').value\r\n        self.goal_tolerance = self.get_parameter('goal_tolerance').value\r\n        self.min_goal_spacing = self.get_parameter('min_goal_spacing').value\r\n\r\n        # Navigation action clients\r\n        self.nav_to_pose_client = ActionClient(self, NavigateToPose, 'navigate_to_pose')\r\n        self.nav_through_poses_client = ActionClient(self, NavigateThroughPoses, 'navigate_through_poses')\r\n\r\n        # Publishers\r\n        self.goal_status_pub = self.create_publisher(String, '/goal_status', 10)\r\n        self.goal_count_pub = self.create_publisher(Int32, '/goal_count', 10)\r\n        self.goal_result_pub = self.create_publisher(String, '/goal_result', 10)\r\n        self.active_goal_pub = self.create_publisher(PoseStamped, '/active_goal', 10)\r\n\r\n        # Subscriptions\r\n        self.goal_command_sub = self.create_subscription(\r\n            String, '/goal_command', self.goal_command_callback, 10)\r\n        self.goals_batch_sub = self.create_subscription(\r\n            String, '/goals_batch', self.goals_batch_callback, 10)\r\n        self.initial_pose_sub = self.create_subscription(\r\n            PoseWithCovarianceStamped, '/initialpose', self.initial_pose_callback, 10)\r\n\r\n        # Internal state\r\n        self.goals: List[NavigationGoal] = []\r\n        self.active_goal_id = None\r\n        self.goal_id_counter = 0\r\n        self.current_robot_pose = None\r\n        self.active_goal_timer = None\r\n        self.timeout_timers = {}\r\n\r\n        # Timer for periodic status updates\r\n        self.status_timer = self.create_timer(1.0, self.publish_status)\r\n\r\n        self.get_logger().info('Advanced Goal Manager initialized')\r\n\r\n    def goal_command_callback(self, msg):\r\n        \"\"\"Handle goal commands\"\"\"\r\n        command = msg.data.strip()\r\n\r\n        if command.startswith('send_goal:'):\r\n            self.handle_send_goal_command(command)\r\n        elif command.startswith('send_goals:'):\r\n            self.handle_send_goals_command(command)\r\n        elif command.startswith('cancel_goal:'):\r\n            goal_id = int(command.split(':')[1])\r\n            self.cancel_goal(goal_id)\r\n        elif command == 'cancel_all':\r\n            self.cancel_all_goals()\r\n        elif command == 'get_status':\r\n            self.publish_all_goals_status()\r\n        elif command.startswith('set_priority:'):\r\n            self.handle_priority_command(command)\r\n\r\n    def goals_batch_callback(self, msg):\r\n        \"\"\"Handle batch goals command\"\"\"\r\n        try:\r\n            batch_data = json.loads(msg.data)\r\n            self.process_goals_batch(batch_data)\r\n        except json.JSONDecodeError:\r\n            self.get_logger().error(f'Invalid JSON in batch command: {msg.data}')\r\n\r\n    def initial_pose_callback(self, msg):\r\n        \"\"\"Update current robot pose\"\"\"\r\n        self.current_robot_pose = msg.pose.pose\r\n\r\n    def handle_send_goal_command(self, command):\r\n        \"\"\"Handle single goal command\"\"\"\r\n        try:\r\n            # Format: send_goal:x,y,yaw,priority,timeout\r\n            parts = command.split(':')[1].split(',')\r\n            x = float(parts[0])\r\n            y = float(parts[1])\r\n            yaw = float(parts[2]) if len(parts) > 2 else 0.0\r\n            priority = int(parts[3]) if len(parts) > 3 else 1\r\n            timeout = float(parts[4]) if len(parts) > 4 else self.default_timeout\r\n\r\n            goal_id = self.add_goal(x, y, yaw, priority, timeout)\r\n            self.get_logger().info(f'Added goal {goal_id}: ({x}, {y}, {yaw}) with priority {priority}')\r\n\r\n            # Start processing if no active goal\r\n            if self.active_goal_id is None:\r\n                self.process_next_goal()\r\n\r\n        except (ValueError, IndexError):\r\n            self.get_logger().error(f'Invalid goal command format: {command}')\r\n\r\n    def handle_send_goals_command(self, command):\r\n        \"\"\"Handle multiple goals command\"\"\"\r\n        try:\r\n            # Format: send_goals:[x1,y1,yaw1,priority1,timeout1];[x2,y2,yaw2,priority2,timeout2];...\r\n            goals_str = command.split(':')[1]\r\n            goals_data = [g.strip('[]').split(',') for g in goals_str.split(';') if g.strip()]\r\n\r\n            for goal_data in goals_data:\r\n                x = float(goal_data[0])\r\n                y = float(goal_data[1])\r\n                yaw = float(goal_data[2]) if len(goal_data) > 2 else 0.0\r\n                priority = int(goal_data[3]) if len(goal_data) > 3 else 1\r\n                timeout = float(goal_data[4]) if len(goal_data) > 4 else self.default_timeout\r\n\r\n                goal_id = self.add_goal(x, y, yaw, priority, timeout)\r\n                self.get_logger().info(f'Added batch goal {goal_id}: ({x}, {y}, {yaw})')\r\n\r\n            # Start processing if no active goal\r\n            if self.active_goal_id is None:\r\n                self.process_next_goal()\r\n\r\n        except (ValueError, IndexError):\r\n            self.get_logger().error(f'Invalid goals command format: {command}')\r\n\r\n    def handle_priority_command(self, command):\r\n        \"\"\"Handle priority setting command\"\"\"\r\n        try:\r\n            # Format: set_priority:goal_id,priority\r\n            parts = command.split(':')[1].split(',')\r\n            goal_id = int(parts[0])\r\n            new_priority = int(parts[1])\r\n\r\n            for goal in self.goals:\r\n                if goal.id == goal_id:\r\n                    goal.priority = new_priority\r\n                    self.get_logger().info(f'Updated priority for goal {goal_id} to {new_priority}')\r\n                    break\r\n            else:\r\n                self.get_logger().error(f'Goal {goal_id} not found')\r\n\r\n        except (ValueError, IndexError):\r\n            self.get_logger().error(f'Invalid priority command format: {command}')\r\n\r\n    def add_goal(self, x, y, yaw, priority=1, timeout=None) -> int:\r\n        \"\"\"Add a goal to the queue\"\"\"\r\n        if len(self.goals) >= self.max_goals:\r\n            self.get_logger().warn('Goal queue is full, removing lowest priority goal')\r\n            # Remove lowest priority goal\r\n            lowest_priority_goal = min(self.goals, key=lambda g: g.priority)\r\n            self.goals.remove(lowest_priority_goal)\r\n\r\n        self.goal_id_counter += 1\r\n        goal = NavigationGoal(\r\n            id=self.goal_id_counter,\r\n            x=x,\r\n            y=y,\r\n            yaw=yaw,\r\n            priority=priority,\r\n            timeout=timeout or self.default_timeout,\r\n            created_time=time.time()\r\n        )\r\n\r\n        self.goals.append(goal)\r\n        self.sort_goals_by_priority()\r\n\r\n        # Publish updated goal count\r\n        count_msg = Int32()\r\n        count_msg.data = len(self.goals)\r\n        self.goal_count_pub.publish(count_msg)\r\n\r\n        return self.goal_id_counter\r\n\r\n    def sort_goals_by_priority(self):\r\n        \"\"\"Sort goals by priority (higher priority first) and creation time\"\"\"\r\n        self.goals.sort(key=lambda g: (-g.priority, g.created_time))\r\n\r\n    def process_next_goal(self):\r\n        \"\"\"Process the next goal in the queue\"\"\"\r\n        if not self.goals:\r\n            self.get_logger().info('No more goals to process')\r\n            return\r\n\r\n        # Find next pending goal\r\n        next_goal = None\r\n        for goal in self.goals:\r\n            if goal.status == GoalStatus.PENDING:\r\n                next_goal = goal\r\n                break\r\n\r\n        if next_goal:\r\n            self.execute_goal(next_goal)\r\n\r\n    def execute_goal(self, goal: NavigationGoal):\r\n        \"\"\"Execute a navigation goal\"\"\"\r\n        if not self.nav_to_pose_client.wait_for_server(timeout_sec=5.0):\r\n            self.get_logger().error('Navigation server not available')\r\n            goal.status = GoalStatus.FAILED\r\n            self.publish_goal_result(goal.id, \"Navigation server unavailable\")\r\n            self.process_next_goal()\r\n            return\r\n\r\n        goal.status = GoalStatus.ACTIVE\r\n        self.active_goal_id = goal.id\r\n\r\n        # Create navigation goal message\r\n        nav_goal = NavigateToPose.Goal()\r\n        nav_goal.pose.header.frame_id = 'map'\r\n        nav_goal.pose.header.stamp = self.get_clock().now().to_msg()\r\n        nav_goal.pose.pose.position.x = goal.x\r\n        nav_goal.pose.pose.position.y = goal.y\r\n        nav_goal.pose.pose.position.z = 0.0\r\n\r\n        # Convert yaw to quaternion\r\n        nav_goal.pose.pose.orientation.z = math.sin(goal.yaw / 2.0)\r\n        nav_goal.pose.pose.orientation.w = math.cos(goal.yaw / 2.0)\r\n\r\n        self.get_logger().info(f'Executing goal {goal.id}: ({goal.x}, {goal.y}, {goal.yaw})')\r\n\r\n        # Publish active goal for visualization\r\n        active_goal_msg = PoseStamped()\r\n        active_goal_msg.header.frame_id = 'map'\r\n        active_goal_msg.header.stamp = self.get_clock().now().to_msg()\r\n        active_goal_msg.pose.position.x = goal.x\r\n        active_goal_msg.pose.position.y = goal.y\r\n        active_goal_msg.pose.position.z = 0.0\r\n        active_goal_msg.pose.orientation.z = math.sin(goal.yaw / 2.0)\r\n        active_goal_msg.pose.orientation.w = math.cos(goal.yaw / 2.0)\r\n        self.active_goal_pub.publish(active_goal_msg)\r\n\r\n        # Start timeout timer\r\n        self.timeout_timers[goal.id] = self.create_timer(\r\n            goal.timeout,\r\n            lambda: self.handle_goal_timeout(goal.id)\r\n        )\r\n\r\n        # Send goal\r\n        future = self.nav_to_pose_client.send_goal_async(nav_goal)\r\n        future.add_done_callback(lambda f: self.goal_response_callback(f, goal.id))\r\n\r\n    def goal_response_callback(self, future, goal_id):\r\n        \"\"\"Handle goal response\"\"\"\r\n        goal = self.find_goal_by_id(goal_id)\r\n        if not goal:\r\n            return\r\n\r\n        goal_handle = future.result()\r\n        if not goal_handle.accepted:\r\n            self.get_logger().error(f'Goal {goal_id} was rejected')\r\n            goal.status = GoalStatus.FAILED\r\n            goal.result = 'Goal rejected by navigation server'\r\n            self.publish_goal_result(goal_id, goal.result)\r\n            self.process_next_goal()\r\n            return\r\n\r\n        self.get_logger().info(f'Goal {goal_id} accepted, waiting for result...')\r\n        result_future = goal_handle.get_result_async()\r\n        result_future.add_done_callback(lambda f: self.result_callback(f, goal_id))\r\n\r\n    def result_callback(self, future, goal_id):\r\n        \"\"\"Handle navigation result\"\"\"\r\n        goal = self.find_goal_by_id(goal_id)\r\n        if not goal:\r\n            return\r\n\r\n        # Cancel timeout timer\r\n        if goal_id in self.timeout_timers:\r\n            self.timeout_timers[goal_id].cancel()\r\n            del self.timeout_timers[goal_id]\r\n\r\n        result = future.result().result\r\n        status = future.result().status\r\n\r\n        if result is not None and status == 3:  # STATUS_SUCCEEDED\r\n            goal.status = GoalStatus.SUCCEEDED\r\n            goal.result = 'Goal reached successfully'\r\n            goal.execution_time = time.time() - goal.created_time\r\n            self.get_logger().info(f'Goal {goal_id} succeeded in {goal.execution_time:.2f}s')\r\n        else:\r\n            goal.status = GoalStatus.FAILED\r\n            goal.result = f'Goal failed with status: {status}'\r\n            self.get_logger().error(f'Goal {goal_id} failed: {goal.result}')\r\n\r\n        # Publish result\r\n        self.publish_goal_result(goal_id, goal.result)\r\n\r\n        # Clear active goal if it's the current one\r\n        if self.active_goal_id == goal_id:\r\n            self.active_goal_id = None\r\n\r\n        # Process next goal\r\n        self.process_next_goal()\r\n\r\n    def handle_goal_timeout(self, goal_id):\r\n        \"\"\"Handle goal timeout\"\"\"\r\n        goal = self.find_goal_by_id(goal_id)\r\n        if not goal:\r\n            return\r\n\r\n        self.get_logger().warn(f'Goal {goal_id} timed out')\r\n        goal.status = GoalStatus.FAILED\r\n        goal.result = f'Goal timed out after {goal.timeout}s'\r\n\r\n        # Publish result\r\n        self.publish_goal_result(goal_id, goal.result)\r\n\r\n        # Clear active goal if it's the current one\r\n        if self.active_goal_id == goal_id:\r\n            self.active_goal_id = None\r\n            self.process_next_goal()\r\n\r\n    def cancel_goal(self, goal_id):\r\n        \"\"\"Cancel a specific goal\"\"\"\r\n        goal = self.find_goal_by_id(goal_id)\r\n        if not goal:\r\n            self.get_logger().error(f'Goal {goal_id} not found')\r\n            return\r\n\r\n        if goal.status == GoalStatus.PENDING:\r\n            # Remove from queue\r\n            self.goals.remove(goal)\r\n            self.get_logger().info(f'Cancelled pending goal {goal_id}')\r\n        elif goal.status == GoalStatus.ACTIVE and self.active_goal_id == goal_id:\r\n            # TODO: In a real implementation, cancel the active goal\r\n            goal.status = GoalStatus.CANCELLED\r\n            goal.result = 'Goal cancelled by user'\r\n            self.active_goal_id = None\r\n            self.get_logger().info(f'Cancelled active goal {goal_id}')\r\n            self.process_next_goal()\r\n        else:\r\n            self.get_logger().warn(f'Cannot cancel goal {goal_id} with status {goal.status}')\r\n\r\n        # Publish result\r\n        self.publish_goal_result(goal_id, goal.result)\r\n\r\n    def cancel_all_goals(self):\r\n        \"\"\"Cancel all pending goals\"\"\"\r\n        pending_goals = [g for g in self.goals if g.status == GoalStatus.PENDING]\r\n        for goal in pending_goals:\r\n            goal.status = GoalStatus.CANCELLED\r\n            goal.result = 'Goal cancelled by user'\r\n            self.publish_goal_result(goal.id, goal.result)\r\n\r\n        self.goals = [g for g in self.goals if g.status != GoalStatus.PENDING]\r\n        self.get_logger().info(f'Cancelled {len(pending_goals)} pending goals')\r\n\r\n    def process_goals_batch(self, batch_data):\r\n        \"\"\"Process a batch of goals from JSON data\"\"\"\r\n        try:\r\n            for goal_data in batch_data.get('goals', []):\r\n                x = goal_data.get('x', 0.0)\r\n                y = goal_data.get('y', 0.0)\r\n                yaw = goal_data.get('yaw', 0.0)\r\n                priority = goal_data.get('priority', 1)\r\n                timeout = goal_data.get('timeout', self.default_timeout)\r\n\r\n                goal_id = self.add_goal(x, y, yaw, priority, timeout)\r\n                self.get_logger().info(f'Added batch goal {goal_id}: ({x}, {y}, {yaw})')\r\n\r\n            # Start processing if no active goal\r\n            if self.active_goal_id is None:\r\n                self.process_next_goal()\r\n\r\n        except Exception as e:\r\n            self.get_logger().error(f'Error processing batch goals: {e}')\r\n\r\n    def find_goal_by_id(self, goal_id) -> NavigationGoal:\r\n        \"\"\"Find a goal by its ID\"\"\"\r\n        for goal in self.goals:\r\n            if goal.id == goal_id:\r\n                return goal\r\n        return None\r\n\r\n    def publish_goal_result(self, goal_id, result):\r\n        \"\"\"Publish goal result\"\"\"\r\n        result_msg = String()\r\n        result_msg.data = f'GOAL_{goal_id}:{result}'\r\n        self.goal_result_pub.publish(result_msg)\r\n\r\n    def publish_status(self):\r\n        \"\"\"Publish current status\"\"\"\r\n        status_msg = String()\r\n        status_msg.data = f'ACTIVE_GOALS:{len([g for g in self.goals if g.status == GoalStatus.ACTIVE])},PENDING_GOALS:{len([g for g in self.goals if g.status == GoalStatus.PENDING])},COMPLETED_GOALS:{len([g for g in self.goals if g.status in [GoalStatus.SUCCEEDED, GoalStatus.FAILED, GoalStatus.CANCELLED]])}'\r\n        self.goal_status_pub.publish(status_msg)\r\n\r\n    def publish_all_goals_status(self):\r\n        \"\"\"Publish status of all goals\"\"\"\r\n        status_data = []\r\n        for goal in self.goals:\r\n            status_data.append({\r\n                'id': goal.id,\r\n                'status': goal.status.name,\r\n                'x': goal.x,\r\n                'y': goal.y,\r\n                'yaw': goal.yaw,\r\n                'priority': goal.priority,\r\n                'result': goal.result\r\n            })\r\n\r\n        status_msg = String()\r\n        status_msg.data = json.dumps(status_data)\r\n        self.goal_status_pub.publish(status_msg)\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    goal_manager = AdvancedGoalManager()\r\n\r\n    try:\r\n        rclpy.spin(goal_manager)\r\n    except KeyboardInterrupt:\r\n        goal_manager.get_logger().info('Goal manager stopped by user')\r\n    finally:\r\n        goal_manager.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,l.jsx)(r.h2,{id:"rviz2-goal-interface",children:"RViz2 Goal Interface"}),"\n",(0,l.jsx)(r.h3,{id:"1-rviz2-goal-tool-configuration",children:"1. RViz2 Goal Tool Configuration"}),"\n",(0,l.jsxs)(r.p,{children:["Create an RViz2 configuration file ",(0,l.jsx)(r.code,{children:"goal_interface.rviz"}),":"]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-yaml",children:'Panels:\r\n  - Class: rviz_common/Displays\r\n    Help Height: 78\r\n    Name: Displays\r\n    Property Tree Widget:\r\n      Expanded:\r\n        - /Global Options1\r\n        - /Status1\r\n        - /Grid1\r\n        - /TF1\r\n        - /Path1\r\n        - /Pose1\r\n        - /MarkerArray1\r\n      Splitter Ratio: 0.5\r\n    Tree Height: 787\r\n  - Class: rviz_common/Selection\r\n    Name: Selection\r\n  - Class: rviz_common/Tool Properties\r\n    Expanded:\r\n      - /2D Goal1\r\n      - /2D Pose1\r\n      - /Publish Point1\r\n    Name: Tool Properties\r\n    Splitter Ratio: 0.5886790156364441\r\n  - Class: rviz_common/Views\r\n    Expanded:\r\n      - /Current View1\r\n    Name: Views\r\n    Splitter Ratio: 0.5\r\n  - Class: nav2_rviz_plugins/Navigation 2\r\n    Name: Navigation 2\r\nVisualization Manager:\r\n  Class: ""\r\n  Displays:\r\n    - Alpha: 0.5\r\n      Cell Size: 1\r\n      Class: rviz_default_plugins/Grid\r\n      Color: 160; 160; 164\r\n      Enabled: true\r\n      Line Style:\r\n        Line Width: 0.029999999329447746\r\n        Value: Lines\r\n      Name: Grid\r\n      Normal Cell Count: 0\r\n      Offset:\r\n        X: 0\r\n        Y: 0\r\n        Z: 0\r\n      Plane: XY\r\n      Plane Cell Count: 100\r\n      Reference Frame: <Fixed Frame>\r\n      Value: true\r\n    - Class: rviz_default_plugins/TF\r\n      Enabled: true\r\n      Frame Timeout: 15\r\n      Frames:\r\n        All Enabled: true\r\n      Marker Scale: 1\r\n      Name: TF\r\n      Show Arrows: true\r\n      Show Axes: true\r\n      Show Names: false\r\n      Tree:\r\n        {}\r\n      Update Interval: 0\r\n      Value: true\r\n    - Alpha: 0.699999988079071\r\n      Class: rviz_default_plugins/Map\r\n      Color Scheme: map\r\n      Draw Behind: false\r\n      Enabled: true\r\n      Name: Map\r\n      Topic:\r\n        Depth: 5\r\n        Durability Policy: Volatile\r\n        History Policy: Keep Last\r\n        Reliability Policy: Reliable\r\n        Value: /map\r\n      Update Topic:\r\n        Depth: 5\r\n        Durability Policy: Volatile\r\n        History Policy: Keep Last\r\n        Reliability Policy: Reliable\r\n        Value: /map_updates\r\n      Use Timestamp: false\r\n      Value: true\r\n    - Alpha: 1\r\n      Buffer Length: 1\r\n      Class: rviz_default_plugins/Path\r\n      Color: 25; 255; 0\r\n      Enabled: true\r\n      Head Diameter: 0.30000001192092896\r\n      Head Length: 0.20000000298023224\r\n      Length: 0.30000001192092896\r\n      Line Style: Lines\r\n      Line Width: 0.029999999329447746\r\n      Name: Path\r\n      Offset:\r\n        X: 0\r\n        Y: 0\r\n        Z: 0\r\n      Pose Color: 255; 85; 255\r\n      Pose Style: None\r\n      Radius: 0.029999999329447746\r\n      Shaft Diameter: 0.10000000149011612\r\n      Shaft Length: 0.10000000149011612\r\n      Topic:\r\n        Depth: 5\r\n        Durability Policy: Volatile\r\n        History Policy: Keep Last\r\n        Reliability Policy: Reliable\r\n        Value: /plan\r\n      Value: true\r\n    - Alpha: 1\r\n      Class: rviz_default_plugins/Pose\r\n      Color: 255; 25; 0\r\n      Enabled: true\r\n      Head Length: 0.30000001192092896\r\n      Head Radius: 0.10000000149011612\r\n      Name: Current Goal\r\n      Shaft Length: 1\r\n      Shaft Radius: 0.05000000074505806\r\n      Shape: Arrow\r\n      Topic:\r\n        Depth: 5\r\n        Durability Policy: Volatile\r\n        History Policy: Keep Last\r\n        Reliability Policy: Reliable\r\n        Value: /active_goal\r\n      Value: true\r\n    - Class: rviz_default_plugins/MarkerArray\r\n      Enabled: true\r\n      Name: Goals Queue\r\n      Namespaces:\r\n        {}\r\n      Topic:\r\n        Depth: 5\r\n        Durability Policy: Volatile\r\n        History Policy: Keep Last\r\n        Reliability Policy: Reliable\r\n        Value: /goals_markers\r\n      Value: true\r\n  Enabled: true\r\n  Global Options:\r\n    Background Color: 48; 48; 48\r\n    Fixed Frame: map\r\n    Frame Rate: 30\r\n  Name: root\r\n  Tools:\r\n    - Class: rviz_default_plugins/Interact\r\n      Hide Inactive Objects: true\r\n    - Class: rviz_default_plugins/MoveCamera\r\n    - Class: rviz_default_plugins/Select\r\n    - Class: rviz_default_plugins/FocusCamera\r\n    - Class: rviz_default_plugins/Measure\r\n    - Class: rviz_default_plugins/SetInitialPose\r\n      Topic:\r\n        Depth: 5\r\n        Durability Policy: Volatile\r\n        History Policy: Keep Last\r\n        Reliability Policy: Reliable\r\n        Value: /initialpose\r\n    - Class: rviz_default_plugins/SetGoal\r\n      Topic:\r\n        Depth: 5\r\n        Durability Policy: Volatile\r\n        History Policy: Keep Last\r\n        Reliability Policy: Reliable\r\n        Value: /goal_pose\r\n    - Class: nav2_rviz_plugins/Navigation 2\r\n  Transformation:\r\n    Current:\r\n      Class: rviz_default_plugins/TF\r\n  Value: true\r\n  Views:\r\n    Current:\r\n      Class: rviz_default_plugins/Orbit\r\n      Distance: 10\r\n      Enable Stereo Rendering:\r\n        Stereo Eye Separation: 0.05999999865889549\r\n        Stereo Focal Distance: 1\r\n        Swap Stereo Eyes: false\r\n        Value: false\r\n      Focal Point:\r\n        X: 0\r\n        Y: 0\r\n        Z: 0\r\n      Focal Shape Fixed Size: true\r\n      Focal Shape Size: 0.05000000074505806\r\n      Invert Z Axis: false\r\n      Name: Current View\r\n      Near Clip Distance: 0.009999999776482582\r\n      Pitch: 0.5\r\n      Target Frame: <Fixed Frame>\r\n      Value: Orbit (rviz)\r\n      Yaw: 0.5\r\n    Saved: ~\r\nWindow Geometry:\r\n  Displays:\r\n    collapsed: false\r\n  Height: 1025\r\n  Hide Left Dock: false\r\n  Hide Right Dock: false\r\n  Navigation 2:\r\n    collapsed: false\r\n  QMainWindow State: 000000ff00000000fd000000040000000000000156000003a7fc0200000009fb0000001200530065006c0065006300740069006f006e00000001e10000009b0000005c00fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afb000000100044006900730070006c006100790073010000003d000003a7000000c900fffffffb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261fb00000010004e0061007600690067006100740069006f006e0020003201000003a9000000c90000000000000000fb0000000a0049006d00610067006501000003a7000001e20000000000000000000000010000010f000003a7fc0200000003fb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fb0000000a00560069006500770073010000003d000003a7000000a400fffffffb0000001200530065006c0065006300740069006f006e010000025a000000b200000000000000000000000200000490000000a9fc0100000001fb0000000a00560069006500770073030000004e00000080000002e10000019700000003000004420000003efc0100000002fb0000000800540069006d00650100000000000004420000000000000000fb0000000800540069006d006501000000000000045000000000000000000000050a000003a700000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000\r\n  Width: 1853\r\n  X: 67\r\n  Y: 27\n'})}),"\n",(0,l.jsx)(r.h3,{id:"2-goal-visualization-node",children:"2. Goal Visualization Node"}),"\n",(0,l.jsx)(r.p,{children:"Create a node to visualize goals in RViz2:"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n"""\r\nGoal Visualization Node for RViz2\r\n"""\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom visualization_msgs.msg import Marker, MarkerArray\r\nfrom geometry_msgs.msg import Point\r\nfrom std_msgs.msg import ColorRGBA\r\nimport math\r\n\r\n\r\nclass GoalVisualizer(Node):\r\n    def __init__(self):\r\n        super().__init__(\'goal_visualizer\')\r\n\r\n        # Publishers\r\n        self.goals_markers_pub = self.create_publisher(MarkerArray, \'/goals_markers\', 10)\r\n        self.active_goal_pub = self.create_publisher(Marker, \'/active_goal_marker\', 10)\r\n\r\n        # Subscriptions\r\n        self.goal_status_sub = self.create_subscription(\r\n            String, \'/goal_status\', self.goal_status_callback, 10)\r\n        self.active_goal_sub = self.create_subscription(\r\n            PoseStamped, \'/active_goal\', self.active_goal_callback, 10)\r\n\r\n        # Internal state\r\n        self.goals = []\r\n        self.active_goal = None\r\n\r\n        # Timer for visualization updates\r\n        self.viz_timer = self.create_timer(0.1, self.update_visualization)\r\n\r\n        self.get_logger().info(\'Goal Visualizer initialized\')\r\n\r\n    def goal_status_callback(self, msg):\r\n        """Process goal status updates"""\r\n        # In a real implementation, this would parse the status message\r\n        # and update the internal goals list\r\n        pass\r\n\r\n    def active_goal_callback(self, msg):\r\n        """Update active goal visualization"""\r\n        self.active_goal = msg\r\n\r\n    def update_visualization(self):\r\n        """Update goal visualization markers"""\r\n        # Create markers for queued goals\r\n        markers = MarkerArray()\r\n\r\n        # Add queued goals\r\n        for i, goal in enumerate(self.goals):\r\n            marker = Marker()\r\n            marker.header.frame_id = "map"\r\n            marker.header.stamp = self.get_clock().now().to_msg()\r\n            marker.ns = "queued_goals"\r\n            marker.id = i\r\n            marker.type = Marker.ARROW\r\n            marker.action = Marker.ADD\r\n\r\n            marker.pose = goal.pose\r\n            marker.scale.x = 0.5  # Length of arrow\r\n            marker.scale.y = 0.1  # Width of arrow\r\n            marker.scale.z = 0.1  # Height of arrow\r\n\r\n            marker.color.r = 0.0\r\n            marker.color.g = 0.0\r\n            marker.color.b = 1.0  # Blue for queued goals\r\n            marker.color.a = 0.8\r\n\r\n            markers.markers.append(marker)\r\n\r\n        # Publish markers\r\n        self.goals_markers_pub.publish(markers)\r\n\r\n        # Publish active goal marker if available\r\n        if self.active_goal:\r\n            active_marker = Marker()\r\n            active_marker.header.frame_id = "map"\r\n            active_marker.header.stamp = self.get_clock().now().to_msg()\r\n            active_marker.ns = "active_goal"\r\n            active_marker.id = 0\r\n            active_marker.type = Marker.ARROW\r\n            active_marker.action = Marker.ADD\r\n\r\n            active_marker.pose = self.active_goal.pose\r\n            active_marker.scale.x = 0.8  # Longer arrow for active goal\r\n            active_marker.scale.y = 0.2\r\n            active_marker.scale.z = 0.2\r\n\r\n            active_marker.color.r = 1.0  # Red for active goal\r\n            active_marker.color.g = 0.0\r\n            active_marker.color.b = 0.0\r\n            active_marker.color.a = 1.0\r\n\r\n            self.active_goal_pub.publish(active_marker)\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    visualizer = GoalVisualizer()\r\n\r\n    try:\r\n        rclpy.spin(visualizer)\r\n    except KeyboardInterrupt:\r\n        visualizer.get_logger().info(\'Goal visualizer stopped by user\')\r\n    finally:\r\n        visualizer.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,l.jsx)(r.h2,{id:"test-scenario-implementation",children:"Test Scenario Implementation"}),"\n",(0,l.jsx)(r.h3,{id:"1-navigation-test-scenarios",children:"1. Navigation Test Scenarios"}),"\n",(0,l.jsxs)(r.p,{children:["Create a test scenarios configuration ",(0,l.jsx)(r.code,{children:"navigation_test_scenarios.py"}),":"]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\"\"\"\r\nNavigation Test Scenarios for Goal Interface\r\n\"\"\"\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\nfrom geometry_msgs.msg import PoseStamped\r\nimport json\r\nimport time\r\n\r\n\r\nclass NavigationTestScenarios(Node):\r\n    def __init__(self):\r\n        super().__init__('navigation_test_scenarios')\r\n\r\n        # Publishers\r\n        self.goals_batch_pub = self.create_publisher(String, '/goals_batch', 10)\r\n        self.goal_command_pub = self.create_publisher(String, '/goal_command', 10)\r\n\r\n        # Test scenarios\r\n        self.test_scenarios = {\r\n            'corridor_test': [\r\n                {'x': 1.0, 'y': 0.0, 'yaw': 0.0, 'priority': 1, 'timeout': 30.0},\r\n                {'x': 3.0, 'y': 0.0, 'yaw': 0.0, 'priority': 1, 'timeout': 30.0},\r\n                {'x': 5.0, 'y': 0.0, 'yaw': 0.0, 'priority': 1, 'timeout': 30.0},\r\n                {'x': 7.0, 'y': 0.0, 'yaw': 0.0, 'priority': 1, 'timeout': 30.0}\r\n            ],\r\n            'maze_test': [\r\n                {'x': -2.0, 'y': -8.0, 'yaw': 0.0, 'priority': 1, 'timeout': 60.0},\r\n                {'x': -1.0, 'y': -6.5, 'yaw': 0.0, 'priority': 1, 'timeout': 60.0},\r\n                {'x': 0.0, 'y': -5.0, 'yaw': 0.0, 'priority': 1, 'timeout': 60.0}\r\n            ],\r\n            'obstacle_avoidance_test': [\r\n                {'x': -6.0, 'y': 0.0, 'yaw': 0.0, 'priority': 1, 'timeout': 45.0},\r\n                {'x': -6.0, 'y': 2.0, 'yaw': 0.0, 'priority': 1, 'timeout': 45.0},\r\n                {'x': -6.0, 'y': 4.0, 'yaw': 0.0, 'priority': 1, 'timeout': 45.0}\r\n            ],\r\n            'dynamic_obstacle_test': [\r\n                {'x': 4.0, 'y': 4.0, 'yaw': 0.0, 'priority': 1, 'timeout': 90.0},\r\n                {'x': 5.0, 'y': 5.0, 'yaw': 0.0, 'priority': 1, 'timeout': 90.0},\r\n                {'x': 6.0, 'y': 6.0, 'yaw': 0.0, 'priority': 1, 'timeout': 90.0}\r\n            ]\r\n        }\r\n\r\n        self.get_logger().info('Navigation Test Scenarios initialized')\r\n\r\n    def run_scenario(self, scenario_name):\r\n        \"\"\"Run a specific test scenario\"\"\"\r\n        if scenario_name not in self.test_scenarios:\r\n            self.get_logger().error(f'Unknown scenario: {scenario_name}')\r\n            return\r\n\r\n        self.get_logger().info(f'Running scenario: {scenario_name}')\r\n\r\n        # Publish the scenario goals as a batch\r\n        scenario_data = {\r\n            'scenario_name': scenario_name,\r\n            'goals': self.test_scenarios[scenario_name],\r\n            'timestamp': time.time()\r\n        }\r\n\r\n        goals_msg = String()\r\n        goals_msg.data = json.dumps(scenario_data)\r\n        self.goals_batch_pub.publish(goals_msg)\r\n\r\n    def run_all_scenarios(self):\r\n        \"\"\"Run all test scenarios sequentially\"\"\"\r\n        for scenario_name in self.test_scenarios.keys():\r\n            self.get_logger().info(f'Starting scenario: {scenario_name}')\r\n            self.run_scenario(scenario_name)\r\n\r\n            # Wait between scenarios\r\n            time.sleep(2.0)\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    test_scenarios = NavigationTestScenarios()\r\n\r\n    # Example: Run a specific scenario\r\n    test_scenarios.run_scenario('corridor_test')\r\n\r\n    # Or run all scenarios\r\n    # test_scenarios.run_all_scenarios()\r\n\r\n    test_scenarios.destroy_node()\r\n    rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,l.jsx)(r.h2,{id:"command-line-interface",children:"Command Line Interface"}),"\n",(0,l.jsx)(r.h3,{id:"1-goal-command-line-tool",children:"1. Goal Command Line Tool"}),"\n",(0,l.jsx)(r.p,{children:"Create a command line tool for sending goals:"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\"\"\"\r\nCommand Line Interface for Navigation Goals\r\n\"\"\"\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\nimport sys\r\nimport argparse\r\n\r\n\r\nclass GoalCLI(Node):\r\n    def __init__(self):\r\n        super().__init__('goal_cli')\r\n\r\n        # Publisher\r\n        self.goal_command_pub = self.create_publisher(String, '/goal_command', 10)\r\n\r\n        self.get_logger().info('Goal CLI initialized')\r\n\r\n    def send_goal(self, x, y, yaw=0.0, priority=1, timeout=60.0):\r\n        \"\"\"Send a single goal\"\"\"\r\n        command = f'send_goal:{x},{y},{yaw},{priority},{timeout}'\r\n        cmd_msg = String()\r\n        cmd_msg.data = command\r\n        self.goal_command_pub.publish(cmd_msg)\r\n        self.get_logger().info(f'Sent goal: {command}')\r\n\r\n    def send_goals_batch(self, goals_list):\r\n        \"\"\"Send a batch of goals\"\"\"\r\n        goals_str = ';'.join([f'[{x},{y},{yaw},{priority},{timeout}]'\r\n                             for x, y, yaw, priority, timeout in goals_list])\r\n        command = f'send_goals:{goals_str}'\r\n        cmd_msg = String()\r\n        cmd_msg.data = command\r\n        self.goal_command_pub.publish(cmd_msg)\r\n        self.get_logger().info(f'Sent batch goals: {command}')\r\n\r\n    def cancel_goal(self, goal_id):\r\n        \"\"\"Cancel a specific goal\"\"\"\r\n        command = f'cancel_goal:{goal_id}'\r\n        cmd_msg = String()\r\n        cmd_msg.data = command\r\n        self.goal_command_pub.publish(cmd_msg)\r\n        self.get_logger().info(f'Sent cancel command for goal: {goal_id}')\r\n\r\n    def cancel_all_goals(self):\r\n        \"\"\"Cancel all goals\"\"\"\r\n        command = 'cancel_all'\r\n        cmd_msg = String()\r\n        cmd_msg.data = command\r\n        self.goal_command_pub.publish(cmd_msg)\r\n        self.get_logger().info('Sent cancel all command')\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n\r\n    parser = argparse.ArgumentParser(description='Navigation Goal CLI')\r\n    parser.add_argument('command', choices=['send', 'batch', 'cancel', 'cancel_all', 'status'])\r\n    parser.add_argument('--x', type=float, help='X coordinate')\r\n    parser.add_argument('--y', type=float, help='Y coordinate')\r\n    parser.add_argument('--yaw', type=float, default=0.0, help='Yaw angle')\r\n    parser.add_argument('--priority', type=int, default=1, help='Goal priority')\r\n    parser.add_argument('--timeout', type=float, default=60.0, help='Goal timeout')\r\n    parser.add_argument('--goal_id', type=int, help='Goal ID for cancellation')\r\n\r\n    args = parser.parse_args()\r\n\r\n    cli = GoalCLI()\r\n\r\n    if args.command == 'send':\r\n        if args.x is None or args.y is None:\r\n            print(\"Error: X and Y coordinates are required for 'send' command\")\r\n            sys.exit(1)\r\n        cli.send_goal(args.x, args.y, args.yaw, args.priority, args.timeout)\r\n    elif args.command == 'batch':\r\n        # Example batch - in real usage, this would be parameterized\r\n        goals = [\r\n            (1.0, 1.0, 0.0, 1, 30.0),\r\n            (2.0, 2.0, 0.0, 1, 30.0),\r\n            (3.0, 3.0, 0.0, 1, 30.0)\r\n        ]\r\n        cli.send_goals_batch(goals)\r\n    elif args.command == 'cancel':\r\n        if args.goal_id is None:\r\n            print(\"Error: Goal ID is required for 'cancel' command\")\r\n            sys.exit(1)\r\n        cli.cancel_goal(args.goal_id)\r\n    elif args.command == 'cancel_all':\r\n        cli.cancel_all_goals()\r\n    elif args.command == 'status':\r\n        cmd_msg = String()\r\n        cmd_msg.data = 'get_status'\r\n        cli.goal_command_pub.publish(cmd_msg)\r\n        cli.get_logger().info('Requested status')\r\n\r\n    # Keep node alive briefly to send message\r\n    rclpy.spin_once(cli, timeout_sec=0.1)\r\n    cli.destroy_node()\r\n    rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,l.jsx)(r.h2,{id:"integration-launch-files",children:"Integration Launch Files"}),"\n",(0,l.jsx)(r.h3,{id:"1-complete-goal-interface-launch",children:"1. Complete Goal Interface Launch"}),"\n",(0,l.jsxs)(r.p,{children:["Create a launch file ",(0,l.jsx)(r.code,{children:"goal_interface_launch.py"}),":"]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-python",children:"import os\r\nfrom launch import LaunchDescription\r\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription, RegisterEventHandler\r\nfrom launch.conditions import IfCondition\r\nfrom launch.event_handlers import OnProcessExit\r\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\r\nfrom launch.substitutions import LaunchConfiguration\r\nfrom launch_ros.actions import Node\r\nfrom ament_index_python.packages import get_package_share_directory\r\n\r\n\r\ndef generate_launch_description():\r\n    # Launch configuration variables\r\n    use_sim_time = LaunchConfiguration('use_sim_time', default='true')\r\n    run_rviz = LaunchConfiguration('run_rviz', default='true')\r\n    autostart = LaunchConfiguration('autostart', default='true')\r\n\r\n    # Declare launch arguments\r\n    declare_use_sim_time = DeclareLaunchArgument(\r\n        'use_sim_time',\r\n        default_value='true',\r\n        description='Use simulation clock if true')\r\n\r\n    declare_run_rviz = DeclareLaunchArgument(\r\n        'run_rviz',\r\n        default_value='true',\r\n        description='Whether to start RViz')\r\n\r\n    declare_autostart = DeclareLaunchArgument(\r\n        'autostart',\r\n        default_value='true',\r\n        description='Automatically startup the nav2 stack')\r\n\r\n    # Advanced goal manager\r\n    goal_manager = Node(\r\n        package='your_robot_navigation',\r\n        executable='advanced_goal_manager',\r\n        name='goal_manager',\r\n        parameters=[{\r\n            'use_sim_time': use_sim_time,\r\n            'max_goals': 50,\r\n            'default_timeout': 60.0,\r\n            'goal_tolerance': 0.25\r\n        }],\r\n        output='screen'\r\n    )\r\n\r\n    # Goal visualizer\r\n    goal_visualizer = Node(\r\n        package='your_robot_navigation',\r\n        executable='goal_visualizer',\r\n        name='goal_visualizer',\r\n        parameters=[{'use_sim_time': use_sim_time}],\r\n        output='screen'\r\n    )\r\n\r\n    # Navigation2 stack\r\n    navigation2 = IncludeLaunchDescription(\r\n        PythonLaunchDescriptionSource(\r\n            os.path.join(\r\n                get_package_share_directory('nav2_bringup'),\r\n                'launch', 'navigation_launch.py')),\r\n        launch_arguments={\r\n            'use_sim_time': use_sim_time,\r\n            'autostart': autostart\r\n        }.items()\r\n    )\r\n\r\n    # RViz2 with goal interface\r\n    rviz = Node(\r\n        condition=IfCondition(run_rviz),\r\n        package='rviz2',\r\n        executable='rviz2',\r\n        name='rviz2',\r\n        arguments=['-d', os.path.join(\r\n            get_package_share_directory('your_robot_navigation'),\r\n            'rviz', 'goal_interface.rviz')],\r\n        parameters=[{'use_sim_time': use_sim_time}]\r\n    )\r\n\r\n    # Create launch description\r\n    ld = LaunchDescription()\r\n\r\n    # Add launch arguments\r\n    ld.add_action(declare_use_sim_time)\r\n    ld.add_action(declare_run_rviz)\r\n    ld.add_action(declare_autostart)\r\n\r\n    # Add nodes\r\n    ld.add_action(goal_manager)\r\n    ld.add_action(goal_visualizer)\r\n    ld.add_action(navigation2)\r\n    ld.add_action(rviz)\r\n\r\n    return ld\n"})}),"\n",(0,l.jsx)(r.h2,{id:"testing-and-validation",children:"Testing and Validation"}),"\n",(0,l.jsx)(r.h3,{id:"1-goal-interface-testing-script",children:"1. Goal Interface Testing Script"}),"\n",(0,l.jsx)(r.p,{children:"Create a comprehensive testing script:"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\"\"\"\r\nGoal Interface Testing Script\r\n\"\"\"\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String, Int32\r\nfrom geometry_msgs.msg import PoseStamped\r\nfrom builtin_interfaces.msg import Time\r\nimport time\r\nimport json\r\n\r\n\r\nclass GoalInterfaceTester(Node):\r\n    def __init__(self):\r\n        super().__init__('goal_interface_tester')\r\n\r\n        # Publishers\r\n        self.goal_command_pub = self.create_publisher(String, '/goal_command', 10)\r\n        self.goals_batch_pub = self.create_publisher(String, '/goals_batch', 10)\r\n\r\n        # Subscriptions\r\n        self.goal_status_sub = self.create_subscription(\r\n            String, '/goal_status', self.goal_status_callback, 10)\r\n        self.goal_result_sub = self.create_subscription(\r\n            String, '/goal_result', self.goal_result_callback, 10)\r\n\r\n        # Internal state\r\n        self.test_results = []\r\n        self.current_test = None\r\n\r\n        self.get_logger().info('Goal Interface Tester initialized')\r\n\r\n    def goal_status_callback(self, msg):\r\n        \"\"\"Handle goal status updates\"\"\"\r\n        self.get_logger().info(f'Goal status: {msg.data}')\r\n\r\n    def goal_result_callback(self, msg):\r\n        \"\"\"Handle goal result updates\"\"\"\r\n        self.get_logger().info(f'Goal result: {msg.data}')\r\n\r\n        # Record result\r\n        self.test_results.append(msg.data)\r\n\r\n    def run_comprehensive_tests(self):\r\n        \"\"\"Run comprehensive goal interface tests\"\"\"\r\n        self.get_logger().info('Starting comprehensive goal interface tests...')\r\n\r\n        # Test 1: Single goal\r\n        self.test_single_goal()\r\n\r\n        # Wait for completion\r\n        time.sleep(5.0)\r\n\r\n        # Test 2: Multiple goals\r\n        self.test_multiple_goals()\r\n\r\n        # Wait for completion\r\n        time.sleep(10.0)\r\n\r\n        # Test 3: Batch goals\r\n        self.test_batch_goals()\r\n\r\n        # Wait for completion\r\n        time.sleep(10.0)\r\n\r\n        # Test 4: Priority testing\r\n        self.test_priority_goals()\r\n\r\n        self.get_logger().info('All tests completed')\r\n        self.print_test_summary()\r\n\r\n    def test_single_goal(self):\r\n        \"\"\"Test single goal functionality\"\"\"\r\n        self.get_logger().info('Testing single goal...')\r\n        cmd_msg = String()\r\n        cmd_msg.data = 'send_goal:1.0,1.0,0.0,1,30.0'\r\n        self.goal_command_pub.publish(cmd_msg)\r\n\r\n    def test_multiple_goals(self):\r\n        \"\"\"Test multiple sequential goals\"\"\"\r\n        self.get_logger().info('Testing multiple goals...')\r\n        # Send several goals in sequence\r\n        for i in range(3):\r\n            cmd_msg = String()\r\n            cmd_msg.data = f'send_goal:{i+2}.0,{i+2}.0,0.0,1,30.0'\r\n            self.goal_command_pub.publish(cmd_msg)\r\n            time.sleep(0.5)  # Small delay between goals\r\n\r\n    def test_batch_goals(self):\r\n        \"\"\"Test batch goal functionality\"\"\"\r\n        self.get_logger().info('Testing batch goals...')\r\n        batch_data = {\r\n            'goals': [\r\n                {'x': -1.0, 'y': -1.0, 'yaw': 0.0, 'priority': 1, 'timeout': 30.0},\r\n                {'x': -2.0, 'y': -2.0, 'yaw': 0.0, 'priority': 1, 'timeout': 30.0},\r\n                {'x': -3.0, 'y': -3.0, 'yaw': 0.0, 'priority': 1, 'timeout': 30.0}\r\n            ]\r\n        }\r\n\r\n        batch_msg = String()\r\n        batch_msg.data = json.dumps(batch_data)\r\n        self.goals_batch_pub.publish(batch_msg)\r\n\r\n    def test_priority_goals(self):\r\n        \"\"\"Test goal priority functionality\"\"\"\r\n        self.get_logger().info('Testing goal priorities...')\r\n\r\n        # Send low priority goal first\r\n        cmd_msg = String()\r\n        cmd_msg.data = 'send_goal:5.0,5.0,0.0,1,30.0'  # Low priority\r\n        self.goal_command_pub.publish(cmd_msg)\r\n\r\n        time.sleep(1.0)\r\n\r\n        # Send high priority goal\r\n        cmd_msg = String()\r\n        cmd_msg.data = 'send_goal:6.0,6.0,0.0,5,30.0'  # High priority\r\n        self.goal_command_pub.publish(cmd_msg)\r\n\r\n    def print_test_summary(self):\r\n        \"\"\"Print test results summary\"\"\"\r\n        self.get_logger().info('=== Test Results Summary ===')\r\n        for result in self.test_results:\r\n            self.get_logger().info(f'  {result}')\r\n        self.get_logger().info(f'Total results recorded: {len(self.test_results)}')\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    tester = GoalInterfaceTester()\r\n\r\n    # Run tests\r\n    tester.run_comprehensive_tests()\r\n\r\n    tester.destroy_node()\r\n    rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,l.jsx)(r.h2,{id:"best-practices-and-tips",children:"Best Practices and Tips"}),"\n",(0,l.jsx)(r.h3,{id:"1-goal-interface-best-practices",children:"1. Goal Interface Best Practices"}),"\n",(0,l.jsxs)(r.ol,{children:["\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:"Error Handling"}),": Always verify that the navigation server is available before sending goals"]}),"\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:"Timeout Management"}),": Implement proper timeouts to prevent goals from hanging indefinitely"]}),"\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:"Priority Management"}),": Use priority levels to handle important goals first"]}),"\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:"Resource Management"}),": Limit the number of concurrent goals to prevent system overload"]}),"\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:"Status Monitoring"}),": Continuously monitor goal status and provide feedback"]}),"\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:"Graceful Degradation"}),": Handle failures gracefully and continue with other goals"]}),"\n"]}),"\n",(0,l.jsx)(r.h3,{id:"2-performance-considerations",children:"2. Performance Considerations"}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsx)(r.li,{children:"Use appropriate queue sizes to balance responsiveness and resource usage"}),"\n",(0,l.jsx)(r.li,{children:"Implement proper cleanup of completed goals to prevent memory leaks"}),"\n",(0,l.jsx)(r.li,{children:"Optimize goal validation to reduce processing overhead"}),"\n",(0,l.jsx)(r.li,{children:"Consider using multi-threading for handling multiple concurrent goals"}),"\n"]}),"\n",(0,l.jsx)(r.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,l.jsx)(r.p,{children:"This comprehensive goal sending interface provides all the necessary components for effective navigation testing:"}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsx)(r.li,{children:"A simple publisher for basic goal sending"}),"\n",(0,l.jsx)(r.li,{children:"An advanced manager for complex scenarios with priorities and batching"}),"\n",(0,l.jsx)(r.li,{children:"RViz2 integration for visualization"}),"\n",(0,l.jsx)(r.li,{children:"Command-line tools for easy testing"}),"\n",(0,l.jsx)(r.li,{children:"Test scenarios for validation"}),"\n",(0,l.jsx)(r.li,{children:"Proper error handling and status monitoring"}),"\n"]}),"\n",(0,l.jsx)(r.p,{children:"The interface is designed to be modular and extensible, allowing for customization based on specific testing requirements. Regular testing with this interface will help ensure reliable navigation performance and identify potential issues before deployment."})]})}function d(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,l.jsx)(r,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}},7074:(e,r,n)=>{n.d(r,{R:()=>o,x:()=>s});var a=n(6540);const l={},t=a.createContext(l);function o(e){const r=a.useContext(t);return a.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function s(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:o(e.components),a.createElement(t.Provider,{value:r},e.children)}}}]);