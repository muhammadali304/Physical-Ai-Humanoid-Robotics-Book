"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[6843],{2842:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"appendix/external-service-failure-handling","title":"External Service Failure Handling Examples for Robotics Applications","description":"This document provides comprehensive examples and strategies for handling failures of external services in robotics applications, ensuring robust and resilient robot operation.","source":"@site/docs/appendix/external-service-failure-handling.md","sourceDirName":"appendix","slug":"/appendix/external-service-failure-handling","permalink":"/docs/appendix/external-service-failure-handling","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/appendix/external-service-failure-handling.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Assessment Methods for Physical AI and Humanoid Robotics","permalink":"/docs/appendix/assessment-methods"},"next":{"title":"Accessibility Statement","permalink":"/docs/accessibility-statement"}}');var i=n(4848),a=n(7074);const s={},l="External Service Failure Handling Examples for Robotics Applications",o={},c=[{value:"Overview",id:"overview",level:2},{value:"Types of External Service Failures",id:"types-of-external-service-failures",level:2},{value:"1. Connectivity Failures",id:"1-connectivity-failures",level:3},{value:"2. Service Availability Failures",id:"2-service-availability-failures",level:3},{value:"3. Authentication and Authorization Failures",id:"3-authentication-and-authorization-failures",level:3},{value:"4. Data and Processing Failures",id:"4-data-and-processing-failures",level:3},{value:"Failure Handling Strategies",id:"failure-handling-strategies",level:2},{value:"1. Circuit Breaker Pattern",id:"1-circuit-breaker-pattern",level:3},{value:"2. Retry with Exponential Backoff",id:"2-retry-with-exponential-backoff",level:3},{value:"3. Fallback and Degraded Mode Handling",id:"3-fallback-and-degraded-mode-handling",level:3},{value:"4. Health Monitoring and Service Discovery",id:"4-health-monitoring-and-service-discovery",level:3},{value:"5. Comprehensive Failure Handling Example",id:"5-comprehensive-failure-handling-example",level:3},{value:"6. Emergency and Graceful Degradation Procedures",id:"6-emergency-and-graceful-degradation-procedures",level:3},{value:"Best Practices for External Service Failure Handling",id:"best-practices-for-external-service-failure-handling",level:2},{value:"1. Proactive Monitoring",id:"1-proactive-monitoring",level:3},{value:"2. Graceful Degradation",id:"2-graceful-degradation",level:3},{value:"3. Circuit Breaker Best Practices",id:"3-circuit-breaker-best-practices",level:3},{value:"4. Retry Strategy Guidelines",id:"4-retry-strategy-guidelines",level:3},{value:"5. Data Consistency",id:"5-data-consistency",level:3},{value:"6. Logging and Observability",id:"6-logging-and-observability",level:3}];function d(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.header,{children:(0,i.jsx)(r.h1,{id:"external-service-failure-handling-examples-for-robotics-applications",children:"External Service Failure Handling Examples for Robotics Applications"})}),"\n",(0,i.jsx)(r.p,{children:"This document provides comprehensive examples and strategies for handling failures of external services in robotics applications, ensuring robust and resilient robot operation."}),"\n",(0,i.jsx)(r.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(r.p,{children:"Robotic systems often depend on external services such as cloud APIs, web services, databases, and remote computing resources. When these services fail, robots must continue operating safely and effectively. This guide covers various failure scenarios and appropriate handling strategies."}),"\n",(0,i.jsx)(r.h2,{id:"types-of-external-service-failures",children:"Types of External Service Failures"}),"\n",(0,i.jsx)(r.h3,{id:"1-connectivity-failures",children:"1. Connectivity Failures"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Network Outage"}),": Complete loss of network connectivity"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Intermittent Connection"}),": Unstable or poor quality connections"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Bandwidth Limitation"}),": Insufficient bandwidth for required operations"]}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"2-service-availability-failures",children:"2. Service Availability Failures"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Service Downtime"}),": External service is temporarily unavailable"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Rate Limiting"}),": API rate limits exceeded"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Service Degradation"}),": Service operating but with reduced performance"]}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"3-authentication-and-authorization-failures",children:"3. Authentication and Authorization Failures"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Expired Credentials"}),": API keys or tokens expired"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Permission Denial"}),": Insufficient permissions for requested operations"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Account Suspension"}),": Service account suspended or disabled"]}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"4-data-and-processing-failures",children:"4. Data and Processing Failures"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Invalid Response"}),": Service returns unexpected or malformed data"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Timeout"}),": Service request exceeds acceptable response time"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Quota Exceeded"}),": Usage limits exceeded for the service"]}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"failure-handling-strategies",children:"Failure Handling Strategies"}),"\n",(0,i.jsx)(r.h3,{id:"1-circuit-breaker-pattern",children:"1. Circuit Breaker Pattern"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:'# circuit_breaker.py\r\nimport time\r\nfrom enum import Enum\r\nfrom typing import Callable, Any, Optional\r\nimport logging\r\n\r\n\r\nclass CircuitState(Enum):\r\n    CLOSED = "closed"      # Normal operation\r\n    OPEN = "open"          # Circuit broken, requests blocked\r\n    HALF_OPEN = "half_open"  # Testing if circuit should close\r\n\r\n\r\nclass CircuitBreaker:\r\n    """\r\n    Circuit breaker pattern for external service calls\r\n    """\r\n    def __init__(self, failure_threshold: int = 5, timeout: int = 60):\r\n        self.failure_threshold = failure_threshold\r\n        self.timeout = timeout\r\n        self.failure_count = 0\r\n        self.last_failure_time = None\r\n        self.state = CircuitState.CLOSED\r\n        self.logger = logging.getLogger(__name__)\r\n\r\n    def call(self, func: Callable, *args, **kwargs) -> Any:\r\n        """\r\n        Execute function with circuit breaker protection\r\n        """\r\n        if self.state == CircuitState.OPEN:\r\n            if self._should_attempt_reset():\r\n                self.state = CircuitState.HALF_OPEN\r\n                self.logger.info("Circuit breaker in HALF_OPEN state, attempting reset")\r\n            else:\r\n                raise Exception("Circuit breaker OPEN - external service unavailable")\r\n\r\n        try:\r\n            result = func(*args, **kwargs)\r\n            self._on_success()\r\n            return result\r\n        except Exception as e:\r\n            self._on_failure(str(e))\r\n            raise\r\n\r\n    def _on_success(self):\r\n        """\r\n        Handle successful service call\r\n        """\r\n        if self.state == CircuitState.HALF_OPEN:\r\n            self.logger.info("Circuit breaker reset to CLOSED after successful call")\r\n\r\n        self.state = CircuitState.CLOSED\r\n        self.failure_count = 0\r\n        self.last_failure_time = None\r\n\r\n    def _on_failure(self, error_message: str):\r\n        """\r\n        Handle failed service call\r\n        """\r\n        self.failure_count += 1\r\n        self.last_failure_time = time.time()\r\n        self.logger.error(f"Service call failed: {error_message}")\r\n\r\n        if self.failure_count >= self.failure_threshold:\r\n            self.state = CircuitState.OPEN\r\n            self.logger.warning("Circuit breaker OPEN - too many failures")\r\n\r\n    def _should_attempt_reset(self) -> bool:\r\n        """\r\n        Check if enough time has passed to attempt reset\r\n        """\r\n        if self.last_failure_time is None:\r\n            return False\r\n        return time.time() - self.last_failure_time >= self.timeout\r\n\r\n\r\n# Example usage in robotics context\r\nclass RobotCloudService:\r\n    """\r\n    Example robot service that uses circuit breaker\r\n    """\r\n    def __init__(self):\r\n        self.circuit_breaker = CircuitBreaker(failure_threshold=3, timeout=30)\r\n\r\n    def get_navigation_map(self, location: str) -> dict:\r\n        """\r\n        Get navigation map from cloud service with circuit breaker protection\r\n        """\r\n        def _get_map():\r\n            # Simulate external API call\r\n            import requests\r\n            response = requests.get(f"https://api.robotcloud.com/maps/{location}")\r\n            response.raise_for_status()\r\n            return response.json()\r\n\r\n        try:\r\n            return self.circuit_breaker.call(_get_map)\r\n        except Exception as e:\r\n            self.logger.error(f"Failed to get navigation map: {e}")\r\n            # Fallback to local map or cached data\r\n            return self.get_local_map(location)\r\n\r\n    def get_local_map(self, location: str) -> dict:\r\n        """\r\n        Fallback method to get local/cached map\r\n        """\r\n        # Return local or cached map data\r\n        return {"location": location, "data": "cached_map_data", "source": "local"}\n'})}),"\n",(0,i.jsx)(r.h3,{id:"2-retry-with-exponential-backoff",children:"2. Retry with Exponential Backoff"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:'# retry_mechanism.py\r\nimport time\r\nimport random\r\nimport asyncio\r\nfrom typing import Callable, Any, Type, Tuple\r\nimport logging\r\n\r\n\r\nclass RetryHandler:\r\n    """\r\n    Retry mechanism with exponential backoff for external service calls\r\n    """\r\n    def __init__(self, max_retries: int = 5, base_delay: float = 1.0, max_delay: float = 60.0):\r\n        self.max_retries = max_retries\r\n        self.base_delay = base_delay\r\n        self.max_delay = max_delay\r\n        self.logger = logging.getLogger(__name__)\r\n\r\n    def execute_with_retry(self, func: Callable, *args,\r\n                          retry_exceptions: Tuple[Type[Exception], ...] = (Exception,),\r\n                          **kwargs) -> Any:\r\n        """\r\n        Execute function with retry mechanism\r\n        """\r\n        last_exception = None\r\n\r\n        for attempt in range(self.max_retries + 1):\r\n            try:\r\n                return func(*args, **kwargs)\r\n            except retry_exceptions as e:\r\n                last_exception = e\r\n                if attempt < self.max_retries:\r\n                    delay = self._calculate_delay(attempt)\r\n                    self.logger.warning(\r\n                        f"Attempt {attempt + 1} failed: {str(e)}. "\r\n                        f"Retrying in {delay:.2f} seconds..."\r\n                    )\r\n                    time.sleep(delay)\r\n                else:\r\n                    self.logger.error(f"All {self.max_retries + 1} attempts failed")\r\n                    raise last_exception\r\n\r\n    async def execute_with_retry_async(self, func: Callable, *args,\r\n                                      retry_exceptions: Tuple[Type[Exception], ...] = (Exception,),\r\n                                      **kwargs) -> Any:\r\n        """\r\n        Execute async function with retry mechanism\r\n        """\r\n        last_exception = None\r\n\r\n        for attempt in range(self.max_retries + 1):\r\n            try:\r\n                return await func(*args, **kwargs)\r\n            except retry_exceptions as e:\r\n                last_exception = e\r\n                if attempt < self.max_retries:\r\n                    delay = self._calculate_delay(attempt)\r\n                    self.logger.warning(\r\n                        f"Async attempt {attempt + 1} failed: {str(e)}. "\r\n                        f"Retrying in {delay:.2f} seconds..."\r\n                    )\r\n                    await asyncio.sleep(delay)\r\n                else:\r\n                    self.logger.error(f"All {self.max_retries + 1} async attempts failed")\r\n                    raise last_exception\r\n\r\n    def _calculate_delay(self, attempt: int) -> float:\r\n        """\r\n        Calculate delay with exponential backoff and jitter\r\n        """\r\n        # Exponential backoff: base_delay * (2^attempt)\r\n        delay = self.base_delay * (2 ** attempt)\r\n        # Cap the delay\r\n        delay = min(delay, self.max_delay)\r\n        # Add jitter to prevent thundering herd\r\n        delay = delay * (0.5 + random.random() * 0.5)\r\n        return delay\r\n\r\n\r\n# Example usage in robotics\r\nclass RobotPerceptionService:\r\n    """\r\n    Example perception service with retry mechanism\r\n    """\r\n    def __init__(self):\r\n        self.retry_handler = RetryHandler(max_retries=3, base_delay=1.0)\r\n\r\n    def detect_objects(self, image_data: bytes) -> dict:\r\n        """\r\n        Detect objects using cloud vision service with retry\r\n        """\r\n        def _detect():\r\n            import requests\r\n            # Simulate cloud vision API call\r\n            response = requests.post(\r\n                "https://api.robotvision.com/detect",\r\n                files={"image": image_data},\r\n                timeout=30\r\n            )\r\n            response.raise_for_status()\r\n            return response.json()\r\n\r\n        try:\r\n            return self.retry_handler.execute_with_retry(\r\n                _detect,\r\n                retry_exceptions=(requests.RequestException, requests.Timeout)\r\n            )\r\n        except Exception as e:\r\n            self.logger.error(f"Object detection failed after retries: {e}")\r\n            # Return empty detection or use fallback\r\n            return {"objects": [], "success": False, "fallback_used": True}\n'})}),"\n",(0,i.jsx)(r.h3,{id:"3-fallback-and-degraded-mode-handling",children:"3. Fallback and Degraded Mode Handling"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:'# fallback_handling.py\r\nimport json\r\nimport os\r\nfrom typing import Dict, Any, Optional, List\r\nimport logging\r\n\r\n\r\nclass FallbackManager:\r\n    """\r\n    Manage fallback strategies for external service failures\r\n    """\r\n    def __init__(self, cache_directory: str = "/tmp/robot_cache"):\r\n        self.cache_directory = cache_directory\r\n        self.fallback_levels = [\r\n            "cloud_service",      # Primary\r\n            "edge_service",       # Secondary\r\n            "local_cache",        # Tertiary\r\n            "default_values",     # Last resort\r\n        ]\r\n        self.logger = logging.getLogger(__name__)\r\n\r\n        # Ensure cache directory exists\r\n        os.makedirs(cache_directory, exist_ok=True)\r\n\r\n    def execute_with_fallback(self, service_calls: List[Callable]) -> Any:\r\n        """\r\n        Execute service calls in order of preference until one succeeds\r\n        """\r\n        for i, service_call in enumerate(service_calls):\r\n            try:\r\n                result = service_call()\r\n                if result is not None:\r\n                    # Cache successful result\r\n                    self._cache_result(service_call.__name__, result)\r\n                    return result\r\n            except Exception as e:\r\n                self.logger.warning(\r\n                    f"Fallback level {i + 1} failed: {str(e)}"\r\n                )\r\n                continue\r\n\r\n        # If all fallbacks fail, raise exception\r\n        raise Exception("All fallback levels exhausted")\r\n\r\n    def _cache_result(self, service_name: str, result: Any):\r\n        """\r\n        Cache successful result for future fallback use\r\n        """\r\n        cache_file = os.path.join(self.cache_directory, f"{service_name}.json")\r\n        try:\r\n            with open(cache_file, \'w\') as f:\r\n                json.dump(result, f)\r\n        except Exception as e:\r\n            self.logger.error(f"Failed to cache result: {e}")\r\n\r\n    def get_cached_result(self, service_name: str, max_age_seconds: int = 3600) -> Optional[Any]:\r\n        """\r\n        Get cached result if it\'s recent enough\r\n        """\r\n        cache_file = os.path.join(self.cache_directory, f"{service_name}.json")\r\n        if not os.path.exists(cache_file):\r\n            return None\r\n\r\n        # Check file age\r\n        file_age = time.time() - os.path.getmtime(cache_file)\r\n        if file_age > max_age_seconds:\r\n            return None\r\n\r\n        try:\r\n            with open(cache_file, \'r\') as f:\r\n                return json.load(f)\r\n        except Exception as e:\r\n            self.logger.error(f"Failed to load cached result: {e}")\r\n            return None\r\n\r\n\r\nclass RobotServiceManager:\r\n    """\r\n    Example robot service manager with fallback capabilities\r\n    """\r\n    def __init__(self):\r\n        self.fallback_manager = FallbackManager()\r\n        self.logger = logging.getLogger(__name__)\r\n\r\n    def get_weather_data(self, location: str) -> dict:\r\n        """\r\n        Get weather data with multiple fallback options\r\n        """\r\n        def cloud_weather():\r\n            import requests\r\n            response = requests.get(f"https://api.weather.com/v1/current?location={location}")\r\n            response.raise_for_status()\r\n            return response.json()\r\n\r\n        def local_weather_cache():\r\n            return self.fallback_manager.get_cached_result("weather", max_age_seconds=1800)  # 30 min\r\n\r\n        def default_weather():\r\n            # Return default weather data\r\n            return {\r\n                "temperature": 20,\r\n                "humidity": 50,\r\n                "condition": "unknown",\r\n                "fallback": True\r\n            }\r\n\r\n        # Try services in order of preference\r\n        try:\r\n            return self.fallback_manager.execute_with_fallback([\r\n                cloud_weather,\r\n                local_weather_cache,\r\n                default_weather\r\n            ])\r\n        except Exception as e:\r\n            self.logger.error(f"Weather service completely failed: {e}")\r\n            return default_weather()\r\n\r\n    def get_navigation_route(self, start: str, end: str) -> dict:\r\n        """\r\n        Get navigation route with fallback options\r\n        """\r\n        def cloud_navigation():\r\n            import requests\r\n            response = requests.get(f"https://api.nav.com/v1/route?start={start}&end={end}")\r\n            response.raise_for_status()\r\n            return response.json()\r\n\r\n        def local_route_cache():\r\n            return self.fallback_manager.get_cached_result(f"route_{start}_{end}", max_age_seconds=300)  # 5 min\r\n\r\n        def simple_route():\r\n            # Return simple straight-line route\r\n            return {\r\n                "route": [{"x": 0, "y": 0}, {"x": 10, "y": 10}],  # Simplified\r\n                "distance": 14.14,\r\n                "estimated_time": 300,  # 5 minutes\r\n                "fallback": True,\r\n                "type": "simplified"\r\n            }\r\n\r\n        try:\r\n            return self.fallback_manager.execute_with_fallback([\r\n                cloud_navigation,\r\n                local_route_cache,\r\n                simple_route\r\n            ])\r\n        except Exception as e:\r\n            self.logger.error(f"Navigation service failed: {e}")\r\n            return simple_route()\n'})}),"\n",(0,i.jsx)(r.h3,{id:"4-health-monitoring-and-service-discovery",children:"4. Health Monitoring and Service Discovery"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:'# health_monitoring.py\r\nimport asyncio\r\nimport aiohttp\r\nimport time\r\nfrom typing import Dict, List, Optional\r\nimport logging\r\n\r\n\r\nclass ServiceHealthMonitor:\r\n    """\r\n    Monitor health of external services\r\n    """\r\n    def __init__(self, check_interval: int = 30):\r\n        self.check_interval = check_interval\r\n        self.services = {}\r\n        self.health_status = {}\r\n        self.logger = logging.getLogger(__name__)\r\n\r\n    def add_service(self, name: str, url: str, health_endpoint: str = "/health"):\r\n        """\r\n        Add service to monitoring\r\n        """\r\n        self.services[name] = {\r\n            "url": url,\r\n            "health_endpoint": health_endpoint,\r\n            "last_check": 0,\r\n            "status": "unknown",\r\n            "response_time": 0\r\n        }\r\n\r\n    async def monitor_services(self):\r\n        """\r\n        Continuously monitor service health\r\n        """\r\n        while True:\r\n            for service_name, service_info in self.services.items():\r\n                await self._check_service_health(service_name, service_info)\r\n\r\n            await asyncio.sleep(self.check_interval)\r\n\r\n    async def _check_service_health(self, name: str, info: Dict):\r\n        """\r\n        Check health of individual service\r\n        """\r\n        try:\r\n            start_time = time.time()\r\n\r\n            async with aiohttp.ClientSession() as session:\r\n                health_url = f"{info[\'url\']}{info[\'health_endpoint\']}"\r\n                async with session.get(health_url, timeout=10) as response:\r\n                    response_time = time.time() - start_time\r\n\r\n                    if response.status == 200:\r\n                        status = "healthy"\r\n                    else:\r\n                        status = "unhealthy"\r\n\r\n                    self.health_status[name] = {\r\n                        "status": status,\r\n                        "response_time": response_time,\r\n                        "last_check": time.time(),\r\n                        "http_status": response.status\r\n                    }\r\n\r\n                    self.logger.info(f"Service {name} health: {status} (response: {response_time:.2f}s)")\r\n\r\n        except Exception as e:\r\n            self.health_status[name] = {\r\n                "status": "unreachable",\r\n                "response_time": -1,\r\n                "last_check": time.time(),\r\n                "error": str(e)\r\n            }\r\n            self.logger.error(f"Service {name} health check failed: {e}")\r\n\r\n    def get_healthy_services(self) -> List[str]:\r\n        """\r\n        Get list of currently healthy services\r\n        """\r\n        return [\r\n            name for name, status in self.health_status.items()\r\n            if status.get("status") == "healthy"\r\n        ]\r\n\r\n    def is_service_healthy(self, service_name: str) -> bool:\r\n        """\r\n        Check if specific service is healthy\r\n        """\r\n        status = self.health_status.get(service_name, {}).get("status")\r\n        return status == "healthy"\r\n\r\n\r\nclass ServiceDiscoveryManager:\r\n    """\r\n    Manage service discovery and routing based on health status\r\n    """\r\n    def __init__(self):\r\n        self.health_monitor = ServiceHealthMonitor()\r\n        self.service_priority = {}  # Service name to priority mapping\r\n\r\n    def register_service(self, name: str, url: str, priority: int = 1):\r\n        """\r\n        Register service with priority\r\n        """\r\n        self.health_monitor.add_service(name, url)\r\n        self.service_priority[name] = priority\r\n\r\n    def get_best_available_service(self, service_type: str) -> Optional[str]:\r\n        """\r\n        Get the best available service of specified type\r\n        """\r\n        healthy_services = self.health_monitor.get_healthy_services()\r\n\r\n        # Filter services by type (e.g., "nav_service_1", "nav_service_2" -> "nav")\r\n        type_services = [\r\n            service for service in healthy_services\r\n            if service_type.lower() in service.lower()\r\n        ]\r\n\r\n        if not type_services:\r\n            return None\r\n\r\n        # Return service with highest priority\r\n        best_service = max(\r\n            type_services,\r\n            key=lambda s: self.service_priority.get(s, 0)\r\n        )\r\n\r\n        return best_service\r\n\r\n    async def start_monitoring(self):\r\n        """\r\n        Start health monitoring\r\n        """\r\n        await self.health_monitor.monitor_services()\n'})}),"\n",(0,i.jsx)(r.h3,{id:"5-comprehensive-failure-handling-example",children:"5. Comprehensive Failure Handling Example"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:'# comprehensive_failure_handling.py\r\nimport asyncio\r\nimport aiohttp\r\nimport time\r\nimport random\r\nfrom typing import Dict, Any, Optional, Callable, List\r\nimport logging\r\n\r\n\r\nclass ComprehensiveFailureHandler:\r\n    """\r\n    Comprehensive failure handling system for robotics applications\r\n    """\r\n    def __init__(self):\r\n        self.circuit_breaker = CircuitBreaker(failure_threshold=3, timeout=60)\r\n        self.retry_handler = RetryHandler(max_retries=3, base_delay=1.0)\r\n        self.fallback_manager = FallbackManager()\r\n        self.health_monitor = ServiceHealthMonitor()\r\n        self.logger = logging.getLogger(__name__)\r\n\r\n        # Service configuration\r\n        self.services_config = {\r\n            "navigation": {\r\n                "primary": "https://nav-api.primary.com",\r\n                "secondary": "https://nav-api.backup.com",\r\n                "timeout": 30\r\n            },\r\n            "perception": {\r\n                "primary": "https://vision-api.primary.com",\r\n                "secondary": "https://vision-api.backup.com",\r\n                "timeout": 15\r\n            },\r\n            "llm": {\r\n                "primary": "https://llm-api.primary.com",\r\n                "secondary": "https://llm-api.backup.com",\r\n                "timeout": 45\r\n            }\r\n        }\r\n\r\n    async def handle_navigation_request(self, start_location: str, end_location: str) -> Dict[str, Any]:\r\n        """\r\n        Handle navigation request with comprehensive failure handling\r\n        """\r\n        # First, check if primary service is healthy\r\n        if self.health_monitor.is_service_healthy("nav_primary"):\r\n            service_url = self.services_config["navigation"]["primary"]\r\n        else:\r\n            service_url = self.services_config["navigation"]["secondary"]\r\n            self.logger.warning("Using secondary navigation service")\r\n\r\n        async def _make_navigation_request():\r\n            try:\r\n                async with aiohttp.ClientSession() as session:\r\n                    async with session.get(\r\n                        f"{service_url}/route",\r\n                        params={"start": start_location, "end": end_location},\r\n                        timeout=aiohttp.ClientTimeout(total=self.services_config["navigation"]["timeout"])\r\n                    ) as response:\r\n                        if response.status != 200:\r\n                            raise Exception(f"Navigation service returned status {response.status}")\r\n                        return await response.json()\r\n            except Exception as e:\r\n                self.logger.error(f"Navigation request failed: {e}")\r\n                raise\r\n\r\n        # Apply circuit breaker protection\r\n        try:\r\n            result = await self.circuit_breaker.call(_make_navigation_request)\r\n            return result\r\n        except Exception as e:\r\n            self.logger.warning(f"Primary navigation failed: {e}")\r\n\r\n            # Try fallback mechanisms\r\n            return await self._navigation_fallback(start_location, end_location)\r\n\r\n    async def _navigation_fallback(self, start_location: str, end_location: str) -> Dict[str, Any]:\r\n        """\r\n        Fallback navigation implementation\r\n        """\r\n        # Try cached route first\r\n        cached_route = self.fallback_manager.get_cached_result(\r\n            f"route_{start_location}_{end_location}",\r\n            max_age_seconds=300  # 5 minutes\r\n        )\r\n\r\n        if cached_route:\r\n            self.logger.info("Using cached navigation route")\r\n            cached_route["fallback_used"] = True\r\n            return cached_route\r\n\r\n        # Try local path planning as last resort\r\n        local_route = await self._local_path_planning(start_location, end_location)\r\n        local_route["fallback_used"] = True\r\n        local_route["source"] = "local_planning"\r\n\r\n        self.logger.info("Using local path planning as navigation fallback")\r\n        return local_route\r\n\r\n    async def _local_path_planning(self, start_location: str, end_location: str) -> Dict[str, Any]:\r\n        """\r\n        Local path planning implementation (simplified)\r\n        """\r\n        # In a real implementation, this would use local path planning algorithms\r\n        # For this example, we\'ll simulate a simple path\r\n        import math\r\n\r\n        # Calculate straight-line distance (simplified coordinates)\r\n        start_coords = (0, 0)  # Simplified\r\n        end_coords = (10, 10)  # Simplified\r\n\r\n        distance = math.sqrt((end_coords[0] - start_coords[0])**2 + (end_coords[1] - start_coords[1])**2)\r\n\r\n        # Generate simple path points\r\n        path_points = [\r\n            {"x": start_coords[0], "y": start_coords[1]},\r\n            {"x": end_coords[0], "y": end_coords[1]}\r\n        ]\r\n\r\n        return {\r\n            "route": path_points,\r\n            "distance": distance,\r\n            "estimated_time": distance * 60,  # Simplified time calculation\r\n            "success": True,\r\n            "method": "local_straight_line"\r\n        }\r\n\r\n    async def handle_perception_request(self, image_data: bytes) -> Dict[str, Any]:\r\n        """\r\n        Handle perception request with failure handling\r\n        """\r\n        # Check service health\r\n        service_url = self.services_config["perception"]["primary"]\r\n        if not self.health_monitor.is_service_healthy("vision_primary"):\r\n            service_url = self.services_config["perception"]["secondary"]\r\n            self.logger.warning("Using secondary vision service")\r\n\r\n        async def _make_perception_request():\r\n            data = aiohttp.FormData()\r\n            data.add_field(\'image\', image_data, content_type=\'image/jpeg\')\r\n\r\n            async with aiohttp.ClientSession() as session:\r\n                async with session.post(\r\n                    f"{service_url}/detect",\r\n                    data=data,\r\n                    timeout=aiohttp.ClientTimeout(total=self.services_config["perception"]["timeout"])\r\n                ) as response:\r\n                    if response.status != 200:\r\n                        raise Exception(f"Perception service returned status {response.status}")\r\n                    return await response.json()\r\n\r\n        try:\r\n            # Apply retry mechanism\r\n            result = await self.retry_handler.execute_with_retry_async(_make_perception_request)\r\n            return result\r\n        except Exception as e:\r\n            self.logger.warning(f"Cloud perception failed: {e}")\r\n            return await self._perception_fallback(image_data)\r\n\r\n    async def _perception_fallback(self, image_data: bytes) -> Dict[str, Any]:\r\n        """\r\n        Fallback perception implementation\r\n        """\r\n        # For this example, return empty detection\r\n        # In practice, this might use local computer vision models\r\n        return {\r\n            "objects": [],\r\n            "detections": [],\r\n            "success": True,\r\n            "fallback_used": True,\r\n            "method": "local_empty_detection"\r\n        }\r\n\r\n    async def handle_llm_request(self, prompt: str, context: Dict[str, Any]) -> Dict[str, Any]:\r\n        """\r\n        Handle LLM request with comprehensive failure handling\r\n        """\r\n        service_url = self.services_config["llm"]["primary"]\r\n        if not self.health_monitor.is_service_healthy("llm_primary"):\r\n            service_url = self.services_config["llm"]["secondary"]\r\n            self.logger.warning("Using secondary LLM service")\r\n\r\n        async def _make_llm_request():\r\n            payload = {\r\n                "prompt": prompt,\r\n                "context": context,\r\n                "temperature": 0.7\r\n            }\r\n\r\n            async with aiohttp.ClientSession() as session:\r\n                async with session.post(\r\n                    f"{service_url}/generate",\r\n                    json=payload,\r\n                    timeout=aiohttp.ClientTimeout(total=self.services_config["llm"]["timeout"])\r\n                ) as response:\r\n                    if response.status != 200:\r\n                        raise Exception(f"LLM service returned status {response.status}")\r\n                    return await response.json()\r\n\r\n        try:\r\n            # Use circuit breaker for LLM requests\r\n            result = await self.circuit_breaker.call(_make_llm_request)\r\n            return result\r\n        except Exception as e:\r\n            self.logger.warning(f"Cloud LLM failed: {e}")\r\n            return await self._llm_fallback(prompt, context)\r\n\r\n    async def _llm_fallback(self, prompt: str, context: Dict[str, Any]) -> Dict[str, Any]:\r\n        """\r\n        Fallback LLM implementation\r\n        """\r\n        # For this example, return a default response\r\n        # In practice, this might use a local LLM or rule-based system\r\n        fallback_responses = [\r\n            "I understand your request, but I need to process it locally.",\r\n            "Processing your command with local capabilities.",\r\n            "I can help with that using my local knowledge.",\r\n            "Let me handle this with my built-in functions."\r\n        ]\r\n\r\n        return {\r\n            "response": random.choice(fallback_responses),\r\n            "success": True,\r\n            "fallback_used": True,\r\n            "method": "local_fallback"\r\n        }\r\n\r\n    async def start_monitoring(self):\r\n        """\r\n        Start service health monitoring\r\n        """\r\n        await self.health_monitor.monitor_services()\r\n\r\n\r\n# Example usage in a robot system\r\nclass RobotSystem:\r\n    """\r\n    Example robot system using comprehensive failure handling\r\n    """\r\n    def __init__(self):\r\n        self.failure_handler = ComprehensiveFailureHandler()\r\n        self.logger = logging.getLogger(__name__)\r\n\r\n    async def execute_navigation_task(self, destination: str) -> bool:\r\n        """\r\n        Execute navigation task with failure handling\r\n        """\r\n        try:\r\n            # Get current location (simplified)\r\n            current_location = "current_pos"\r\n\r\n            # Get navigation route with failure handling\r\n            route_data = await self.failure_handler.handle_navigation_request(\r\n                current_location, destination\r\n            )\r\n\r\n            if route_data.get("success", False):\r\n                self.logger.info(f"Navigation route obtained: {route_data}")\r\n                # Execute navigation using route_data\r\n                return True\r\n            else:\r\n                self.logger.error("Failed to get navigation route")\r\n                return False\r\n\r\n        except Exception as e:\r\n            self.logger.error(f"Navigation task failed: {e}")\r\n            return False\r\n\r\n    async def execute_perception_task(self, image_data: bytes) -> Dict[str, Any]:\r\n        """\r\n        Execute perception task with failure handling\r\n        """\r\n        try:\r\n            perception_data = await self.failure_handler.handle_perception_request(image_data)\r\n            self.logger.info(f"Perception results: {perception_data}")\r\n            return perception_data\r\n        except Exception as e:\r\n            self.logger.error(f"Perception task failed: {e}")\r\n            return {"objects": [], "success": False, "error": str(e)}\r\n\r\n    async def execute_command_with_llm(self, user_command: str, robot_context: Dict[str, Any]) -> str:\r\n        """\r\n        Execute command using LLM with failure handling\r\n        """\r\n        try:\r\n            llm_response = await self.failure_handler.handle_llm_request(user_command, robot_context)\r\n            self.logger.info(f"LLM response: {llm_response}")\r\n            return llm_response.get("response", "Command processed")\r\n        except Exception as e:\r\n            self.logger.error(f"LLM command processing failed: {e}")\r\n            return "I encountered an issue processing your command, but I\'m continuing with basic functions."\n'})}),"\n",(0,i.jsx)(r.h3,{id:"6-emergency-and-graceful-degradation-procedures",children:"6. Emergency and Graceful Degradation Procedures"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:'# emergency_procedures.py\r\nimport asyncio\r\nimport signal\r\nimport sys\r\nfrom typing import Dict, Any, Callable\r\nimport logging\r\n\r\n\r\nclass EmergencyProcedureManager:\r\n    """\r\n    Manage emergency procedures and graceful degradation\r\n    """\r\n    def __init__(self):\r\n        self.emergency_procedures = {}\r\n        self.degradation_levels = {}\r\n        self.current_level = "normal"\r\n        self.logger = logging.getLogger(__name__)\r\n\r\n        # Register signal handlers for graceful shutdown\r\n        signal.signal(signal.SIGTERM, self._signal_handler)\r\n        signal.signal(signal.SIGINT, self._signal_handler)\r\n\r\n    def register_emergency_procedure(self, level: str, procedure: Callable):\r\n        """\r\n        Register emergency procedure for specific degradation level\r\n        """\r\n        self.emergency_procedures[level] = procedure\r\n\r\n    def set_degradation_level(self, level: str):\r\n        """\r\n        Set current system degradation level\r\n        """\r\n        old_level = self.current_level\r\n        self.current_level = level\r\n\r\n        self.logger.warning(f"System degradation level changed from {old_level} to {level}")\r\n\r\n        # Execute appropriate emergency procedure if registered\r\n        if level in self.emergency_procedures:\r\n            try:\r\n                self.emergency_procedures[level]()\r\n            except Exception as e:\r\n                self.logger.error(f"Emergency procedure for level {level} failed: {e}")\r\n\r\n    def _signal_handler(self, signum, frame):\r\n        """\r\n        Handle system signals for graceful shutdown\r\n        """\r\n        self.logger.info(f"Received signal {signum}, initiating graceful shutdown")\r\n        self.initiate_emergency_shutdown()\r\n        sys.exit(0)\r\n\r\n    def initiate_emergency_shutdown(self):\r\n        """\r\n        Initiate emergency shutdown procedures\r\n        """\r\n        self.logger.critical("Initiating emergency shutdown")\r\n\r\n        # Set emergency degradation level\r\n        self.set_degradation_level("emergency_shutdown")\r\n\r\n        # Stop all non-critical services\r\n        self._stop_non_critical_services()\r\n\r\n        # Save critical state\r\n        self._save_critical_state()\r\n\r\n        # Execute emergency stop if needed\r\n        self._execute_emergency_stop()\r\n\r\n    def _stop_non_critical_services(self):\r\n        """\r\n        Stop non-critical services to conserve resources\r\n        """\r\n        self.logger.info("Stopping non-critical services")\r\n        # Implementation would stop services like:\r\n        # - Advanced perception\r\n        # - Cloud connectivity\r\n        # - Non-essential computations\r\n        pass\r\n\r\n    def _save_critical_state(self):\r\n        """\r\n        Save critical system state before shutdown\r\n        """\r\n        self.logger.info("Saving critical system state")\r\n        # Implementation would save:\r\n        # - Current position\r\n        # - Task progress\r\n        # - System configuration\r\n        pass\r\n\r\n    def _execute_emergency_stop(self):\r\n        """\r\n        Execute emergency stop if system is mobile\r\n        """\r\n        self.logger.info("Executing emergency stop")\r\n        # Implementation would send stop commands to:\r\n        # - Motor controllers\r\n        # - Navigation system\r\n        # - Manipulator arms\r\n        pass\r\n\r\n    def get_degradation_plan(self) -> Dict[str, Any]:\r\n        """\r\n        Get current degradation plan\r\n        """\r\n        return {\r\n            "current_level": self.current_level,\r\n            "allowed_functions": self._get_allowed_functions(),\r\n            "resource_allocation": self._get_resource_allocation(),\r\n            "safety_measures": self._get_safety_measures()\r\n        }\r\n\r\n    def _get_allowed_functions(self) -> List[str]:\r\n        """\r\n        Get functions allowed at current degradation level\r\n        """\r\n        level_functions = {\r\n            "normal": ["all_functions"],\r\n            "degraded": ["basic_navigation", "essential_sensors", "emergency_comm"],\r\n            "critical": ["safety_systems", "position_hold", "emergency_comm"],\r\n            "emergency_shutdown": ["none"]\r\n        }\r\n        return level_functions.get(self.current_level, ["none"])\r\n\r\n    def _get_resource_allocation(self) -> Dict[str, float]:\r\n        """\r\n        Get resource allocation at current level\r\n        """\r\n        level_resources = {\r\n            "normal": {"cpu": 1.0, "memory": 1.0, "power": 1.0},\r\n            "degraded": {"cpu": 0.7, "memory": 0.6, "power": 0.8},\r\n            "critical": {"cpu": 0.3, "memory": 0.2, "power": 0.5},\r\n            "emergency_shutdown": {"cpu": 0.1, "memory": 0.1, "power": 0.2}\r\n        }\r\n        return level_resources.get(self.current_level, {"cpu": 0.0, "memory": 0.0, "power": 0.0})\r\n\r\n    def _get_safety_measures(self) -> List[str]:\r\n        """\r\n        Get active safety measures\r\n        """\r\n        level_safety = {\r\n            "normal": ["standard_safety"],\r\n            "degraded": ["standard_safety", "reduced_speed"],\r\n            "critical": ["standard_safety", "position_hold", "reduced_speed"],\r\n            "emergency_shutdown": ["full_stop", "safe_position", "power_down"]\r\n        }\r\n        return level_safety.get(self.current_level, ["none"])\r\n\r\n\r\n# Example emergency procedures\r\ndef emergency_shutdown_procedure():\r\n    """\r\n    Procedure for emergency shutdown level\r\n    """\r\n    logging.getLogger(__name__).critical("Executing emergency shutdown procedure")\r\n    # Stop all movement\r\n    # Activate emergency brakes\r\n    # Save critical data\r\n    # Power down non-essential systems\r\n\r\n\r\ndef critical_degradation_procedure():\r\n    """\r\n    Procedure for critical degradation level\r\n    """\r\n    logging.getLogger(__name__).warning("Executing critical degradation procedure")\r\n    # Reduce system functions to essentials\r\n    # Maintain safe position\r\n    # Preserve power\r\n    pass\r\n\r\n\r\ndef degraded_operation_procedure():\r\n    """\r\n    Procedure for degraded operation level\r\n    """\r\n    logging.getLogger(__name__).info("Executing degraded operation procedure")\r\n    # Reduce performance requirements\r\n    # Switch to local processing\r\n    # Limit non-essential functions\r\n    pass\r\n\r\n\r\n# Integration example\r\nclass RobustRobotSystem:\r\n    """\r\n    Example of integrating all failure handling components\r\n    """\r\n    def __init__(self):\r\n        self.failure_handler = ComprehensiveFailureHandler()\r\n        self.emergency_manager = EmergencyProcedureManager()\r\n\r\n        # Register emergency procedures\r\n        self.emergency_manager.register_emergency_procedure("emergency_shutdown", emergency_shutdown_procedure)\r\n        self.emergency_manager.register_emergency_procedure("critical", critical_degradation_procedure)\r\n        self.emergency_manager.register_emergency_procedure("degraded", degraded_operation_procedure)\r\n\r\n    async def run_with_resilience(self):\r\n        """\r\n        Run robot system with comprehensive resilience\r\n        """\r\n        try:\r\n            while True:\r\n                # Check system health\r\n                if self._is_system_stressed():\r\n                    self.emergency_manager.set_degradation_level("degraded")\r\n\r\n                # Perform tasks with failure handling\r\n                await self._perform_resilient_tasks()\r\n\r\n                await asyncio.sleep(1)  # Main loop delay\r\n\r\n        except Exception as e:\r\n            self.logger.error(f"System error: {e}")\r\n            self.emergency_manager.set_degradation_level("critical")\r\n\r\n    def _is_system_stressed(self) -> bool:\r\n        """\r\n        Check if system is under stress\r\n        """\r\n        # Check for multiple service failures, high resource usage, etc.\r\n        return False  # Simplified\r\n\r\n    async def _perform_resilient_tasks(self):\r\n        """\r\n        Perform tasks with built-in resilience\r\n        """\r\n        # Example tasks with failure handling\r\n        await self.failure_handler.handle_navigation_request("start", "end")\r\n        # Add other resilient tasks\r\n        pass\n'})}),"\n",(0,i.jsx)(r.h2,{id:"best-practices-for-external-service-failure-handling",children:"Best Practices for External Service Failure Handling"}),"\n",(0,i.jsx)(r.h3,{id:"1-proactive-monitoring",children:"1. Proactive Monitoring"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Implement health checks for all external dependencies"}),"\n",(0,i.jsx)(r.li,{children:"Monitor response times and error rates"}),"\n",(0,i.jsx)(r.li,{children:"Set up alerts for service degradation"}),"\n",(0,i.jsx)(r.li,{children:"Track service availability metrics"}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"2-graceful-degradation",children:"2. Graceful Degradation"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Design systems to operate with reduced functionality"}),"\n",(0,i.jsx)(r.li,{children:"Prioritize critical functions during failures"}),"\n",(0,i.jsx)(r.li,{children:"Provide fallback mechanisms for all external services"}),"\n",(0,i.jsx)(r.li,{children:"Maintain essential safety functions"}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"3-circuit-breaker-best-practices",children:"3. Circuit Breaker Best Practices"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Set appropriate failure thresholds"}),"\n",(0,i.jsx)(r.li,{children:"Use reasonable timeout values"}),"\n",(0,i.jsx)(r.li,{children:"Implement proper state transitions"}),"\n",(0,i.jsx)(r.li,{children:"Monitor circuit breaker effectiveness"}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"4-retry-strategy-guidelines",children:"4. Retry Strategy Guidelines"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Use exponential backoff with jitter"}),"\n",(0,i.jsx)(r.li,{children:"Limit maximum retry attempts"}),"\n",(0,i.jsx)(r.li,{children:"Handle different failure types appropriately"}),"\n",(0,i.jsx)(r.li,{children:"Consider the nature of the failure before retrying"}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"5-data-consistency",children:"5. Data Consistency"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Implement idempotent operations where possible"}),"\n",(0,i.jsx)(r.li,{children:"Use proper transaction management"}),"\n",(0,i.jsx)(r.li,{children:"Handle partial failures gracefully"}),"\n",(0,i.jsx)(r.li,{children:"Maintain data integrity during failures"}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"6-logging-and-observability",children:"6. Logging and Observability"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Log all failure events with sufficient detail"}),"\n",(0,i.jsx)(r.li,{children:"Track failure patterns and trends"}),"\n",(0,i.jsx)(r.li,{children:"Monitor fallback usage"}),"\n",(0,i.jsx)(r.li,{children:"Maintain audit trails for security"}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"This comprehensive guide provides practical examples and implementation strategies for handling external service failures in robotics applications, ensuring robust and resilient robot operation even when external services are unavailable."})]})}function u(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},7074:(e,r,n)=>{n.d(r,{R:()=>s,x:()=>l});var t=n(6540);const i={},a=t.createContext(i);function s(e){const r=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function l(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(a.Provider,{value:r},e.children)}}}]);