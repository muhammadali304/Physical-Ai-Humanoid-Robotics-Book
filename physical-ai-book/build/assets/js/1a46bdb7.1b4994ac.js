"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[7660],{359:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>t,contentTitle:()=>a,default:()=>m,frontMatter:()=>l,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"simulation/physics-performance-optimization","title":"Physics Simulation Performance Optimization Guide","description":"Overview","source":"@site/docs/simulation/physics-performance-optimization.md","sourceDirName":"simulation","slug":"/simulation/physics-performance-optimization","permalink":"/docs/simulation/physics-performance-optimization","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/simulation/physics-performance-optimization.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"How to Verify Accurate Sensor Data Generation","permalink":"/docs/simulation/sensor-data-verification"},"next":{"title":"FPS Validation Process for Physics Simulation","permalink":"/docs/simulation/fps-validation-process"}}');var s=i(4848),o=i(7074);const l={},a="Physics Simulation Performance Optimization Guide",t={},c=[{value:"Overview",id:"overview",level:2},{value:"Performance Metrics",id:"performance-metrics",level:2},{value:"Target Performance",id:"target-performance",level:3},{value:"Key Performance Indicators",id:"key-performance-indicators",level:3},{value:"Physics Engine Configuration",id:"physics-engine-configuration",level:2},{value:"ODE (Open Dynamics Engine) Optimization",id:"ode-open-dynamics-engine-optimization",level:3},{value:"Basic Physics Configuration",id:"basic-physics-configuration",level:4},{value:"Performance vs. Accuracy Trade-offs",id:"performance-vs-accuracy-trade-offs",level:4},{value:"Alternative Physics Engines",id:"alternative-physics-engines",level:3},{value:"Model Optimization Strategies",id:"model-optimization-strategies",level:2},{value:"1. Simplified Collision Geometries",id:"1-simplified-collision-geometries",level:3},{value:"2. Level of Detail (LOD)",id:"2-level-of-detail-lod",level:3},{value:"3. Efficient Mesh Formats",id:"3-efficient-mesh-formats",level:3},{value:"World Optimization",id:"world-optimization",level:2},{value:"1. Terrain Optimization",id:"1-terrain-optimization",level:3},{value:"2. Static vs Dynamic Objects",id:"2-static-vs-dynamic-objects",level:3},{value:"3. Occlusion and Culling",id:"3-occlusion-and-culling",level:3},{value:"Sensor Optimization",id:"sensor-optimization",level:2},{value:"1. Sensor Update Rates",id:"1-sensor-update-rates",level:3},{value:"2. Sensor Resolution",id:"2-sensor-resolution",level:3},{value:"Plugin Optimization",id:"plugin-optimization",level:2},{value:"1. Efficient Controller Plugins",id:"1-efficient-controller-plugins",level:3},{value:"2. Asynchronous Processing",id:"2-asynchronous-processing",level:3},{value:"Hardware Considerations",id:"hardware-considerations",level:2},{value:"CPU Optimization",id:"cpu-optimization",level:3},{value:"Memory Management",id:"memory-management",level:3},{value:"GPU Acceleration",id:"gpu-acceleration",level:3},{value:"Gazebo-Specific Optimizations",id:"gazebo-specific-optimizations",level:2},{value:"1. Real-Time Factor Configuration",id:"1-real-time-factor-configuration",level:3},{value:"2. Threading Configuration",id:"2-threading-configuration",level:3},{value:"3. Scene Graph Optimization",id:"3-scene-graph-optimization",level:3},{value:"Performance Monitoring Tools",id:"performance-monitoring-tools",level:2},{value:"1. Built-in Gazebo Tools",id:"1-built-in-gazebo-tools",level:3},{value:"2. System Monitoring",id:"2-system-monitoring",level:3},{value:"3. Custom Performance Scripts",id:"3-custom-performance-scripts",level:3},{value:"Common Performance Issues and Solutions",id:"common-performance-issues-and-solutions",level:2},{value:"Issue: Low FPS (Under 30)",id:"issue-low-fps-under-30",level:3},{value:"Issue: Unstable Physics",id:"issue-unstable-physics",level:3},{value:"Issue: High CPU Usage",id:"issue-high-cpu-usage",level:3},{value:"Issue: Jittery Movement",id:"issue-jittery-movement",level:3},{value:"Best Practices Summary",id:"best-practices-summary",level:2},{value:"Performance Validation Checklist",id:"performance-validation-checklist",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"physics-simulation-performance-optimization-guide",children:"Physics Simulation Performance Optimization Guide"})}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"This guide provides strategies and techniques for optimizing physics simulation performance in Gazebo to achieve stable 30+ FPS performance. Proper optimization is essential for real-time simulation and responsive robot behavior."}),"\n",(0,s.jsx)(n.h2,{id:"performance-metrics",children:"Performance Metrics"}),"\n",(0,s.jsx)(n.h3,{id:"target-performance",children:"Target Performance"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Minimum"}),": 30 FPS for smooth real-time simulation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Recommended"}),": 60 FPS for high-quality real-time simulation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Maximum"}),": 100+ FPS for fast simulation (when real-time factor is not critical)"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"key-performance-indicators",children:"Key Performance Indicators"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Simulation update rate (Hz)"}),"\n",(0,s.jsx)(n.li,{children:"Real-time factor (RTF)"}),"\n",(0,s.jsx)(n.li,{children:"CPU utilization"}),"\n",(0,s.jsx)(n.li,{children:"Memory usage"}),"\n",(0,s.jsx)(n.li,{children:"Physics engine step time"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"physics-engine-configuration",children:"Physics Engine Configuration"}),"\n",(0,s.jsx)(n.h3,{id:"ode-open-dynamics-engine-optimization",children:"ODE (Open Dynamics Engine) Optimization"}),"\n",(0,s.jsx)(n.p,{children:"The most common physics engine in Gazebo is ODE. Here's how to optimize its configuration:"}),"\n",(0,s.jsx)(n.h4,{id:"basic-physics-configuration",children:"Basic Physics Configuration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<physics name="fast_physics" type="ode">\r\n  \x3c!-- Smaller step size for accuracy, larger for performance --\x3e\r\n  <max_step_size>0.001</max_step_size>\r\n\r\n  \x3c!-- Target real-time update rate --\x3e\r\n  <real_time_update_rate>1000.0</real_time_update_rate>\r\n\r\n  \x3c!-- Gravity setting --\x3e\r\n  <gravity>0 0 -9.8</gravity>\r\n\r\n  <ode>\r\n    <solver>\r\n      \x3c!-- Use \'quick\' solver for better performance --\x3e\r\n      <type>quick</type>\r\n      \x3c!-- Iterations: fewer = faster but less accurate --\x3e\r\n      <iters>20</iters>\r\n      \x3c!-- Successive Over Relaxation parameter --\x3e\r\n      <sor>1.3</sor>\r\n    </solver>\r\n    <constraints>\r\n      \x3c!-- Constraint Force Mixing --\x3e\r\n      <cfm>0.0</cfm>\r\n      \x3c!-- Error Reduction Parameter --\x3e\r\n      <erp>0.2</erp>\r\n      \x3c!-- Maximum correcting velocity --\x3e\r\n      <contact_max_correcting_vel>100.0</contact_max_correcting_vel>\r\n      \x3c!-- Contact surface layer thickness --\x3e\r\n      <contact_surface_layer>0.001</contact_surface_layer>\r\n    </constraints>\r\n  </ode>\r\n</physics>\n'})}),"\n",(0,s.jsx)(n.h4,{id:"performance-vs-accuracy-trade-offs",children:"Performance vs. Accuracy Trade-offs"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:["Higher ",(0,s.jsx)(n.code,{children:"max_step_size"})]}),": Better performance, less accuracy"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:["Lower ",(0,s.jsx)(n.code,{children:"iters"})]}),": Better performance, less accuracy"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:["Higher ",(0,s.jsx)(n.code,{children:"sor"})]}),": Potentially better convergence but may be unstable"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:["Higher ",(0,s.jsx)(n.code,{children:"contact_surface_layer"})]}),": More stable contacts but less accurate"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"alternative-physics-engines",children:"Alternative Physics Engines"}),"\n",(0,s.jsx)(n.p,{children:"Consider using DART or Bullet for specific use cases:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"DART"}),": Better for articulated robots with many joints"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Bullet"}),": Better for complex collision detection"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"model-optimization-strategies",children:"Model Optimization Strategies"}),"\n",(0,s.jsx)(n.h3,{id:"1-simplified-collision-geometries",children:"1. Simplified Collision Geometries"}),"\n",(0,s.jsx)(n.p,{children:"Use simplified collision meshes to reduce computation:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Good: Use simple shapes for collision --\x3e\r\n<link name="simple_box">\r\n  <collision name="collision">\r\n    <geometry>\r\n      <box>\r\n        <size>1 1 1</size>\r\n      </box>\r\n    </geometry>\r\n  </collision>\r\n  <visual name="visual">\r\n    <geometry>\r\n      <mesh filename="complex_robot_model.dae"/>\r\n    </geometry>\r\n  </visual>\r\n</link>\r\n\r\n\x3c!-- Avoid: Complex meshes for collision --\x3e\r\n<link name="complex_mesh">\r\n  <collision name="collision">\r\n    <geometry>\r\n      <mesh filename="complex_robot_model.dae"/>  \x3c!-- This is expensive! --\x3e\r\n    </geometry>\r\n  </collision>\r\n</link>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"2-level-of-detail-lod",children:"2. Level of Detail (LOD)"}),"\n",(0,s.jsx)(n.p,{children:"Implement LOD for complex models:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<link name="detailed_link">\r\n  <visual name="visual_lod_0">\r\n    <geometry>\r\n      <mesh filename="high_detail.dae"/>\r\n    </geometry>\r\n    <material>\r\n      <script>Gazebo/Blue<\/script>\r\n    </material>\r\n  </visual>\r\n  <visual name="visual_lod_1">\r\n    <geometry>\r\n      <mesh filename="medium_detail.dae"/>\r\n    </geometry>\r\n    <material>\r\n      <script>Gazebo/Blue<\/script>\r\n    </material>\r\n    \x3c!-- Enable LOD --\x3e\r\n    <lod>\r\n      <max lod="1"/>\r\n    </lod>\r\n  </visual>\r\n</link>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"3-efficient-mesh-formats",children:"3. Efficient Mesh Formats"}),"\n",(0,s.jsx)(n.p,{children:"Use efficient mesh formats and simplify where possible:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"DAE"}),": Good for complex models with textures"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"STL"}),": Good for collision meshes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"OBJ"}),": Good balance of features and performance"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"world-optimization",children:"World Optimization"}),"\n",(0,s.jsx)(n.h3,{id:"1-terrain-optimization",children:"1. Terrain Optimization"}),"\n",(0,s.jsx)(n.p,{children:"For large outdoor environments:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Use heightmap with appropriate resolution --\x3e\r\n<model name="terrain">\r\n  <static>true</static>\r\n  <link name="link">\r\n    <collision name="collision">\r\n      <geometry>\r\n        <heightmap>\r\n          <uri>model://my_terrain/heightmap.png</uri>\r\n          \x3c!-- Reduce resolution for better performance --\x3e\r\n          <size>100 100 20</size>\r\n          <use_terrain_paging>false</use_terrain_paging>\r\n        </heightmap>\r\n      </geometry>\r\n    </collision>\r\n  </link>\r\n</model>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"2-static-vs-dynamic-objects",children:"2. Static vs Dynamic Objects"}),"\n",(0,s.jsx)(n.p,{children:"Mark static objects as static:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Static objects don\'t need physics calculations --\x3e\r\n<model name="building">\r\n  <static>true</static>  \x3c!-- This is key! --\x3e\r\n  <link name="main_link">\r\n    \x3c!-- ... --\x3e\r\n  </link>\r\n</model>\r\n\r\n\x3c!-- Dynamic objects need physics calculations --\x3e\r\n<model name="moving_robot">\r\n  <static>false</static>  \x3c!-- Default behavior --\x3e\r\n  <link name="main_link">\r\n    \x3c!-- ... --\x3e\r\n  </link>\r\n</model>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"3-occlusion-and-culling",children:"3. Occlusion and Culling"}),"\n",(0,s.jsx)(n.p,{children:"Remove objects that don't affect physics:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Decorative objects can be visual-only --\x3e\r\n<model name="decorative_tree">\r\n  <link name="visual_only">\r\n    <visual name="visual">\r\n      <geometry>\r\n        <mesh filename="tree.dae"/>\r\n      </geometry>\r\n    </visual>\r\n    \x3c!-- No collision element = no physics impact --\x3e\r\n  </link>\r\n</model>\n'})}),"\n",(0,s.jsx)(n.h2,{id:"sensor-optimization",children:"Sensor Optimization"}),"\n",(0,s.jsx)(n.h3,{id:"1-sensor-update-rates",children:"1. Sensor Update Rates"}),"\n",(0,s.jsx)(n.p,{children:"Optimize sensor update rates based on application needs:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- For navigation: 10-20 Hz LIDAR is often sufficient --\x3e\r\n<gazebo reference="lidar_link">\r\n  <sensor type="ray" name="lidar_sensor">\r\n    <update_rate>10</update_rate>  \x3c!-- Lower for better performance --\x3e\r\n    \x3c!-- ... --\x3e\r\n  </sensor>\r\n</gazebo>\r\n\r\n\x3c!-- For precise control: Higher update rates needed --\x3e\r\n<gazebo reference="imu_link">\r\n  <sensor type="imu" name="imu_sensor">\r\n    <update_rate>100</update_rate>  \x3c!-- Higher for IMU --\x3e\r\n    \x3c!-- ... --\x3e\r\n  </sensor>\r\n</gazebo>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"2-sensor-resolution",children:"2. Sensor Resolution"}),"\n",(0,s.jsx)(n.p,{children:"Reduce sensor resolution where possible:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- LIDAR: Reduce samples for better performance --\x3e\r\n<ray>\r\n  <scan>\r\n    <horizontal>\r\n      <samples>360</samples>  \x3c!-- Reduce from default 720 --\x3e\r\n      <resolution>1</resolution>\r\n      <min_angle>-1.570796</min_angle>  \x3c!-- Reduce FOV if possible --\x3e\r\n      <max_angle>1.570796</max_angle>\r\n    </horizontal>\r\n  </scan>\r\n</ray>\r\n\r\n\x3c!-- Camera: Reduce resolution --\x3e\r\n<camera name="head_camera">\r\n  <image>\r\n    <width>320</width>  \x3c!-- Reduce from 640 --\x3e\r\n    <height>240</height>  \x3c!-- Reduce from 480 --\x3e\r\n    <format>R8G8B8</format>\r\n  </image>\r\n</camera>\n'})}),"\n",(0,s.jsx)(n.h2,{id:"plugin-optimization",children:"Plugin Optimization"}),"\n",(0,s.jsx)(n.h3,{id:"1-efficient-controller-plugins",children:"1. Efficient Controller Plugins"}),"\n",(0,s.jsx)(n.p,{children:"Optimize controller update rates:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Diff drive controller: Balance update rate and performance --\x3e\r\n<plugin name="diff_drive" filename="libgazebo_ros_diff_drive.so">\r\n  <update_rate>30</update_rate>  \x3c!-- Match your target FPS --\x3e\r\n  \x3c!-- ... --\x3e\r\n</plugin>\r\n\r\n\x3c!-- Joint state publisher: Don\'t update too frequently --\x3e\r\n<plugin name="joint_state_publisher" filename="libgazebo_ros_joint_state_publisher.so">\r\n  <update_rate>30</update_rate>\r\n  \x3c!-- ... --\x3e\r\n</plugin>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"2-asynchronous-processing",children:"2. Asynchronous Processing"}),"\n",(0,s.jsx)(n.p,{children:"Where possible, implement asynchronous sensor processing:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Example: Processing-intensive sensor plugin --\x3e\r\n<gazebo>\r\n  <plugin name="complex_sensor" filename="libcomplex_sensor_plugin.so">\r\n    \x3c!-- Enable threading for intensive processing --\x3e\r\n    <threaded>true</threaded>\r\n    \x3c!-- Separate processing from physics update --\x3e\r\n    <update_rate>10</update_rate>\r\n  </plugin>\r\n</gazebo>\n'})}),"\n",(0,s.jsx)(n.h2,{id:"hardware-considerations",children:"Hardware Considerations"}),"\n",(0,s.jsx)(n.h3,{id:"cpu-optimization",children:"CPU Optimization"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Multi-threading"}),": Enable multi-threading where possible"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Core allocation"}),": Assign dedicated cores for physics simulation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"CPU affinity"}),": Bind simulation processes to specific cores"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Model caching"}),": Cache frequently used models"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Texture compression"}),": Use compressed textures"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Resource limits"}),": Set reasonable limits on dynamic allocations"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"gpu-acceleration",children:"GPU Acceleration"}),"\n",(0,s.jsx)(n.p,{children:"While physics is CPU-bound, GPU can help with:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Rendering optimization"}),"\n",(0,s.jsx)(n.li,{children:"Sensor simulation (camera, LIDAR raycasting)"}),"\n",(0,s.jsx)(n.li,{children:"Visualization"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"gazebo-specific-optimizations",children:"Gazebo-Specific Optimizations"}),"\n",(0,s.jsx)(n.h3,{id:"1-real-time-factor-configuration",children:"1. Real-Time Factor Configuration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'# Launch Gazebo with specific real-time factor\r\ngzserver --lockstep --threads 4 world_file.world\r\n\r\n# Or in launch files\r\n<param name="real_time_update_rate" value="1000"/>\r\n<param name="max_step_size" value="0.001"/>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"2-threading-configuration",children:"2. Threading Configuration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Enable multi-threading in physics engine --\x3e\r\n<physics name="multi_threaded" type="ode">\r\n  <ode>\r\n    <threaded_collision>true</threaded_collision>\r\n  </ode>\r\n</physics>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"3-scene-graph-optimization",children:"3. Scene Graph Optimization"}),"\n",(0,s.jsx)(n.p,{children:"Minimize complex scene graphs:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Reduce number of nested models"}),"\n",(0,s.jsx)(n.li,{children:"Combine static objects into single models when possible"}),"\n",(0,s.jsx)(n.li,{children:"Use instancing for repeated objects"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"performance-monitoring-tools",children:"Performance Monitoring Tools"}),"\n",(0,s.jsx)(n.h3,{id:"1-built-in-gazebo-tools",children:"1. Built-in Gazebo Tools"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Monitor simulation performance\r\ngz stats\r\n\r\n# Monitor specific topics\r\nros2 topic hz /clock\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-system-monitoring",children:"2. System Monitoring"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Monitor CPU usage\r\nhtop\r\n# Monitor memory usage\r\nfree -h\r\n# Monitor disk I/O if loading models from disk\r\niotop\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-custom-performance-scripts",children:"3. Custom Performance Scripts"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\"\"\"\r\nPerformance monitoring script for Gazebo simulation\r\n\"\"\"\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import Float32\r\nfrom rclpy.qos import qos_profile_sensor_data\r\nimport time\r\n\r\nclass PerformanceMonitor(Node):\r\n    def __init__(self):\r\n        super().__init__('performance_monitor')\r\n\r\n        # Publishers for performance metrics\r\n        self.rtf_publisher = self.create_publisher(Float32, '/gazebo/real_time_factor', 10)\r\n        self.fps_publisher = self.create_publisher(Float32, '/gazebo/fps', 10)\r\n\r\n        # Store timing information\r\n        self.last_time = self.get_clock().now()\r\n        self.frame_count = 0\r\n\r\n        # Timer for periodic updates\r\n        self.timer = self.create_timer(1.0, self.publish_performance_metrics)\r\n\r\n        self.get_logger().info('Performance monitor started')\r\n\r\n    def publish_performance_metrics(self):\r\n        # Calculate FPS and RTF\r\n        current_time = self.get_clock().now()\r\n        elapsed_time = (current_time.nanoseconds - self.last_time.nanoseconds) / 1e9\r\n        fps = Float32()\r\n        fps.data = float(self.frame_count) / elapsed_time if elapsed_time > 0 else 0.0\r\n\r\n        self.fps_publisher.publish(fps)\r\n\r\n        # Calculate RTF (simplified - in real application you'd get this from Gazebo)\r\n        rtf = Float32()\r\n        rtf.data = fps.data * 0.033  # Assuming 30ms per frame target\r\n        self.rtf_publisher.publish(rtf)\r\n\r\n        self.get_logger().info(f'FPS: {fps.data:.2f}, RTF: {rtf.data:.2f}')\r\n\r\n        # Reset for next calculation\r\n        self.last_time = current_time\r\n        self.frame_count = 0\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    monitor = PerformanceMonitor()\r\n\r\n    try:\r\n        rclpy.spin(monitor)\r\n    except KeyboardInterrupt:\r\n        monitor.get_logger().info('Performance monitor stopped by user')\r\n\r\n    monitor.destroy_node()\r\n    rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"common-performance-issues-and-solutions",children:"Common Performance Issues and Solutions"}),"\n",(0,s.jsx)(n.h3,{id:"issue-low-fps-under-30",children:"Issue: Low FPS (Under 30)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solutions"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Reduce ",(0,s.jsx)(n.code,{children:"max_step_size"})," to improve accuracy at the cost of performance"]}),"\n",(0,s.jsx)(n.li,{children:"Simplify collision geometries"}),"\n",(0,s.jsx)(n.li,{children:"Reduce sensor update rates"}),"\n",(0,s.jsx)(n.li,{children:"Use fewer complex models in the scene"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"issue-unstable-physics",children:"Issue: Unstable Physics"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solutions"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Decrease ",(0,s.jsx)(n.code,{children:"max_step_size"})," to improve stability"]}),"\n",(0,s.jsxs)(n.li,{children:["Increase ",(0,s.jsx)(n.code,{children:"iters"})," in the solver"]}),"\n",(0,s.jsxs)(n.li,{children:["Adjust ",(0,s.jsx)(n.code,{children:"erp"})," and ",(0,s.jsx)(n.code,{children:"cfm"})," values"]}),"\n",(0,s.jsx)(n.li,{children:"Reduce model complexity"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"issue-high-cpu-usage",children:"Issue: High CPU Usage"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solutions"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Increase ",(0,s.jsx)(n.code,{children:"max_step_size"})," (within stability limits)"]}),"\n",(0,s.jsx)(n.li,{children:"Reduce number of active joints/models"}),"\n",(0,s.jsx)(n.li,{children:"Use simpler collision geometries"}),"\n",(0,s.jsx)(n.li,{children:"Optimize plugin update rates"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"issue-jittery-movement",children:"Issue: Jittery Movement"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solutions"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Decrease ",(0,s.jsx)(n.code,{children:"max_step_size"})]}),"\n",(0,s.jsx)(n.li,{children:"Increase solver iterations"}),"\n",(0,s.jsx)(n.li,{children:"Check for high mass ratios in joints"}),"\n",(0,s.jsx)(n.li,{children:"Verify proper inertial properties"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"best-practices-summary",children:"Best Practices Summary"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Start Simple"}),": Begin with basic models and add complexity gradually"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Profile Regularly"}),": Monitor performance as you add elements"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Balance Accuracy and Performance"}),": Choose parameters based on your application needs"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use Appropriate Geometries"}),": Simple collision shapes with detailed visuals"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Optimize Update Rates"}),": Match sensor/controller rates to application requirements"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Test on Target Hardware"}),": Always validate performance on deployment hardware"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Document Trade-offs"}),": Keep track of performance vs. accuracy decisions"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"performance-validation-checklist",children:"Performance Validation Checklist"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Simulation runs at 30+ FPS consistently"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Real-time factor stays close to 1.0"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Physics behavior is stable and realistic"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Sensor data is accurate and timely"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Robot controllers respond appropriately"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","No excessive CPU/memory usage"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","All models behave as expected"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"Physics simulation optimization requires balancing accuracy, stability, and performance. The optimal configuration depends on your specific application requirements. Start with the default settings and adjust parameters based on your performance monitoring and application needs. Regular testing and profiling will help you achieve the best possible simulation performance for your use case."})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},7074:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>a});var r=i(6540);const s={},o=r.createContext(s);function l(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);