"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[7148],{739:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>s,contentTitle:()=>i,default:()=>p,frontMatter:()=>l,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"isaac-platform/path-execution-controller","title":"Path Execution Controller for Robot Movement","description":"Overview","source":"@site/docs/isaac-platform/path-execution-controller.md","sourceDirName":"isaac-platform","slug":"/isaac-platform/path-execution-controller","permalink":"/./docs/isaac-platform/path-execution-controller","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/isaac-platform/path-execution-controller.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Path Planning Algorithms Implementation","permalink":"/./docs/isaac-platform/path-planning-algorithms"},"next":{"title":"Perception Pipeline Integration with Navigation System","permalink":"/./docs/isaac-platform/perception-navigation-integration"}}');var o=n(4848),a=n(7074);const l={},i="Path Execution Controller for Robot Movement",s={},c=[{value:"Overview",id:"overview",level:2},{value:"Understanding Path Execution",id:"understanding-path-execution",level:2},{value:"What is Path Execution?",id:"what-is-path-execution",level:3},{value:"Key Components",id:"key-components",level:3},{value:"Navigation2 Controller Configuration",id:"navigation2-controller-configuration",level:2},{value:"1. Basic Controller Server Configuration",id:"1-basic-controller-server-configuration",level:3},{value:"2. Advanced Controller Configuration",id:"2-advanced-controller-configuration",level:3},{value:"Custom Path Execution Controller Implementation",id:"custom-path-execution-controller-implementation",level:2},{value:"1. Basic Pure Pursuit Controller",id:"1-basic-pure-pursuit-controller",level:3},{value:"2. Advanced Path Execution with Obstacle Avoidance",id:"2-advanced-path-execution-with-obstacle-avoidance",level:3},{value:"Path Execution Integration with Isaac ROS",id:"path-execution-integration-with-isaac-ros",level:2},{value:"1. Perception-Enhanced Path Execution",id:"1-perception-enhanced-path-execution",level:3},{value:"2. Visual-Inertial Path Execution",id:"2-visual-inertial-path-execution",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"1. Controller Performance Tuning",id:"1-controller-performance-tuning",level:3},{value:"2. Memory and Computation Optimization",id:"2-memory-and-computation-optimization",level:3},{value:"Path Execution Quality Metrics",id:"path-execution-quality-metrics",level:2},{value:"1. Path Following Performance Metrics",id:"1-path-following-performance-metrics",level:3},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:2},{value:"1. Path Following Problems",id:"1-path-following-problems",level:3},{value:"Issue: Robot oscillates around path",id:"issue-robot-oscillates-around-path",level:4},{value:"Issue: Robot stops frequently during path execution",id:"issue-robot-stops-frequently-during-path-execution",level:4},{value:"Issue: Robot cannot follow sharp turns",id:"issue-robot-cannot-follow-sharp-turns",level:4},{value:"2. Performance Issues",id:"2-performance-issues",level:3},{value:"Issue: High CPU usage during path execution",id:"issue-high-cpu-usage-during-path-execution",level:4},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Controller Selection Guidelines",id:"1-controller-selection-guidelines",level:3},{value:"2. Parameter Tuning Best Practices",id:"2-parameter-tuning-best-practices",level:3},{value:"3. Safety Considerations",id:"3-safety-considerations",level:3},{value:"Integration with Navigation System",id:"integration-with-navigation-system",level:2},{value:"1. Complete Navigation Configuration",id:"1-complete-navigation-configuration",level:3},{value:"Resources",id:"resources",level:2},{value:"Conclusion",id:"conclusion",level:2}];function _(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(r.header,{children:(0,o.jsx)(r.h1,{id:"path-execution-controller-for-robot-movement",children:"Path Execution Controller for Robot Movement"})}),"\n",(0,o.jsx)(r.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(r.p,{children:"This guide provides comprehensive instructions for implementing path execution controllers that translate planned paths into actual robot movement. The path execution controller is a critical component of the navigation stack that follows global plans while avoiding local obstacles and maintaining safe motion."}),"\n",(0,o.jsx)(r.h2,{id:"understanding-path-execution",children:"Understanding Path Execution"}),"\n",(0,o.jsx)(r.h3,{id:"what-is-path-execution",children:"What is Path Execution?"}),"\n",(0,o.jsx)(r.p,{children:"Path execution is the process of converting a planned path (sequence of waypoints) into velocity commands that drive the robot along the path while avoiding obstacles and maintaining stability."}),"\n",(0,o.jsx)(r.h3,{id:"key-components",children:"Key Components"}),"\n",(0,o.jsxs)(r.ol,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Local Planner"}),": Generates velocity commands based on global path and local obstacles"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Trajectory Controller"}),": Smooths and executes motion commands"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Safety Controller"}),": Ensures safe operation and obstacle avoidance"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Feedback Controller"}),": Adjusts based on actual robot state"]}),"\n"]}),"\n",(0,o.jsx)(r.h2,{id:"navigation2-controller-configuration",children:"Navigation2 Controller Configuration"}),"\n",(0,o.jsx)(r.h3,{id:"1-basic-controller-server-configuration",children:"1. Basic Controller Server Configuration"}),"\n",(0,o.jsxs)(r.p,{children:["Create a controller configuration file ",(0,o.jsx)(r.code,{children:"controller_config.yaml"}),":"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-yaml",children:'controller_server:\r\n  ros__parameters:\r\n    use_sim_time: false\r\n    controller_frequency: 20.0\r\n    min_x_velocity_threshold: 0.001\r\n    min_y_velocity_threshold: 0.5\r\n    min_theta_velocity_threshold: 0.001\r\n    failure_tolerance: 0.3\r\n    progress_checker_plugin: "progress_checker"\r\n    goal_checker_plugins: ["general_goal_checker"]\r\n    controller_plugins: ["FollowPath"]\r\n\r\n    # Progress checker parameters\r\n    progress_checker:\r\n      plugin: "nav2_controller::SimpleProgressChecker"\r\n      required_movement_radius: 0.5\r\n      movement_time_allowance: 10.0\r\n\r\n    # Goal checker parameters\r\n    general_goal_checker:\r\n      plugin: "nav2_controller::SimpleGoalChecker"\r\n      xy_goal_tolerance: 0.25\r\n      yaw_goal_tolerance: 0.25\r\n      stateful: True\r\n\r\n    # Controller parameters\r\n    FollowPath:\r\n      plugin: "dwb_core::DWBLocalPlanner"\r\n      debug_trajectory_details: True\r\n      min_vel_x: 0.0\r\n      min_vel_y: 0.0\r\n      max_vel_x: 0.5\r\n      max_vel_y: 0.0\r\n      max_vel_theta: 1.0\r\n      min_speed_xy: 0.0\r\n      max_speed_xy: 0.5\r\n      min_speed_theta: 0.0\r\n      acc_lim_x: 2.5\r\n      acc_lim_y: 0.0\r\n      acc_lim_theta: 3.2\r\n      decel_lim_x: -2.5\r\n      decel_lim_y: 0.0\r\n      decel_lim_theta: -3.2\r\n      vx_samples: 20\r\n      vy_samples: 5\r\n      vtheta_samples: 20\r\n      sim_time: 1.7\r\n      linear_granularity: 0.05\r\n      angular_granularity: 0.025\r\n      transform_tolerance: 0.2\r\n      xy_goal_tolerance: 0.25\r\n      yaw_goal_tolerance: 0.25\r\n      stateful: True\r\n      restore_defaults: False\r\n      publish_cost_grid_pc: False\r\n      use_dwb: True\r\n      max_vel_obstacle: 1.32\n'})}),"\n",(0,o.jsx)(r.h3,{id:"2-advanced-controller-configuration",children:"2. Advanced Controller Configuration"}),"\n",(0,o.jsx)(r.p,{children:"For more sophisticated path execution:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-yaml",children:'controller_server:\r\n  ros__parameters:\r\n    use_sim_time: false\r\n    controller_frequency: 50.0  # Higher frequency for better control\r\n    min_x_velocity_threshold: 0.001\r\n    min_y_velocity_threshold: 0.001\r\n    min_theta_velocity_threshold: 0.001\r\n    failure_tolerance: 0.5\r\n    progress_checker_plugin: "progress_checker"\r\n    goal_checker_plugins: ["general_goal_checker", "precise_goal_checker"]\r\n    controller_plugins: ["FollowPath", "BackupController"]\r\n\r\n    # Enhanced progress checker\r\n    progress_checker:\r\n      plugin: "nav2_controller::SimpleProgressChecker"\r\n      required_movement_radius: 0.25  # Smaller for more sensitive checking\r\n      movement_time_allowance: 5.0    # Shorter timeout\r\n\r\n    # Multiple goal checkers for different scenarios\r\n    general_goal_checker:\r\n      plugin: "nav2_controller::SimpleGoalChecker"\r\n      xy_goal_tolerance: 0.25\r\n      yaw_goal_tolerance: 0.25\r\n      stateful: True\r\n\r\n    precise_goal_checker:\r\n      plugin: "nav2_controller::SimpleGoalChecker"\r\n      xy_goal_tolerance: 0.10  # Tighter tolerance for precision\r\n      yaw_goal_tolerance: 0.10\r\n      stateful: True\r\n\r\n    # Main path following controller\r\n    FollowPath:\r\n      plugin: "dwb_core::DWBLocalPlanner"\r\n      debug_trajectory_details: False\r\n      min_vel_x: 0.05          # Minimum forward speed to prevent stalling\r\n      min_vel_y: 0.0\r\n      max_vel_x: 0.8           # Higher speed for efficiency\r\n      max_vel_y: 0.0\r\n      max_vel_theta: 2.0       # Higher angular speed for better turning\r\n      min_speed_xy: 0.05\r\n      max_speed_xy: 0.8\r\n      min_speed_theta: 0.1\r\n      acc_lim_x: 3.0           # Higher acceleration for better responsiveness\r\n      acc_lim_y: 0.0\r\n      acc_lim_theta: 4.0       # Higher angular acceleration\r\n      decel_lim_x: -3.0\r\n      decel_lim_y: 0.0\r\n      decel_lim_theta: -4.0\r\n      vx_samples: 40           # More samples for better optimization\r\n      vy_samples: 5\r\n      vtheta_samples: 40\r\n      sim_time: 2.0            # Longer simulation horizon\r\n      linear_granularity: 0.025  # Finer granularity\r\n      angular_granularity: 0.01\r\n      transform_tolerance: 0.1\r\n      xy_goal_tolerance: 0.25\r\n      yaw_goal_tolerance: 0.25\r\n      stateful: True\r\n      restore_defaults: False\r\n      publish_cost_grid_pc: True  # Enable for debugging\r\n      use_dwb: True\r\n      max_vel_obstacle: 2.0\r\n\r\n    # Backup controller for emergency situations\r\n    BackupController:\r\n      plugin: "nav2_controller::BackUpController"\r\n      min_vel_x: -0.2\r\n      max_vel_x: -0.1\r\n      acc_lim_x: 1.0\r\n      decel_lim_x: -1.0\r\n      sim_time: 1.0\r\n      vx_samples: 10\r\n      tolerance: 0.1\r\n      threshold_to_rotate: 0.2\n'})}),"\n",(0,o.jsx)(r.h2,{id:"custom-path-execution-controller-implementation",children:"Custom Path Execution Controller Implementation"}),"\n",(0,o.jsx)(r.h3,{id:"1-basic-pure-pursuit-controller",children:"1. Basic Pure Pursuit Controller"}),"\n",(0,o.jsxs)(r.p,{children:["Create a custom pure pursuit path follower ",(0,o.jsx)(r.code,{children:"pure_pursuit_controller.py"}),":"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n"""\r\nCustom Pure Pursuit Path Execution Controller\r\n"""\r\nimport math\r\nfrom typing import List, Tuple\r\nimport numpy as np\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import Twist, PoseStamped, Point\r\nfrom nav_msgs.msg import Path\r\nfrom sensor_msgs.msg import LaserScan\r\nfrom tf2_ros import TransformException\r\nfrom tf2_ros.buffer import Buffer\r\nfrom tf2_ros.transform_listener import TransformListener\r\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy\r\nimport time\r\n\r\n\r\nclass PurePursuitController(Node):\r\n    def __init__(self):\r\n        super().__init__(\'pure_pursuit_controller\')\r\n\r\n        # Parameters\r\n        self.declare_parameter(\'lookahead_distance\', 0.6)\r\n        self.declare_parameter(\'max_linear_velocity\', 0.5)\r\n        self.declare_parameter(\'max_angular_velocity\', 1.0)\r\n        self.declare_parameter(\'min_linear_velocity\', 0.1)\r\n        self.declare_parameter(\'control_frequency\', 20.0)\r\n\r\n        self.lookahead_distance = self.get_parameter(\'lookahead_distance\').value\r\n        self.max_linear_vel = self.get_parameter(\'max_linear_velocity\').value\r\n        self.max_angular_vel = self.get_parameter(\'max_angular_velocity\').value\r\n        self.min_linear_vel = self.get_parameter(\'min_linear_velocity\').value\r\n        self.control_freq = self.get_parameter(\'control_frequency\').value\r\n\r\n        # Current path and state\r\n        self.current_path = []\r\n        self.current_path_index = 0\r\n        self.robot_pose = None\r\n        self.path_received = False\r\n\r\n        # TF buffer for pose transformation\r\n        self.tf_buffer = Buffer()\r\n        self.tf_listener = TransformListener(self.tf_buffer, self)\r\n\r\n        # Publishers and subscribers\r\n        qos_profile = QoSProfile(\r\n            reliability=ReliabilityPolicy.RELIABLE,\r\n            history=HistoryPolicy.KEEP_LAST,\r\n            depth=1\r\n        )\r\n\r\n        self.cmd_vel_pub = self.create_publisher(Twist, \'cmd_vel\', 1)\r\n        self.path_sub = self.create_subscription(\r\n            Path, \'global_plan\', self.path_callback, qos_profile)\r\n        self.laser_sub = self.create_subscription(\r\n            LaserScan, \'scan\', self.laser_callback, qos_profile)\r\n\r\n        # Timer for control loop\r\n        self.control_timer = self.create_timer(1.0/self.control_freq, self.control_loop)\r\n\r\n        # Safety variables\r\n        self.obstacle_detected = False\r\n        self.obstacle_distance = float(\'inf\')\r\n\r\n        self.get_logger().info(\'Pure Pursuit Controller initialized\')\r\n\r\n    def path_callback(self, msg):\r\n        """Callback for receiving path to follow"""\r\n        self.current_path = msg.poses\r\n        self.current_path_index = 0\r\n        self.path_received = True\r\n        self.get_logger().info(f\'Received path with {len(self.current_path)} waypoints\')\r\n\r\n    def laser_callback(self, msg):\r\n        """Callback for laser scan to detect obstacles"""\r\n        # Simple obstacle detection - check minimum range in front\r\n        front_ranges = msg.ranges[len(msg.ranges)//2-30:len(msg.ranges)//2+30]\r\n        valid_ranges = [r for r in front_ranges if not (math.isnan(r) or math.isinf(r))]\r\n\r\n        if valid_ranges:\r\n            self.obstacle_distance = min(valid_ranges)\r\n            self.obstacle_detected = self.obstacle_distance < 0.8  # 0.8m threshold\r\n        else:\r\n            self.obstacle_distance = float(\'inf\')\r\n            self.obstacle_detected = False\r\n\r\n    def get_robot_pose(self):\r\n        """Get current robot pose using TF"""\r\n        try:\r\n            transform = self.tf_buffer.lookup_transform(\r\n                \'map\', \'base_link\', rclpy.time.Time())\r\n\r\n            pose = PoseStamped()\r\n            pose.pose.position.x = transform.transform.translation.x\r\n            pose.pose.position.y = transform.transform.translation.y\r\n            pose.pose.orientation = transform.transform.rotation\r\n\r\n            return pose.pose\r\n        except TransformException as ex:\r\n            self.get_logger().warn(f\'Could not transform: {ex}\')\r\n            return None\r\n\r\n    def find_lookahead_point(self):\r\n        """Find the lookahead point on the path"""\r\n        if not self.current_path or self.current_path_index >= len(self.current_path):\r\n            return None\r\n\r\n        robot_pose = self.get_robot_pose()\r\n        if not robot_pose:\r\n            return None\r\n\r\n        robot_x = robot_pose.position.x\r\n        robot_y = robot_pose.position.y\r\n\r\n        # Find the closest point on the path\r\n        closest_idx = self.current_path_index\r\n        min_dist = float(\'inf\')\r\n\r\n        for i in range(self.current_path_index, len(self.current_path)):\r\n            path_x = self.current_path[i].pose.position.x\r\n            path_y = self.current_path[i].pose.position.y\r\n            dist = math.sqrt((robot_x - path_x)**2 + (robot_y - path_y)**2)\r\n\r\n            if dist < min_dist:\r\n                min_dist = dist\r\n                closest_idx = i\r\n\r\n        # Find the lookahead point beyond the closest point\r\n        for i in range(closest_idx, len(self.current_path)):\r\n            path_x = self.current_path[i].pose.position.x\r\n            path_y = self.current_path[i].pose.position.y\r\n            dist = math.sqrt((robot_x - path_x)**2 + (robot_y - path_y)**2)\r\n\r\n            if dist >= self.lookahead_distance:\r\n                self.current_path_index = i\r\n                return (path_x, path_y)\r\n\r\n        # If no point is far enough, return the last point\r\n        if self.current_path:\r\n            last_point = self.current_path[-1]\r\n            return (last_point.pose.position.x, last_point.pose.position.y)\r\n\r\n        return None\r\n\r\n    def calculate_control(self, lookahead_point):\r\n        """Calculate linear and angular velocities using pure pursuit"""\r\n        robot_pose = self.get_robot_pose()\r\n        if not robot_pose or not lookahead_point:\r\n            return 0.0, 0.0\r\n\r\n        robot_x = robot_pose.position.x\r\n        robot_y = robot_pose.position.y\r\n        robot_yaw = self.quaternion_to_yaw(robot_pose.orientation)\r\n\r\n        lookahead_x, lookahead_y = lookahead_point\r\n\r\n        # Calculate distance to lookahead point\r\n        dist_to_lookahead = math.sqrt(\r\n            (lookahead_x - robot_x)**2 + (lookahead_y - robot_y)**2)\r\n\r\n        # Calculate angle to lookahead point\r\n        angle_to_lookahead = math.atan2(lookahead_y - robot_y, lookahead_x - robot_x)\r\n        angle_diff = self.normalize_angle(angle_to_lookahead - robot_yaw)\r\n\r\n        # Pure pursuit formula\r\n        curvature = 2 * math.sin(angle_diff) / dist_to_lookahead\r\n\r\n        # Calculate velocities\r\n        linear_vel = min(self.max_linear_vel, self.max_linear_vel * math.cos(angle_diff))\r\n        angular_vel = linear_vel * curvature\r\n\r\n        # Limit angular velocity\r\n        angular_vel = max(-self.max_angular_vel, min(self.max_angular_vel, angular_vel))\r\n\r\n        return linear_vel, angular_vel\r\n\r\n    def quaternion_to_yaw(self, quaternion):\r\n        """Convert quaternion to yaw angle"""\r\n        siny_cosp = 2 * (quaternion.w * quaternion.z + quaternion.x * quaternion.y)\r\n        cosy_cosp = 1 - 2 * (quaternion.y * quaternion.y + quaternion.z * quaternion.z)\r\n        return math.atan2(siny_cosp, cosy_cosp)\r\n\r\n    def normalize_angle(self, angle):\r\n        """Normalize angle to [-pi, pi]"""\r\n        while angle > math.pi:\r\n            angle -= 2 * math.pi\r\n        while angle < -math.pi:\r\n            angle += 2 * math.pi\r\n        return angle\r\n\r\n    def control_loop(self):\r\n        """Main control loop"""\r\n        if not self.path_received or not self.current_path:\r\n            return\r\n\r\n        # Check if path is completed\r\n        if self.current_path_index >= len(self.current_path) - 1:\r\n            self.stop_robot()\r\n            self.get_logger().info(\'Path execution completed\')\r\n            return\r\n\r\n        # Check for obstacles\r\n        if self.obstacle_detected:\r\n            self.get_logger().warn(f\'Obstacle detected at {self.obstacle_distance:.2f}m, stopping\')\r\n            self.stop_robot()\r\n            return\r\n\r\n        # Find lookahead point\r\n        lookahead_point = self.find_lookahead_point()\r\n        if not lookahead_point:\r\n            self.stop_robot()\r\n            return\r\n\r\n        # Calculate control commands\r\n        linear_vel, angular_vel = self.calculate_control(lookahead_point)\r\n\r\n        # Apply safety limits\r\n        linear_vel = max(self.min_linear_vel, min(self.max_linear_vel, linear_vel))\r\n\r\n        # Create and publish velocity command\r\n        cmd_vel = Twist()\r\n        cmd_vel.linear.x = linear_vel\r\n        cmd_vel.angular.z = angular_vel\r\n\r\n        self.cmd_vel_pub.publish(cmd_vel)\r\n\r\n        # Log control information\r\n        self.get_logger().debug(\r\n            f\'Linear: {linear_vel:.3f}, Angular: {angular_vel:.3f}, \'\r\n            f\'Lookahead: ({lookahead_point[0]:.2f}, {lookahead_point[1]:.2f})\')\r\n\r\n    def stop_robot(self):\r\n        """Stop the robot"""\r\n        cmd_vel = Twist()\r\n        cmd_vel.linear.x = 0.0\r\n        cmd_vel.angular.z = 0.0\r\n        self.cmd_vel_pub.publish(cmd_vel)\r\n\r\n    def is_path_complete(self):\r\n        """Check if path execution is complete"""\r\n        if not self.current_path or self.current_path_index >= len(self.current_path):\r\n            return True\r\n\r\n        robot_pose = self.get_robot_pose()\r\n        if not robot_pose:\r\n            return False\r\n\r\n        last_waypoint = self.current_path[-1]\r\n        dist_to_goal = math.sqrt(\r\n            (robot_pose.position.x - last_waypoint.pose.position.x)**2 +\r\n            (robot_pose.position.y - last_waypoint.pose.position.y)**2)\r\n\r\n        return dist_to_goal < 0.25  # 25cm tolerance\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    controller = PurePursuitController()\r\n\r\n    try:\r\n        rclpy.spin(controller)\r\n    except KeyboardInterrupt:\r\n        controller.get_logger().info(\'Pure pursuit controller stopped by user\')\r\n    finally:\r\n        controller.stop_robot()\r\n        controller.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,o.jsx)(r.h3,{id:"2-advanced-path-execution-with-obstacle-avoidance",children:"2. Advanced Path Execution with Obstacle Avoidance"}),"\n",(0,o.jsxs)(r.p,{children:["Create a more sophisticated path execution controller ",(0,o.jsx)(r.code,{children:"advanced_path_controller.py"}),":"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n"""\r\nAdvanced Path Execution Controller with Obstacle Avoidance\r\n"""\r\nimport math\r\nimport numpy as np\r\nfrom typing import List, Tuple\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import Twist, PoseStamped, Point\r\nfrom nav_msgs.msg import Path, OccupancyGrid\r\nfrom sensor_msgs.msg import LaserScan\r\nfrom tf2_ros import TransformException\r\nfrom tf2_ros.buffer import Buffer\r\nfrom tf2_ros.transform_listener import TransformListener\r\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy\r\nfrom std_msgs.msg import Float32\r\nimport time\r\n\r\n\r\nclass AdvancedPathController(Node):\r\n    def __init__(self):\r\n        super().__init__(\'advanced_path_controller\')\r\n\r\n        # Parameters\r\n        self.declare_parameter(\'lookahead_distance\', 0.8)\r\n        self.declare_parameter(\'max_linear_velocity\', 0.6)\r\n        self.declare_parameter(\'max_angular_velocity\', 1.5)\r\n        self.declare_parameter(\'min_linear_velocity\', 0.05)\r\n        self.declare_parameter(\'control_frequency\', 30.0)\r\n        self.declare_parameter(\'obstacle_threshold\', 0.8)\r\n        self.declare_parameter(\'inflation_radius\', 0.3)\r\n        self.declare_parameter(\'path_smoothing\', True)\r\n\r\n        self.lookahead_distance = self.get_parameter(\'lookahead_distance\').value\r\n        self.max_linear_vel = self.get_parameter(\'max_linear_velocity\').value\r\n        self.max_angular_vel = self.get_parameter(\'max_angular_velocity\').value\r\n        self.min_linear_vel = self.get_parameter(\'min_linear_velocity\').value\r\n        self.control_freq = self.get_parameter(\'control_frequency\').value\r\n        self.obstacle_threshold = self.get_parameter(\'obstacle_threshold\').value\r\n        self.inflation_radius = self.get_parameter(\'inflation_radius\').value\r\n        self.path_smoothing = self.get_parameter(\'path_smoothing\').value\r\n\r\n        # Current state\r\n        self.current_path = []\r\n        self.smoothed_path = []\r\n        self.current_path_index = 0\r\n        self.path_received = False\r\n\r\n        # Robot state\r\n        self.robot_pose = None\r\n        self.robot_velocity = 0.0\r\n        self.robot_angular_velocity = 0.0\r\n\r\n        # TF buffer\r\n        self.tf_buffer = Buffer()\r\n        self.tf_listener = TransformListener(self.tf_buffer, self)\r\n\r\n        # Publishers and subscribers\r\n        qos_profile = QoSProfile(\r\n            reliability=ReliabilityPolicy.RELIABLE,\r\n            history=HistoryPolicy.KEEP_LAST,\r\n            depth=1\r\n        )\r\n\r\n        self.cmd_vel_pub = self.create_publisher(Twist, \'cmd_vel\', 1)\r\n        self.path_sub = self.create_subscription(\r\n            Path, \'global_plan\', self.path_callback, qos_profile)\r\n        self.laser_sub = self.create_subscription(\r\n            LaserScan, \'scan\', self.laser_callback, qos_profile)\r\n        self.odom_sub = self.create_subscription(\r\n            Path, \'odom\', self.odom_callback, qos_profile)  # Simplified - in real implementation use proper odometry\r\n\r\n        # Timer for control loop\r\n        self.control_timer = self.create_timer(1.0/self.control_freq, self.control_loop)\r\n\r\n        # Safety and obstacle avoidance\r\n        self.obstacle_detected = False\r\n        self.obstacle_distance = float(\'inf\')\r\n        self.local_path = []  # Local path with obstacle avoidance\r\n        self.recovery_mode = False\r\n        self.recovery_start_time = 0\r\n\r\n        # Performance monitoring\r\n        self.last_cmd_time = time.time()\r\n        self.velocity_publisher = self.create_publisher(Float32, \'current_velocity\', 1)\r\n\r\n        self.get_logger().info(\'Advanced Path Controller initialized\')\r\n\r\n    def path_callback(self, msg):\r\n        """Callback for receiving path to follow"""\r\n        self.current_path = msg.poses\r\n        self.current_path_index = 0\r\n\r\n        # Smooth the path if enabled\r\n        if self.path_smoothing:\r\n            self.smoothed_path = self.smooth_path(self.current_path)\r\n        else:\r\n            self.smoothed_path = self.current_path\r\n\r\n        self.path_received = True\r\n        self.recovery_mode = False\r\n        self.get_logger().info(f\'Received path with {len(self.current_path)} waypoints\')\r\n\r\n    def laser_callback(self, msg):\r\n        """Callback for laser scan to detect obstacles and create local path"""\r\n        # Process laser scan for obstacle detection\r\n        self.process_laser_scan(msg)\r\n\r\n        # Create local path considering obstacles\r\n        if self.path_received and self.current_path:\r\n            self.local_path = self.create_local_path_with_obstacles(msg)\r\n\r\n    def process_laser_scan(self, scan_msg):\r\n        """Process laser scan to detect obstacles"""\r\n        # Check for obstacles in front of robot\r\n        front_ranges = scan_msg.ranges[len(scan_msg.ranges)//2-45:len(scan_msg.ranges)//2+45]\r\n        valid_ranges = [r for r in front_ranges if not (math.isnan(r) or math.isinf(r) or r > 10.0)]\r\n\r\n        if valid_ranges:\r\n            self.obstacle_distance = min(valid_ranges)\r\n            self.obstacle_detected = self.obstacle_distance < self.obstacle_threshold\r\n        else:\r\n            self.obstacle_distance = float(\'inf\')\r\n            self.obstacle_detected = False\r\n\r\n    def create_local_path_with_obstacles(self, scan_msg):\r\n        """Create a local path that avoids detected obstacles"""\r\n        if not self.current_path or self.current_path_index >= len(self.current_path):\r\n            return []\r\n\r\n        robot_pose = self.get_robot_pose()\r\n        if not robot_pose:\r\n            return []\r\n\r\n        # Get the next few waypoints from global path\r\n        local_waypoints = []\r\n        start_idx = min(self.current_path_index, len(self.current_path) - 1)\r\n\r\n        for i in range(start_idx, min(start_idx + 10, len(self.current_path))):\r\n            local_waypoints.append(self.current_path[i])\r\n\r\n        # If obstacles detected, modify local path to avoid them\r\n        if self.obstacle_detected:\r\n            local_waypoints = self.avoid_obstacles_in_local_path(local_waypoints, scan_msg, robot_pose)\r\n\r\n        return local_waypoints\r\n\r\n    def avoid_obstacles_in_local_path(self, local_waypoints, scan_msg, robot_pose):\r\n        """Modify local path to avoid obstacles"""\r\n        if not local_waypoints:\r\n            return []\r\n\r\n        # Simple obstacle avoidance: find alternative points that avoid obstacles\r\n        adjusted_waypoints = []\r\n\r\n        for waypoint in local_waypoints:\r\n            waypoint_x = waypoint.pose.position.x\r\n            waypoint_y = waypoint.pose.position.y\r\n\r\n            # Calculate range and bearing to waypoint\r\n            dx = waypoint_x - robot_pose.position.x\r\n            dy = waypoint_y - robot_pose.position.y\r\n            distance_to_waypoint = math.sqrt(dx*dx + dy*dy)\r\n\r\n            if distance_to_waypoint > 0:\r\n                # Check if path to waypoint is clear\r\n                angle_to_waypoint = math.atan2(dy, dx)\r\n\r\n                # Check laser ranges in the direction of the waypoint\r\n                angle_idx = int((angle_to_waypoint + math.pi) * len(scan_msg.ranges) / (2 * math.pi))\r\n                angle_idx = max(0, min(len(scan_msg.ranges) - 1, angle_idx))\r\n\r\n                if scan_msg.ranges[angle_idx] < self.obstacle_threshold:\r\n                    # Obstacle detected in path, try to find alternative\r\n                    adjusted_waypoint = self.find_alternative_waypoint(\r\n                        waypoint, robot_pose, scan_msg)\r\n                    adjusted_waypoints.append(adjusted_waypoint)\r\n                else:\r\n                    adjusted_waypoints.append(waypoint)\r\n            else:\r\n                adjusted_waypoints.append(waypoint)\r\n\r\n        return adjusted_waypoints\r\n\r\n    def find_alternative_waypoint(self, original_waypoint, robot_pose, scan_msg):\r\n        """Find an alternative waypoint that avoids obstacles"""\r\n        # Create a new waypoint slightly offset from the original\r\n        original_x = original_waypoint.pose.position.x\r\n        original_y = original_waypoint.pose.position.y\r\n\r\n        robot_x = robot_pose.position.x\r\n        robot_y = robot_pose.position.y\r\n\r\n        # Calculate direction from robot to original waypoint\r\n        dx = original_x - robot_x\r\n        dy = original_y - robot_y\r\n        distance = math.sqrt(dx*dx + dy*dy)\r\n\r\n        if distance > 0:\r\n            # Create offset perpendicular to the path\r\n            perp_dx = -dy / distance  # Perpendicular direction\r\n            perp_dy = dx / distance\r\n\r\n            # Try offset to the left first\r\n            offset_x = original_x + perp_dx * 0.3  # 30cm offset\r\n            offset_y = original_y + perp_dy * 0.3\r\n\r\n            # Check if this offset is clear of obstacles\r\n            if self.is_path_clear(robot_x, robot_y, offset_x, offset_y, scan_msg):\r\n                new_waypoint = PoseStamped()\r\n                new_waypoint.pose.position.x = offset_x\r\n                new_waypoint.pose.position.y = offset_y\r\n                new_waypoint.pose.orientation = original_waypoint.pose.orientation\r\n                return new_waypoint\r\n\r\n        # If offset doesn\'t work, return original (controller will handle)\r\n        return original_waypoint\r\n\r\n    def is_path_clear(self, start_x, start_y, end_x, end_y, scan_msg):\r\n        """Check if path between two points is clear of obstacles"""\r\n        # Simplified check - in practice, use ray tracing through laser data\r\n        distance = math.sqrt((end_x - start_x)**2 + (end_y - start_y)**2)\r\n\r\n        # Sample points along the path\r\n        steps = max(1, int(distance / 0.1))  # Check every 10cm\r\n        for i in range(steps + 1):\r\n            t = i / steps\r\n            check_x = start_x + t * (end_x - start_x)\r\n            check_y = start_y + t * (end_y - start_y)\r\n\r\n            # Convert to laser frame and check if clear\r\n            # This is a simplified check - full implementation would require\r\n            # transforming to laser frame and checking scan ranges\r\n            pass\r\n\r\n        return True  # Simplified - return true for now\r\n\r\n    def get_robot_pose(self):\r\n        """Get current robot pose using TF"""\r\n        try:\r\n            transform = self.tf_buffer.lookup_transform(\r\n                \'map\', \'base_link\', rclpy.time.Time())\r\n\r\n            pose = PoseStamped()\r\n            pose.pose.position.x = transform.transform.translation.x\r\n            pose.pose.position.y = transform.transform.translation.y\r\n            pose.pose.orientation = transform.transform.rotation\r\n\r\n            return pose.pose\r\n        except TransformException as ex:\r\n            self.get_logger().debug(f\'Transform lookup failed: {ex}\')\r\n            return None\r\n\r\n    def smooth_path(self, path):\r\n        """Apply path smoothing using a simple averaging filter"""\r\n        if len(path) < 3:\r\n            return path\r\n\r\n        smoothed_path = []\r\n        path_array = [(p.pose.position.x, p.pose.position.y) for p in path]\r\n\r\n        for i in range(len(path_array)):\r\n            if i == 0 or i == len(path_array) - 1:\r\n                # Keep start and end points\r\n                smoothed_path.append(path[i])\r\n            else:\r\n                # Average with neighbors\r\n                prev_x, prev_y = path_array[i-1]\r\n                curr_x, curr_y = path_array[i]\r\n                next_x, next_y = path_array[i+1]\r\n\r\n                smooth_x = (prev_x + curr_x + next_x) / 3\r\n                smooth_y = (prev_y + curr_y + next_y) / 3\r\n\r\n                new_pose = PoseStamped()\r\n                new_pose.pose.position.x = smooth_x\r\n                new_pose.pose.position.y = smooth_y\r\n                new_pose.pose.orientation = path[i].pose.orientation\r\n                smoothed_path.append(new_pose)\r\n\r\n        return smoothed_path\r\n\r\n    def find_lookahead_point(self):\r\n        """Find the lookahead point on the local path"""\r\n        if not self.local_path and not self.smoothed_path:\r\n            return None\r\n\r\n        path_to_use = self.local_path if self.local_path else self.smoothed_path\r\n        current_idx = 0\r\n\r\n        robot_pose = self.get_robot_pose()\r\n        if not robot_pose:\r\n            return None\r\n\r\n        robot_x = robot_pose.position.x\r\n        robot_y = robot_pose.position.y\r\n\r\n        # Find the closest point on the path\r\n        closest_idx = 0\r\n        min_dist = float(\'inf\')\r\n\r\n        for i in range(len(path_to_use)):\r\n            path_x = path_to_use[i].pose.position.x\r\n            path_y = path_to_use[i].pose.position.y\r\n            dist = math.sqrt((robot_x - path_x)**2 + (robot_y - path_y)**2)\r\n\r\n            if dist < min_dist:\r\n                min_dist = dist\r\n                closest_idx = i\r\n\r\n        # Find the lookahead point beyond the closest point\r\n        for i in range(closest_idx, len(path_to_use)):\r\n            path_x = path_to_use[i].pose.position.x\r\n            path_y = path_to_use[i].pose.position.y\r\n            dist = math.sqrt((robot_x - path_x)**2 + (robot_y - path_y)**2)\r\n\r\n            if dist >= self.lookahead_distance:\r\n                self.current_path_index = i\r\n                return (path_x, path_y)\r\n\r\n        # If no point is far enough, return the last point\r\n        if path_to_use:\r\n            last_point = path_to_use[-1]\r\n            return (last_point.pose.position.x, last_point.pose.position.y)\r\n\r\n        return None\r\n\r\n    def calculate_control(self, lookahead_point):\r\n        """Calculate linear and angular velocities"""\r\n        robot_pose = self.get_robot_pose()\r\n        if not robot_pose or not lookahead_point:\r\n            return 0.0, 0.0\r\n\r\n        robot_x = robot_pose.position.x\r\n        robot_y = robot_pose.position.y\r\n        robot_yaw = self.quaternion_to_yaw(robot_pose.orientation)\r\n\r\n        lookahead_x, lookahead_y = lookahead_point\r\n\r\n        # Calculate distance to lookahead point\r\n        dist_to_lookahead = math.sqrt(\r\n            (lookahead_x - robot_x)**2 + (lookahead_y - robot_y)**2)\r\n\r\n        # Calculate angle to lookahead point\r\n        angle_to_lookahead = math.atan2(lookahead_y - robot_y, lookahead_x - robot_x)\r\n        angle_diff = self.normalize_angle(angle_to_lookahead - robot_yaw)\r\n\r\n        # Pure pursuit with velocity scaling\r\n        curvature = 2 * math.sin(angle_diff) / dist_to_lookahead if dist_to_lookahead > 0.01 else 0.0\r\n\r\n        # Calculate velocities with obstacle awareness\r\n        base_linear_vel = min(self.max_linear_vel, self.max_linear_vel * math.cos(angle_diff))\r\n\r\n        # Reduce speed when close to obstacles\r\n        speed_factor = min(1.0, self.obstacle_distance / self.obstacle_threshold)\r\n        linear_vel = base_linear_vel * speed_factor if self.obstacle_detected else base_linear_vel\r\n\r\n        # Ensure minimum speed to prevent stalling\r\n        linear_vel = max(self.min_linear_vel, linear_vel) if linear_vel > 0 else linear_vel\r\n\r\n        angular_vel = linear_vel * curvature\r\n\r\n        # Limit angular velocity\r\n        angular_vel = max(-self.max_angular_vel, min(self.max_angular_vel, angular_vel))\r\n\r\n        return linear_vel, angular_vel\r\n\r\n    def quaternion_to_yaw(self, quaternion):\r\n        """Convert quaternion to yaw angle"""\r\n        siny_cosp = 2 * (quaternion.w * quaternion.z + quaternion.x * quaternion.y)\r\n        cosy_cosp = 1 - 2 * (quaternion.y * quaternion.y + quaternion.z * quaternion.z)\r\n        return math.atan2(siny_cosp, cosy_cosp)\r\n\r\n    def normalize_angle(self, angle):\r\n        """Normalize angle to [-pi, pi]"""\r\n        while angle > math.pi:\r\n            angle -= 2 * math.pi\r\n        while angle < -math.pi:\r\n            angle += 2 * math.pi\r\n        return angle\r\n\r\n    def control_loop(self):\r\n        """Main control loop"""\r\n        if not self.path_received:\r\n            self.stop_robot()\r\n            return\r\n\r\n        # Check if path is completed\r\n        if (self.current_path_index >= len(self.current_path) - 1 and\r\n            len(self.current_path) > 0):\r\n            self.stop_robot()\r\n            self.get_logger().info(\'Path execution completed\')\r\n            return\r\n\r\n        # Handle obstacle detection and recovery\r\n        if self.obstacle_detected:\r\n            if not self.recovery_mode:\r\n                self.recovery_mode = True\r\n                self.recovery_start_time = time.time()\r\n                self.get_logger().warn(f\'Obstacle detected at {self.obstacle_distance:.2f}m, initiating recovery\')\r\n\r\n            # In recovery mode, try to navigate around obstacle\r\n            cmd_vel = self.handle_obstacle_recovery()\r\n            self.cmd_vel_pub.publish(cmd_vel)\r\n            return\r\n\r\n        # Normal path following\r\n        if self.recovery_mode:\r\n            # Clear recovery mode after some time without obstacles\r\n            if time.time() - self.recovery_start_time > 2.0:\r\n                self.recovery_mode = False\r\n                self.get_logger().info(\'Obstacle cleared, resuming path following\')\r\n\r\n        # Find lookahead point\r\n        lookahead_point = self.find_lookahead_point()\r\n        if not lookahead_point:\r\n            self.stop_robot()\r\n            return\r\n\r\n        # Calculate control commands\r\n        linear_vel, angular_vel = self.calculate_control(lookahead_point)\r\n\r\n        # Create and publish velocity command\r\n        cmd_vel = Twist()\r\n        cmd_vel.linear.x = linear_vel\r\n        cmd_vel.angular.z = angular_vel\r\n\r\n        self.cmd_vel_pub.publish(cmd_vel)\r\n\r\n        # Publish current velocity for monitoring\r\n        vel_msg = Float32()\r\n        vel_msg.data = linear_vel\r\n        self.velocity_publisher.publish(vel_msg)\r\n\r\n        # Log control information\r\n        if time.time() - self.last_cmd_time > 1.0:  # Log every second\r\n            self.get_logger().info(\r\n                f\'Linear: {linear_vel:.3f}, Angular: {angular_vel:.3f}, \'\r\n                f\'Obstacles: {"Yes" if self.obstacle_detected else "No"}\')\r\n            self.last_cmd_time = time.time()\r\n\r\n    def handle_obstacle_recovery(self):\r\n        """Handle obstacle recovery behavior"""\r\n        # Simple recovery: slow down and try to go around\r\n        cmd_vel = Twist()\r\n\r\n        if self.obstacle_distance < 0.3:  # Very close, backup\r\n            cmd_vel.linear.x = -0.1\r\n            cmd_vel.angular.z = 0.0\r\n        elif self.obstacle_distance < 0.6:  # Medium distance, turn\r\n            cmd_vel.linear.x = 0.0\r\n            cmd_vel.angular.z = 0.5  # Turn in place\r\n        else:  # Far enough, slow down and continue\r\n            cmd_vel.linear.x = 0.1\r\n            cmd_vel.angular.z = 0.2  # Gentle turn\r\n\r\n        return cmd_vel\r\n\r\n    def stop_robot(self):\r\n        """Stop the robot"""\r\n        cmd_vel = Twist()\r\n        cmd_vel.linear.x = 0.0\r\n        cmd_vel.angular.z = 0.0\r\n        self.cmd_vel_pub.publish(cmd_vel)\r\n\r\n    def is_path_complete(self):\r\n        """Check if path execution is complete"""\r\n        if not self.current_path or self.current_path_index >= len(self.current_path):\r\n            return True\r\n\r\n        robot_pose = self.get_robot_pose()\r\n        if not robot_pose:\r\n            return False\r\n\r\n        last_waypoint = self.current_path[-1]\r\n        dist_to_goal = math.sqrt(\r\n            (robot_pose.position.x - last_waypoint.pose.position.x)**2 +\r\n            (robot_pose.position.y - last_waypoint.pose.position.y)**2)\r\n\r\n        return dist_to_goal < 0.25  # 25cm tolerance\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    controller = AdvancedPathController()\r\n\r\n    try:\r\n        rclpy.spin(controller)\r\n    except KeyboardInterrupt:\r\n        controller.get_logger().info(\'Advanced path controller stopped by user\')\r\n    finally:\r\n        controller.stop_robot()\r\n        controller.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,o.jsx)(r.h2,{id:"path-execution-integration-with-isaac-ros",children:"Path Execution Integration with Isaac ROS"}),"\n",(0,o.jsx)(r.h3,{id:"1-perception-enhanced-path-execution",children:"1. Perception-Enhanced Path Execution"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-yaml",children:'# Configuration for perception-enhanced path execution\r\ncontroller_server:\r\n  ros__parameters:\r\n    use_sim_time: false\r\n    controller_frequency: 30.0\r\n    min_x_velocity_threshold: 0.001\r\n    min_y_velocity_threshold: 0.001\r\n    min_theta_velocity_threshold: 0.001\r\n    failure_tolerance: 0.5\r\n    progress_checker_plugin: "progress_checker"\r\n    goal_checker_plugins: ["general_goal_checker"]\r\n    controller_plugins: ["FollowPath", "IsaacPerceptionController"]\r\n\r\n    progress_checker:\r\n      plugin: "nav2_controller::SimpleProgressChecker"\r\n      required_movement_radius: 0.25\r\n      movement_time_allowance: 5.0\r\n\r\n    general_goal_checker:\r\n      plugin: "nav2_controller::SimpleGoalChecker"\r\n      xy_goal_tolerance: 0.25\r\n      yaw_goal_tolerance: 0.25\r\n      stateful: True\r\n\r\n    FollowPath:\r\n      plugin: "dwb_core::DWBLocalPlanner"\r\n      debug_trajectory_details: False\r\n      min_vel_x: 0.05\r\n      min_vel_y: 0.0\r\n      max_vel_x: 0.6\r\n      max_vel_y: 0.0\r\n      max_vel_theta: 1.5\r\n      min_speed_xy: 0.05\r\n      max_speed_xy: 0.6\r\n      min_speed_theta: 0.1\r\n      acc_lim_x: 2.0\r\n      acc_lim_y: 0.0\r\n      acc_lim_theta: 3.0\r\n      decel_lim_x: -2.0\r\n      decel_lim_y: 0.0\r\n      decel_lim_theta: -3.0\r\n      vx_samples: 20\r\n      vy_samples: 5\r\n      vtheta_samples: 20\r\n      sim_time: 1.5\r\n      linear_granularity: 0.05\r\n      angular_granularity: 0.025\r\n      transform_tolerance: 0.1\r\n      xy_goal_tolerance: 0.25\r\n      yaw_goal_tolerance: 0.25\r\n      stateful: True\r\n      restore_defaults: False\r\n      publish_cost_grid_pc: False\r\n      use_dwb: True\r\n      max_vel_obstacle: 1.5\r\n\r\n    IsaacPerceptionController:\r\n      plugin: "nav2_isaac_controller/IsaacPerceptionController"\r\n      enabled: True\r\n      perception_topic: "/segmentation/segmentation_map"\r\n      dynamic_object_topic: "/dynamic_objects"\r\n      obstacle_cost_multiplier: 2.0\r\n      free_space_multiplier: 0.5\r\n      perception_timeout: 1.0\r\n      safety_buffer: 0.3\n'})}),"\n",(0,o.jsx)(r.h3,{id:"2-visual-inertial-path-execution",children:"2. Visual-Inertial Path Execution"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-yaml",children:'# Configuration for visual-inertial enhanced path execution\r\ncontroller_server:\r\n  ros__parameters:\r\n    use_sim_time: false\r\n    controller_frequency: 50.0  # Higher frequency for visual-inertial\r\n    min_x_velocity_threshold: 0.001\r\n    min_theta_velocity_threshold: 0.001\r\n    failure_tolerance: 0.3\r\n    progress_checker_plugin: "visual_inertial_progress_checker"\r\n    goal_checker_plugins: ["visual_inertial_goal_checker"]\r\n    controller_plugins: ["VisualInertialController"]\r\n\r\n    visual_inertial_progress_checker:\r\n      plugin: "nav2_controller::VisualInertialProgressChecker"\r\n      required_movement_radius: 0.2\r\n      movement_time_allowance: 3.0\r\n      visual_confidence_threshold: 0.7\r\n\r\n    visual_inertial_goal_checker:\r\n      plugin: "nav2_controller::VisualInertialGoalChecker"\r\n      xy_goal_tolerance: 0.15  # Tighter tolerance with visual feedback\r\n      yaw_goal_tolerance: 0.15\r\n      visual_alignment_tolerance: 0.2\r\n      stateful: True\r\n\r\n    VisualInertialController:\r\n      plugin: "nav2_visual_inertial_controller/VisualInertialController"\r\n      max_vel_x: 0.7\r\n      max_vel_theta: 2.0\r\n      visual_weight: 0.6\r\n      inertial_weight: 0.4\r\n      visual_inertial_fusion: true\r\n      pose_update_frequency: 100.0  # High frequency for visual-inertial\r\n      tracking_confidence_threshold: 0.6\n'})}),"\n",(0,o.jsx)(r.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,o.jsx)(r.h3,{id:"1-controller-performance-tuning",children:"1. Controller Performance Tuning"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-yaml",children:'# Optimized controller configuration for performance\r\ncontroller_server:\r\n  ros__parameters:\r\n    use_sim_time: false\r\n    controller_frequency: 20.0  # Balance between performance and control quality\r\n    min_x_velocity_threshold: 0.001\r\n    min_theta_velocity_threshold: 0.001\r\n    failure_tolerance: 0.5\r\n    progress_checker_plugin: "progress_checker"\r\n    goal_checker_plugins: ["general_goal_checker"]\r\n    controller_plugins: ["FollowPath"]\r\n\r\n    progress_checker:\r\n      plugin: "nav2_controller::SimpleProgressChecker"\r\n      required_movement_radius: 0.5\r\n      movement_time_allowance: 10.0\r\n\r\n    general_goal_checker:\r\n      plugin: "nav2_controller::SimpleGoalChecker"\r\n      xy_goal_tolerance: 0.25\r\n      yaw_goal_tolerance: 0.25\r\n      stateful: True\r\n\r\n    FollowPath:\r\n      plugin: "dwb_core::DWBLocalPlanner"\r\n      debug_trajectory_details: False  # Disable for performance\r\n      min_vel_x: 0.05\r\n      min_vel_y: 0.0\r\n      max_vel_x: 0.5\r\n      max_vel_y: 0.0\r\n      max_vel_theta: 1.0\r\n      min_speed_xy: 0.05\r\n      max_speed_xy: 0.5\r\n      min_speed_theta: 0.0\r\n      acc_lim_x: 1.5  # Lower acceleration for smoother motion\r\n      acc_lim_y: 0.0\r\n      acc_lim_theta: 2.0\r\n      decel_lim_x: -1.5\r\n      decel_lim_y: 0.0\r\n      decel_lim_theta: -2.0\r\n      vx_samples: 15  # Reduce samples for performance\r\n      vy_samples: 3\r\n      vtheta_samples: 15\r\n      sim_time: 1.0  # Shorter simulation time\r\n      linear_granularity: 0.1  # Coarser granularity\r\n      angular_granularity: 0.05\r\n      transform_tolerance: 0.2\r\n      xy_goal_tolerance: 0.25\r\n      yaw_goal_tolerance: 0.25\r\n      stateful: True\r\n      restore_defaults: False\r\n      publish_cost_grid_pc: False  # Disable for performance\r\n      use_dwb: True\r\n      max_vel_obstacle: 1.0\n'})}),"\n",(0,o.jsx)(r.h3,{id:"2-memory-and-computation-optimization",children:"2. Memory and Computation Optimization"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-yaml",children:'# Memory-optimized controller configuration\r\ncontroller_server:\r\n  ros__parameters:\r\n    use_sim_time: false\r\n    controller_frequency: 10.0  # Lower frequency to reduce CPU usage\r\n    min_x_velocity_threshold: 0.01\r\n    min_theta_velocity_threshold: 0.01\r\n    failure_tolerance: 1.0  # Higher tolerance to reduce re-planning\r\n    progress_checker_plugin: "simple_progress_checker"\r\n    goal_checker_plugins: ["simple_goal_checker"]\r\n    controller_plugins: ["SimpleController"]\r\n\r\n    simple_progress_checker:\r\n      plugin: "nav2_controller::SimpleProgressChecker"\r\n      required_movement_radius: 1.0  # Larger radius to reduce checks\r\n      movement_time_allowance: 20.0\r\n\r\n    simple_goal_checker:\r\n      plugin: "nav2_controller::SimpleGoalChecker"\r\n      xy_goal_tolerance: 0.5  # Larger tolerance for performance\r\n      yaw_goal_tolerance: 0.5\r\n      stateful: False  # Disable stateful behavior\r\n\r\n    SimpleController:\r\n      plugin: "dwb_core::DWBLocalPlanner"\r\n      debug_trajectory_details: False\r\n      min_vel_x: 0.1\r\n      max_vel_x: 0.3\r\n      max_vel_theta: 0.5\r\n      vx_samples: 10  # Minimal samples\r\n      vtheta_samples: 10\r\n      sim_time: 0.5  # Minimal simulation time\r\n      linear_granularity: 0.2\r\n      angular_granularity: 0.1\r\n      transform_tolerance: 0.5\r\n      xy_goal_tolerance: 0.5\r\n      stateful: False\n'})}),"\n",(0,o.jsx)(r.h2,{id:"path-execution-quality-metrics",children:"Path Execution Quality Metrics"}),"\n",(0,o.jsx)(r.h3,{id:"1-path-following-performance-metrics",children:"1. Path Following Performance Metrics"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n"""\r\nPath Execution Quality Metrics\r\n"""\r\nimport math\r\nfrom typing import List\r\nfrom geometry_msgs.msg import PoseStamped, Twist\r\n\r\n\r\nclass PathExecutionMetrics:\r\n    def __init__(self):\r\n        self.path_deviation_history = []\r\n        self.velocity_profile = []\r\n        self.execution_time = 0\r\n        self.start_time = None\r\n\r\n    def calculate_deviation(self, actual_pose: PoseStamped, path_poses: List[PoseStamped], current_idx: int):\r\n        """Calculate deviation from planned path"""\r\n        if not path_poses or current_idx >= len(path_poses):\r\n            return float(\'inf\')\r\n\r\n        # Find closest point on path\r\n        min_dist = float(\'inf\')\r\n        for i in range(current_idx, len(path_poses)):\r\n            path_pose = path_poses[i]\r\n            dist = math.sqrt(\r\n                (actual_pose.pose.position.x - path_pose.pose.position.x)**2 +\r\n                (actual_pose.pose.position.y - path_pose.pose.position.y)**2\r\n            )\r\n            min_dist = min(min_dist, dist)\r\n\r\n        self.path_deviation_history.append(min_dist)\r\n        return min_dist\r\n\r\n    def calculate_smoothness(self, velocity_profile: List[Twist]):\r\n        """Calculate path following smoothness"""\r\n        if len(velocity_profile) < 2:\r\n            return 0\r\n\r\n        acceleration_changes = []\r\n        for i in range(1, len(velocity_profile)):\r\n            prev_vel = velocity_profile[i-1]\r\n            curr_vel = velocity_profile[i]\r\n\r\n            linear_acc_change = abs(curr_vel.linear.x - prev_vel.linear.x)\r\n            angular_acc_change = abs(curr_vel.angular.z - prev_vel.angular.z)\r\n            total_change = linear_acc_change + angular_acc_change\r\n            acceleration_changes.append(total_change)\r\n\r\n        if acceleration_changes:\r\n            return sum(acceleration_changes) / len(acceleration_changes)\r\n        return 0\r\n\r\n    def calculate_efficiency(self, actual_distance: float, optimal_distance: float):\r\n        """Calculate path efficiency"""\r\n        if optimal_distance > 0:\r\n            return optimal_distance / actual_distance if actual_distance > 0 else 0\r\n        return 1.0  # Perfect efficiency if no optimal distance\r\n\r\n    def get_comprehensive_metrics(self, path_poses: List[PoseStamped], start_pose: PoseStamped, end_pose: PoseStamped):\r\n        """Get comprehensive path execution metrics"""\r\n        # Calculate total path length\r\n        total_path_length = 0\r\n        for i in range(1, len(path_poses)):\r\n            p1 = path_poses[i-1].pose.position\r\n            p2 = path_poses[i].pose.position\r\n            dist = math.sqrt((p2.x - p1.x)**2 + (p2.y - p1.y)**2)\r\n            total_path_length += dist\r\n\r\n        # Calculate actual travel distance\r\n        actual_distance = math.sqrt(\r\n            (end_pose.pose.position.x - start_pose.pose.position.x)**2 +\r\n            (end_pose.pose.position.y - start_pose.pose.position.y)**2\r\n        )\r\n\r\n        # Calculate metrics\r\n        avg_deviation = sum(self.path_deviation_history) / len(self.path_deviation_history) if self.path_deviation_history else float(\'inf\')\r\n        max_deviation = max(self.path_deviation_history) if self.path_deviation_history else float(\'inf\')\r\n        path_efficiency = self.calculate_efficiency(actual_distance, total_path_length)\r\n        smoothness = self.calculate_smoothness(self.velocity_profile)\r\n\r\n        return {\r\n            \'total_path_length\': total_path_length,\r\n            \'actual_distance\': actual_distance,\r\n            \'average_deviation\': avg_deviation,\r\n            \'max_deviation\': max_deviation,\r\n            \'path_efficiency\': path_efficiency,\r\n            \'smoothness\': smoothness,\r\n            \'execution_time\': self.execution_time,\r\n            \'deviation_std\': self.calculate_std(self.path_deviation_history)\r\n        }\r\n\r\n    def calculate_std(self, values):\r\n        """Calculate standard deviation"""\r\n        if len(values) < 2:\r\n            return 0\r\n        mean = sum(values) / len(values)\r\n        variance = sum((x - mean) ** 2 for x in values) / len(values)\r\n        return math.sqrt(variance)\n'})}),"\n",(0,o.jsx)(r.h2,{id:"troubleshooting-common-issues",children:"Troubleshooting Common Issues"}),"\n",(0,o.jsx)(r.h3,{id:"1-path-following-problems",children:"1. Path Following Problems"}),"\n",(0,o.jsx)(r.h4,{id:"issue-robot-oscillates-around-path",children:"Issue: Robot oscillates around path"}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Symptoms"}),": Robot sways back and forth across the path\r\n",(0,o.jsx)(r.strong,{children:"Solutions"}),":"]}),"\n",(0,o.jsxs)(r.ol,{children:["\n",(0,o.jsxs)(r.li,{children:["Increase lookahead distance:","\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-yaml",children:"lookahead_distance: 1.0  # Increase from 0.6\n"})}),"\n"]}),"\n",(0,o.jsxs)(r.li,{children:["Reduce angular velocity limits:","\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-yaml",children:"max_vel_theta: 0.8  # Reduce from 1.0\n"})}),"\n"]}),"\n",(0,o.jsx)(r.li,{children:"Increase minimum linear velocity to prevent stalling"}),"\n"]}),"\n",(0,o.jsx)(r.h4,{id:"issue-robot-stops-frequently-during-path-execution",children:"Issue: Robot stops frequently during path execution"}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Symptoms"}),": Robot stops and starts repeatedly\r\n",(0,o.jsx)(r.strong,{children:"Solutions"}),":"]}),"\n",(0,o.jsxs)(r.ol,{children:["\n",(0,o.jsxs)(r.li,{children:["Increase goal tolerances:","\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-yaml",children:"xy_goal_tolerance: 0.5  # Increase from 0.25\n"})}),"\n"]}),"\n",(0,o.jsx)(r.li,{children:"Check for costmap updates interfering with navigation"}),"\n",(0,o.jsx)(r.li,{children:"Verify sensor data quality and frequency"}),"\n"]}),"\n",(0,o.jsx)(r.h4,{id:"issue-robot-cannot-follow-sharp-turns",children:"Issue: Robot cannot follow sharp turns"}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Symptoms"}),": Robot cuts corners or fails to turn properly\r\n",(0,o.jsx)(r.strong,{children:"Solutions"}),":"]}),"\n",(0,o.jsxs)(r.ol,{children:["\n",(0,o.jsxs)(r.li,{children:["Reduce linear velocity during turns:","\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-yaml",children:"max_vel_x: 0.3  # Reduce for sharp turns\n"})}),"\n"]}),"\n",(0,o.jsxs)(r.li,{children:["Increase angular velocity limits:","\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-yaml",children:"max_vel_theta: 2.0  # Increase for sharper turns\n"})}),"\n"]}),"\n",(0,o.jsx)(r.li,{children:"Implement velocity scaling based on curvature"}),"\n"]}),"\n",(0,o.jsx)(r.h3,{id:"2-performance-issues",children:"2. Performance Issues"}),"\n",(0,o.jsx)(r.h4,{id:"issue-high-cpu-usage-during-path-execution",children:"Issue: High CPU usage during path execution"}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Symptoms"}),": System becomes unresponsive during navigation\r\n",(0,o.jsx)(r.strong,{children:"Solutions"}),":"]}),"\n",(0,o.jsxs)(r.ol,{children:["\n",(0,o.jsxs)(r.li,{children:["Reduce controller frequency:","\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-yaml",children:"controller_frequency: 10.0  # Reduce from 20.0\n"})}),"\n"]}),"\n",(0,o.jsx)(r.li,{children:"Simplify path following algorithm"}),"\n",(0,o.jsxs)(r.li,{children:["Reduce number of velocity samples:","\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-yaml",children:"vx_samples: 10  # Reduce from 20\r\nvtheta_samples: 10  # Reduce from 20\n"})}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(r.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsx)(r.h3,{id:"1-controller-selection-guidelines",children:"1. Controller Selection Guidelines"}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"DWB (Dynamic Window Approach)"}),": Best for dynamic obstacle avoidance"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"MPC (Model Predictive Control)"}),": Best for precise control and constraints"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Pure Pursuit"}),": Best for smooth, predictable paths"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Trajectory Rollout"}),": Best for complex dynamics"]}),"\n"]}),"\n",(0,o.jsx)(r.h3,{id:"2-parameter-tuning-best-practices",children:"2. Parameter Tuning Best Practices"}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsx)(r.li,{children:"Start with conservative parameters"}),"\n",(0,o.jsx)(r.li,{children:"Tune for your specific robot dynamics"}),"\n",(0,o.jsx)(r.li,{children:"Test in simulation before real-world deployment"}),"\n",(0,o.jsx)(r.li,{children:"Monitor performance metrics during operation"}),"\n",(0,o.jsx)(r.li,{children:"Adjust parameters based on environment complexity"}),"\n"]}),"\n",(0,o.jsx)(r.h3,{id:"3-safety-considerations",children:"3. Safety Considerations"}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsx)(r.li,{children:"Implement emergency stop mechanisms"}),"\n",(0,o.jsx)(r.li,{children:"Set appropriate velocity limits"}),"\n",(0,o.jsx)(r.li,{children:"Monitor obstacle detection continuously"}),"\n",(0,o.jsx)(r.li,{children:"Implement recovery behaviors for failure cases"}),"\n"]}),"\n",(0,o.jsx)(r.h2,{id:"integration-with-navigation-system",children:"Integration with Navigation System"}),"\n",(0,o.jsx)(r.h3,{id:"1-complete-navigation-configuration",children:"1. Complete Navigation Configuration"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-yaml",children:'# Complete navigation stack configuration\r\nplanner_server:\r\n  ros__parameters:\r\n    expected_planner_frequency: 1.0\r\n    use_sim_time: false\r\n    planner_plugins: ["GridBased"]\r\n    GridBased:\r\n      plugin: "nav2_navfn_planner::NavfnPlanner"\r\n      tolerance: 0.5\r\n      use_astar: true\r\n      allow_unknown: false\r\n\r\ncontroller_server:\r\n  ros__parameters:\r\n    use_sim_time: false\r\n    controller_frequency: 20.0\r\n    min_x_velocity_threshold: 0.001\r\n    min_theta_velocity_threshold: 0.001\r\n    failure_tolerance: 0.3\r\n    progress_checker_plugin: "progress_checker"\r\n    goal_checker_plugins: ["general_goal_checker"]\r\n    controller_plugins: ["FollowPath"]\r\n    # ... (controller config from above)\r\n\r\nbehavior_server:\r\n  ros__parameters:\r\n    costmap_topic: local_costmap/costmap_raw\r\n    footprint_topic: local_costmap/published_footprint\r\n    cycle_frequency: 10.0\r\n    behavior_plugins: ["spin", "backup", "wait"]\r\n    # ... (behavior config)\r\n\r\nlocal_costmap:\r\n  local_costmap:\r\n    ros__parameters:\r\n      update_frequency: 5.0\r\n      publish_frequency: 2.0\r\n      global_frame: odom\r\n      robot_base_frame: base_link\r\n      use_sim_time: false\r\n      rolling_window: true\r\n      width: 3\r\n      height: 3\r\n      resolution: 0.05\r\n      # ... (costmap config)\r\n\r\nglobal_costmap:\r\n  global_costmap:\r\n    ros__parameters:\r\n      update_frequency: 1.0\r\n      publish_frequency: 1.0\r\n      global_frame: map\r\n      robot_base_frame: base_link\r\n      use_sim_time: false\r\n      robot_radius: 0.22\r\n      # ... (costmap config)\n'})}),"\n",(0,o.jsx)(r.h2,{id:"resources",children:"Resources"}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsx)(r.li,{children:(0,o.jsx)(r.a,{href:"https://navigation.ros.org/configuration/packages/configuring-controllers.html",children:"Navigation2 Controller Documentation"})}),"\n",(0,o.jsx)(r.li,{children:(0,o.jsx)(r.a,{href:"https://github.com/ros-planning/navigation2/blob/main/dwb_core/dwb_plugins/README.md",children:"DWB Local Planner Guide"})}),"\n",(0,o.jsx)(r.li,{children:(0,o.jsx)(r.a,{href:"https://navigation.ros.org/tutorials/docs/path_execution_tutorial.html",children:"Path Execution Tutorials"})}),"\n"]}),"\n",(0,o.jsx)(r.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(r.p,{children:"This guide provides comprehensive coverage of path execution controllers for ROS 2 Navigation2. The path execution controller is a critical component that bridges the gap between global path planning and actual robot motion. Proper configuration and tuning are essential for achieving smooth, safe, and efficient navigation. The choice of controller algorithm and parameters depends on your specific robot dynamics, environment, and performance requirements."})]})}function p(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,o.jsx)(r,{...e,children:(0,o.jsx)(_,{...e})}):_(e)}},7074:(e,r,n)=>{n.d(r,{R:()=>l,x:()=>i});var t=n(6540);const o={},a=t.createContext(o);function l(e){const r=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:l(e.components),t.createElement(a.Provider,{value:r},e.children)}}}]);