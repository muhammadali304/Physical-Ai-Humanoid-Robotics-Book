"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[5361],{7074:(e,r,n)=>{n.d(r,{R:()=>s,x:()=>o});var t=n(6540);const i={},a=t.createContext(i);function s(e){const r=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(a.Provider,{value:r},e.children)}},8904:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"appendix/security-best-practices","title":"Security Best Practices for Robotics Applications","description":"This document provides comprehensive security best practices for robotics applications, covering both software and hardware security considerations.","source":"@site/docs/appendix/security-best-practices.md","sourceDirName":"appendix","slug":"/appendix/security-best-practices","permalink":"/./docs/appendix/security-best-practices","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/appendix/security-best-practices.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Hardware Guide - Physical AI & Humanoid Robotics","permalink":"/./docs/appendix/hardware-guide"},"next":{"title":"Assessment Methods for Physical AI and Humanoid Robotics","permalink":"/./docs/appendix/assessment-methods"}}');var i=n(4848),a=n(7074);const s={},o="Security Best Practices for Robotics Applications",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Security Domains in Robotics",id:"security-domains-in-robotics",level:2},{value:"1. Network Security",id:"1-network-security",level:3},{value:"2. Software Security",id:"2-software-security",level:3},{value:"3. Hardware Security",id:"3-hardware-security",level:3},{value:"4. Data Security",id:"4-data-security",level:3},{value:"Network Security Best Practices",id:"network-security-best-practices",level:2},{value:"1. ROS 2 Security Configuration",id:"1-ros-2-security-configuration",level:3},{value:"A. DDS Security",id:"a-dds-security",level:4},{value:"B. Secure ROS 2 Node Implementation",id:"b-secure-ros-2-node-implementation",level:4},{value:"2. Network Segmentation and Isolation",id:"2-network-segmentation-and-isolation",level:3},{value:"A. Network Configuration",id:"a-network-configuration",level:4},{value:"3. Wireless Security for Mobile Robots",id:"3-wireless-security-for-mobile-robots",level:3},{value:"A. WiFi Security Configuration",id:"a-wifi-security-configuration",level:4},{value:"Software Security Best Practices",id:"software-security-best-practices",level:2},{value:"1. Secure Coding Practices",id:"1-secure-coding-practices",level:3},{value:"A. Input Validation and Sanitization",id:"a-input-validation-and-sanitization",level:4},{value:"B. Authentication and Authorization",id:"b-authentication-and-authorization",level:4},{value:"2. Dependency and Package Security",id:"2-dependency-and-package-security",level:3},{value:"A. Secure Dependency Management",id:"a-secure-dependency-management",level:4},{value:"Hardware Security Best Practices",id:"hardware-security-best-practices",level:2},{value:"1. Physical Security Measures",id:"1-physical-security-measures",level:3},{value:"A. Secure Hardware Design",id:"a-secure-hardware-design",level:4},{value:"2. Firmware Security",id:"2-firmware-security",level:3},{value:"A. Secure Firmware Updates",id:"a-secure-firmware-updates",level:4},{value:"Data Security Best Practices",id:"data-security-best-practices",level:2},{value:"1. Data Encryption and Privacy",id:"1-data-encryption-and-privacy",level:3},{value:"A. Data Protection Implementation",id:"a-data-protection-implementation",level:4},{value:"2. Privacy Protection",id:"2-privacy-protection",level:3},{value:"A. Privacy-Enhancing Technologies",id:"a-privacy-enhancing-technologies",level:4},{value:"Security Monitoring and Incident Response",id:"security-monitoring-and-incident-response",level:2},{value:"1. Security Monitoring System",id:"1-security-monitoring-system",level:3},{value:"A. Security Event Monitoring",id:"a-security-event-monitoring",level:4}];function d(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.header,{children:(0,i.jsx)(r.h1,{id:"security-best-practices-for-robotics-applications",children:"Security Best Practices for Robotics Applications"})}),"\n",(0,i.jsx)(r.p,{children:"This document provides comprehensive security best practices for robotics applications, covering both software and hardware security considerations."}),"\n",(0,i.jsx)(r.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(r.p,{children:"Robotics security is a critical aspect of modern robotics development, encompassing protection against unauthorized access, data breaches, physical tampering, and cyber attacks. This guide covers security considerations for all aspects of the Physical AI and Humanoid Robotics curriculum."}),"\n",(0,i.jsx)(r.h2,{id:"security-domains-in-robotics",children:"Security Domains in Robotics"}),"\n",(0,i.jsx)(r.h3,{id:"1-network-security",children:"1. Network Security"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Communication Protocols"}),": Securing ROS 2 communications"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Network Segmentation"}),": Isolating robot networks"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Wireless Security"}),": Protecting wireless connections"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Firewall Configuration"}),": Controlling network access"]}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"2-software-security",children:"2. Software Security"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Code Security"}),": Secure coding practices"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Dependency Management"}),": Managing third-party libraries"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Authentication"}),": User and system authentication"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Authorization"}),": Access control mechanisms"]}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"3-hardware-security",children:"3. Hardware Security"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Physical Access Control"}),": Protecting hardware components"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Secure Boot"}),": Ensuring trusted boot processes"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Hardware Tamper Detection"}),": Detecting physical tampering"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Firmware Security"}),": Protecting firmware integrity"]}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"4-data-security",children:"4. Data Security"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Data Encryption"}),": Protecting sensitive data"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Privacy Protection"}),": Safeguarding personal information"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Data Integrity"}),": Ensuring data accuracy"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Audit Trails"}),": Tracking system activities"]}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"network-security-best-practices",children:"Network Security Best Practices"}),"\n",(0,i.jsx)(r.h3,{id:"1-ros-2-security-configuration",children:"1. ROS 2 Security Configuration"}),"\n",(0,i.jsx)(r.h4,{id:"a-dds-security",children:"A. DDS Security"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-yaml",children:'# security_config.yaml - DDS Security Configuration\r\nname: "robot_security"\r\nversion: "1.0"\r\n\r\n# DomainParticipant security configuration\r\ndomain_participant:\r\n  access_control_plugin: "builtin.AccessControl"\r\n  authentication_plugin: "builtin.Authentication"\r\n  cryptography_plugin: "builtin.Cryptographic"\r\n\r\n# Access control rules\r\naccess_control:\r\n  # Allow only specific participants\r\n  permissions:\r\n    - domain_id: 0\r\n      allow: ["robot_control", "navigation", "perception"]\r\n      deny: ["*"]  # Deny all others by default\r\n\r\n# Authentication configuration\r\nauthentication:\r\n  # Use certificate-based authentication\r\n  method: "certificate"\r\n  certificate_file: "/etc/ros/security/certificates/robot_cert.pem"\r\n  private_key_file: "/etc/ros/security/keys/robot_key.pem"\r\n  trusted_ca_file: "/etc/ros/security/certificates/ca_cert.pem"\r\n\r\n# Cryptography settings\r\ncryptography:\r\n  # Use AES-256 encryption\r\n  cipher_suite: "AES256_GCM"\r\n  key_size: 256\n'})}),"\n",(0,i.jsx)(r.h4,{id:"b-secure-ros-2-node-implementation",children:"B. Secure ROS 2 Node Implementation"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:'# secure_node_example.py\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom rclpy.qos import QoSProfile, QoSDurabilityPolicy, QoSReliabilityPolicy\r\nfrom std_msgs.msg import String\r\nimport ssl\r\nimport hashlib\r\nfrom typing import Optional\r\n\r\n\r\nclass SecureRobotNode(Node):\r\n    """\r\n    Example of a secure ROS 2 node implementation\r\n    """\r\n    def __init__(self):\r\n        super().__init__(\'secure_robot_node\')\r\n\r\n        # Initialize security components\r\n        self.security_manager = SecurityManager()\r\n        self.encryption_manager = EncryptionManager()\r\n\r\n        # Create secure publisher with authentication\r\n        qos_profile = QoSProfile(\r\n            depth=10,\r\n            durability=QoSDurabilityPolicy.TRANSIENT_LOCAL,\r\n            reliability=QoSReliabilityPolicy.RELIABLE\r\n        )\r\n\r\n        self.secure_publisher = self.create_publisher(\r\n            String,\r\n            \'secure_commands\',\r\n            qos_profile\r\n        )\r\n\r\n        # Create secure subscription with validation\r\n        self.secure_subscriber = self.create_subscription(\r\n            String,\r\n            \'secure_status\',\r\n            self.secure_status_callback,\r\n            qos_profile\r\n        )\r\n\r\n        # Start security monitoring\r\n        self.security_timer = self.create_timer(1.0, self.security_check)\r\n\r\n    def secure_status_callback(self, msg):\r\n        """\r\n        Secure callback with message validation\r\n        """\r\n        # Validate message integrity\r\n        if not self.security_manager.validate_message(msg):\r\n            self.get_logger().error("Invalid message received")\r\n            return\r\n\r\n        # Decrypt message if encrypted\r\n        decrypted_msg = self.encryption_manager.decrypt(msg.data)\r\n        if decrypted_msg is None:\r\n            self.get_logger().error("Failed to decrypt message")\r\n            return\r\n\r\n        # Process the secure message\r\n        self.process_secure_command(decrypted_msg)\r\n\r\n    def process_secure_command(self, command: str):\r\n        """\r\n        Process secure commands with authorization\r\n        """\r\n        # Check if command is authorized\r\n        if not self.security_manager.is_authorized_command(command):\r\n            self.get_logger().error(f"Unauthorized command: {command}")\r\n            return\r\n\r\n        # Execute command safely\r\n        self.execute_command(command)\r\n\r\n    def security_check(self):\r\n        """\r\n        Periodic security checks\r\n        """\r\n        # Check for security violations\r\n        security_status = self.security_manager.get_security_status()\r\n        if not security_status[\'secure\']:\r\n            self.get_logger().warn(f"Security issue detected: {security_status[\'details\']}")\r\n\r\n\r\nclass SecurityManager:\r\n    """\r\n    Security management for ROS 2 nodes\r\n    """\r\n    def __init__(self):\r\n        self.authorized_commands = {\r\n            \'move_forward\', \'turn_left\', \'turn_right\', \'stop\',\r\n            \'take_picture\', \'speak\', \'listen\', \'shutdown\'\r\n        }\r\n        self.message_history = []\r\n        self.security_thresholds = {\r\n            \'max_commands_per_minute\': 60,\r\n            \'max_message_size\': 1024  # bytes\r\n        }\r\n\r\n    def validate_message(self, msg) -> bool:\r\n        """\r\n        Validate message integrity and format\r\n        """\r\n        # Check message size\r\n        if len(str(msg)) > self.security_thresholds[\'max_message_size\']:\r\n            return False\r\n\r\n        # Check for command frequency\r\n        current_time = rclpy.time.Time().nanoseconds\r\n        recent_commands = [\r\n            m for m in self.message_history\r\n            if current_time - m[\'timestamp\'] < 60000000000  # 1 minute\r\n        ]\r\n\r\n        if len(recent_commands) > self.security_thresholds[\'max_commands_per_minute\']:\r\n            return False\r\n\r\n        # Add to history\r\n        self.message_history.append({\r\n            \'timestamp\': current_time,\r\n            \'content\': str(msg)\r\n        })\r\n\r\n        # Keep only recent history\r\n        self.message_history = self.message_history[-100:]\r\n\r\n        return True\r\n\r\n    def is_authorized_command(self, command: str) -> bool:\r\n        """\r\n        Check if command is authorized\r\n        """\r\n        # Simple command validation\r\n        return command.split()[0] in self.authorized_commands\r\n\r\n    def get_security_status(self) -> dict:\r\n        """\r\n        Get current security status\r\n        """\r\n        return {\r\n            \'secure\': True,\r\n            \'details\': \'All systems nominal\',\r\n            \'last_check\': rclpy.time.Time().nanoseconds\r\n        }\r\n\r\n\r\nclass EncryptionManager:\r\n    """\r\n    Encryption management for secure communications\r\n    """\r\n    def __init__(self):\r\n        self.encryption_key = self._generate_encryption_key()\r\n        self.algorithm = \'AES-256\'\r\n\r\n    def _generate_encryption_key(self) -> bytes:\r\n        """\r\n        Generate secure encryption key\r\n        """\r\n        import os\r\n        return os.urandom(32)  # 256-bit key\r\n\r\n    def encrypt(self, data: str) -> str:\r\n        """\r\n        Encrypt data before transmission\r\n        """\r\n        # In practice, use a proper encryption library like cryptography\r\n        import base64\r\n        # This is a simplified example - use proper encryption in production\r\n        encrypted = base64.b64encode(data.encode()).decode()\r\n        return encrypted\r\n\r\n    def decrypt(self, encrypted_data: str) -> Optional[str]:\r\n        """\r\n        Decrypt received data\r\n        """\r\n        try:\r\n            import base64\r\n            # This is a simplified example - use proper decryption in production\r\n            decrypted = base64.b64decode(encrypted_data.encode()).decode()\r\n            return decrypted\r\n        except Exception:\r\n            return None\n'})}),"\n",(0,i.jsx)(r.h3,{id:"2-network-segmentation-and-isolation",children:"2. Network Segmentation and Isolation"}),"\n",(0,i.jsx)(r.h4,{id:"a-network-configuration",children:"A. Network Configuration"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-bash",children:'# network_security.sh - Network security configuration script\r\n#!/bin/bash\r\n\r\n# Create isolated network namespace for robot\r\ncreate_robot_namespace() {\r\n    echo "Creating isolated network namespace for robot..."\r\n\r\n    # Create network namespace\r\n    sudo ip netns add robot_ns\r\n\r\n    # Create virtual ethernet pair\r\n    sudo ip link add veth0 type veth peer name veth1\r\n\r\n    # Move one end to robot namespace\r\n    sudo ip link set veth1 netns robot_ns\r\n\r\n    # Configure host side\r\n    sudo ip addr add 192.168.100.1/24 dev veth0\r\n    sudo ip link set veth0 up\r\n\r\n    # Configure robot namespace side\r\n    sudo ip netns exec robot_ns ip addr add 192.168.100.2/24 dev veth1\r\n    sudo ip netns exec robot_ns ip link set veth1 up\r\n    sudo ip netns exec robot_ns ip link set lo up\r\n\r\n    echo "Network namespace created successfully"\r\n}\r\n\r\n# Configure firewall rules\r\nconfigure_firewall() {\r\n    echo "Configuring firewall rules..."\r\n\r\n    # Allow only necessary ROS 2 ports\r\n    sudo ufw allow 11311/tcp  # ROS master\r\n    sudo ufw allow 8883/tcp   # MQTT (if used)\r\n    sudo ufw allow 9090/tcp   # rosbridge (if used)\r\n\r\n    # Deny all other incoming connections by default\r\n    sudo ufw default deny incoming\r\n    sudo ufw default allow outgoing\r\n\r\n    # Enable firewall\r\n    sudo ufw --force enable\r\n\r\n    echo "Firewall configured successfully"\r\n}\r\n\r\n# Setup VPN for remote access\r\nsetup_vpn_access() {\r\n    echo "Setting up VPN for secure remote access..."\r\n\r\n    # Install OpenVPN\r\n    sudo apt update\r\n    sudo apt install -y openvpn easy-rsa\r\n\r\n    # Generate certificates (simplified)\r\n    make-cadir ~/openvpn-ca\r\n    cd ~/openvpn-ca\r\n    ./easyrsa init-pki\r\n    ./easyrsa build-ca nopass\r\n\r\n    echo "VPN setup initiated - complete certificate generation manually"\r\n}\r\n\r\n# Main execution\r\nif [ "$1" = "setup" ]; then\r\n    create_robot_namespace\r\n    configure_firewall\r\n    setup_vpn_access\r\n    echo "Network security setup completed"\r\nelif [ "$1" = "cleanup" ]; then\r\n    sudo ip netns delete robot_ns 2>/dev/null || true\r\n    sudo ip link delete veth0 2>/dev/null || true\r\n    echo "Network security cleanup completed"\r\nelse\r\n    echo "Usage: $0 {setup|cleanup}"\r\n    exit 1\r\nfi\n'})}),"\n",(0,i.jsx)(r.h3,{id:"3-wireless-security-for-mobile-robots",children:"3. Wireless Security for Mobile Robots"}),"\n",(0,i.jsx)(r.h4,{id:"a-wifi-security-configuration",children:"A. WiFi Security Configuration"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-yaml",children:'# wifi_security.yaml - WiFi security configuration\r\nwireless_security:\r\n  # Network configuration\r\n  ssid: "robot_network"\r\n  security_type: "WPA2-Enterprise"  # Use WPA3 if available\r\n  authentication:\r\n    method: "EAP-TLS"  # Certificate-based authentication\r\n    certificate_path: "/etc/robot/security/client_cert.pem"\r\n    private_key_path: "/etc/robot/security/client_key.pem"\r\n    ca_cert_path: "/etc/robot/security/ca_cert.pem"\r\n\r\n  # Connection parameters\r\n  connection_timeout: 30  # seconds\r\n  retry_attempts: 3\r\n  reconnect_interval: 5  # seconds\r\n\r\n  # Security monitoring\r\n  monitoring:\r\n    scan_interval: 60  # seconds\r\n    suspicious_beacon_threshold: 5\r\n    deauth_attack_detection: true\n'})}),"\n",(0,i.jsx)(r.h2,{id:"software-security-best-practices",children:"Software Security Best Practices"}),"\n",(0,i.jsx)(r.h3,{id:"1-secure-coding-practices",children:"1. Secure Coding Practices"}),"\n",(0,i.jsx)(r.h4,{id:"a-input-validation-and-sanitization",children:"A. Input Validation and Sanitization"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:"# secure_input_handling.py\r\nimport re\r\nimport html\r\nfrom typing import Any, Dict, List\r\nimport json\r\n\r\n\r\nclass SecureInputHandler:\r\n    \"\"\"\r\n    Secure input handling with validation and sanitization\r\n    \"\"\"\r\n    def __init__(self):\r\n        # Define allowed patterns for different input types\r\n        self.patterns = {\r\n            'robot_command': r'^[a-zA-Z_][a-zA-Z0-9_]*$',\r\n            'coordinate': r'^-?\\d+\\.?\\d*,\\s*-?\\d+\\.?\\d*(,\\s*-?\\d+\\.?\\d*)?$',\r\n            'user_name': r'^[a-zA-Z][a-zA-Z0-9_]{2,19}$',\r\n            'file_path': r'^[a-zA-Z0-9/_\\-.]+$'\r\n        }\r\n\r\n    def validate_command(self, command: str) -> Dict[str, Any]:\r\n        \"\"\"\r\n        Validate robot command with security checks\r\n        \"\"\"\r\n        result = {\r\n            'valid': False,\r\n            'sanitized': '',\r\n            'errors': []\r\n        }\r\n\r\n        # Check for command injection patterns\r\n        dangerous_patterns = [\r\n            r'[;&|`$()]',  # Shell metacharacters\r\n            r'\\.\\./',      # Directory traversal\r\n            r'exec\\(|eval\\(|system\\(',  # Dangerous functions\r\n        ]\r\n\r\n        for pattern in dangerous_patterns:\r\n            if re.search(pattern, command, re.IGNORECASE):\r\n                result['errors'].append(f'Dangerous pattern detected: {pattern}')\r\n                return result\r\n\r\n        # Validate against allowed pattern\r\n        if not re.match(self.patterns['robot_command'], command.split()[0] if command.split() else ''):\r\n            result['errors'].append('Invalid command format')\r\n            return result\r\n\r\n        # Sanitize the command\r\n        result['sanitized'] = self._sanitize_input(command)\r\n        result['valid'] = True\r\n\r\n        return result\r\n\r\n    def validate_coordinates(self, coord_str: str) -> Dict[str, Any]:\r\n        \"\"\"\r\n        Validate coordinate input\r\n        \"\"\"\r\n        result = {\r\n            'valid': False,\r\n            'coordinates': None,\r\n            'errors': []\r\n        }\r\n\r\n        if not re.match(self.patterns['coordinate'], coord_str):\r\n            result['errors'].append('Invalid coordinate format')\r\n            return result\r\n\r\n        try:\r\n            coords = [float(x.strip()) for x in coord_str.split(',')]\r\n            if len(coords) < 2 or len(coords) > 3:\r\n                result['errors'].append('Invalid number of coordinates')\r\n                return result\r\n\r\n            result['coordinates'] = coords\r\n            result['valid'] = True\r\n        except ValueError:\r\n            result['errors'].append('Invalid coordinate values')\r\n\r\n        return result\r\n\r\n    def _sanitize_input(self, input_str: str) -> str:\r\n        \"\"\"\r\n        Sanitize input string\r\n        \"\"\"\r\n        # Remove HTML tags\r\n        sanitized = html.escape(input_str)\r\n\r\n        # Remove dangerous characters\r\n        sanitized = re.sub(r'[<>\"\\']', '', sanitized)\r\n\r\n        # Limit length\r\n        if len(sanitized) > 1000:\r\n            sanitized = sanitized[:1000]\r\n\r\n        return sanitized\r\n\r\n    def validate_json_input(self, json_str: str) -> Dict[str, Any]:\r\n        \"\"\"\r\n        Validate JSON input safely\r\n        \"\"\"\r\n        result = {\r\n            'valid': False,\r\n            'data': None,\r\n            'errors': []\r\n        }\r\n\r\n        try:\r\n            # Parse JSON with limits to prevent large object attacks\r\n            if len(json_str) > 100000:  # 100KB limit\r\n                result['errors'].append('JSON input too large')\r\n                return result\r\n\r\n            parsed_data = json.loads(json_str)\r\n\r\n            # Validate structure\r\n            if not isinstance(parsed_data, dict):\r\n                result['errors'].append('JSON must be an object')\r\n                return result\r\n\r\n            # Sanitize all string values\r\n            sanitized_data = self._sanitize_dict(parsed_data)\r\n\r\n            result['data'] = sanitized_data\r\n            result['valid'] = True\r\n        except json.JSONDecodeError as e:\r\n            result['errors'].append(f'Invalid JSON: {str(e)}')\r\n        except Exception as e:\r\n            result['errors'].append(f'Validation error: {str(e)}')\r\n\r\n        return result\r\n\r\n    def _sanitize_dict(self, data: Dict[str, Any]) -> Dict[str, Any]:\r\n        \"\"\"\r\n        Recursively sanitize dictionary values\r\n        \"\"\"\r\n        if isinstance(data, str):\r\n            return self._sanitize_input(data)\r\n        elif isinstance(data, dict):\r\n            return {k: self._sanitize_dict(v) for k, v in data.items()}\r\n        elif isinstance(data, list):\r\n            return [self._sanitize_dict(item) for item in data]\r\n        else:\r\n            return data\n"})}),"\n",(0,i.jsx)(r.h4,{id:"b-authentication-and-authorization",children:"B. Authentication and Authorization"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:"# auth_system.py\r\nimport hashlib\r\nimport secrets\r\nimport jwt\r\nfrom datetime import datetime, timedelta\r\nfrom typing import Dict, Optional, List\r\nimport bcrypt\r\n\r\n\r\nclass RobotAuthenticationSystem:\r\n    \"\"\"\r\n    Authentication and authorization system for robotics applications\r\n    \"\"\"\r\n    def __init__(self):\r\n        self.secret_key = secrets.token_urlsafe(32)\r\n        self.users = {}  # In production, use a database\r\n        self.active_sessions = {}\r\n        self.role_permissions = {\r\n            'admin': ['all_operations'],\r\n            'operator': ['basic_control', 'monitoring'],\r\n            'guest': ['view_only']\r\n        }\r\n\r\n    def register_user(self, username: str, password: str, role: str = 'operator') -> bool:\r\n        \"\"\"\r\n        Register a new user with hashed password\r\n        \"\"\"\r\n        if username in self.users:\r\n            return False\r\n\r\n        # Hash password securely\r\n        password_hash = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())\r\n\r\n        self.users[username] = {\r\n            'password_hash': password_hash,\r\n            'role': role,\r\n            'created_at': datetime.now(),\r\n            'last_login': None\r\n        }\r\n\r\n        return True\r\n\r\n    def authenticate_user(self, username: str, password: str) -> Optional[Dict[str, str]]:\r\n        \"\"\"\r\n        Authenticate user and return JWT token\r\n        \"\"\"\r\n        if username not in self.users:\r\n            return None\r\n\r\n        user = self.users[username]\r\n\r\n        # Verify password\r\n        if bcrypt.checkpw(password.encode('utf-8'), user['password_hash']):\r\n            # Update last login\r\n            user['last_login'] = datetime.now()\r\n\r\n            # Generate JWT token\r\n            token_payload = {\r\n                'username': username,\r\n                'role': user['role'],\r\n                'exp': datetime.utcnow() + timedelta(hours=24),\r\n                'iat': datetime.utcnow()\r\n            }\r\n\r\n            token = jwt.encode(token_payload, self.secret_key, algorithm='HS256')\r\n            session_id = secrets.token_urlsafe(32)\r\n\r\n            # Store session\r\n            self.active_sessions[session_id] = {\r\n                'username': username,\r\n                'token': token,\r\n                'created_at': datetime.now()\r\n            }\r\n\r\n            return {\r\n                'session_id': session_id,\r\n                'token': token,\r\n                'role': user['role']\r\n            }\r\n\r\n        return None\r\n\r\n    def validate_token(self, token: str) -> Optional[Dict[str, str]]:\r\n        \"\"\"\r\n        Validate JWT token\r\n        \"\"\"\r\n        try:\r\n            payload = jwt.decode(token, self.secret_key, algorithms=['HS256'])\r\n            return payload\r\n        except jwt.ExpiredSignatureError:\r\n            return None\r\n        except jwt.InvalidTokenError:\r\n            return None\r\n\r\n    def authorize_action(self, username: str, action: str) -> bool:\r\n        \"\"\"\r\n        Check if user is authorized to perform action\r\n        \"\"\"\r\n        if username not in self.users:\r\n            return False\r\n\r\n        user_role = self.users[username]['role']\r\n        user_permissions = self.role_permissions.get(user_role, [])\r\n\r\n        # Check if user has permission for action\r\n        return 'all_operations' in user_permissions or action in user_permissions\r\n\r\n    def logout_user(self, session_id: str) -> bool:\r\n        \"\"\"\r\n        Logout user and invalidate session\r\n        \"\"\"\r\n        if session_id in self.active_sessions:\r\n            del self.active_sessions[session_id]\r\n            return True\r\n        return False\r\n\r\n\r\nclass RBACManager:\r\n    \"\"\"\r\n    Role-Based Access Control manager\r\n    \"\"\"\r\n    def __init__(self):\r\n        self.roles = {\r\n            'admin': {\r\n                'permissions': [\r\n                    'robot_control_all',\r\n                    'system_configuration',\r\n                    'user_management',\r\n                    'data_access_all',\r\n                    'security_management'\r\n                ]\r\n            },\r\n            'operator': {\r\n                'permissions': [\r\n                    'robot_basic_control',\r\n                    'navigation',\r\n                    'perception_view',\r\n                    'limited_data_access'\r\n                ]\r\n            },\r\n            'researcher': {\r\n                'permissions': [\r\n                    'experiment_control',\r\n                    'data_analysis',\r\n                    'algorithm_development',\r\n                    'limited_navigation'\r\n                ]\r\n            },\r\n            'guest': {\r\n                'permissions': [\r\n                    'view_system_status',\r\n                    'view_logs',\r\n                    'basic_monitoring'\r\n                ]\r\n            }\r\n        }\r\n\r\n    def check_permission(self, role: str, permission: str) -> bool:\r\n        \"\"\"\r\n        Check if role has specific permission\r\n        \"\"\"\r\n        role_data = self.roles.get(role, {})\r\n        return permission in role_data.get('permissions', [])\r\n\r\n    def get_role_permissions(self, role: str) -> List[str]:\r\n        \"\"\"\r\n        Get all permissions for a role\r\n        \"\"\"\r\n        return self.roles.get(role, {}).get('permissions', [])\n"})}),"\n",(0,i.jsx)(r.h3,{id:"2-dependency-and-package-security",children:"2. Dependency and Package Security"}),"\n",(0,i.jsx)(r.h4,{id:"a-secure-dependency-management",children:"A. Secure Dependency Management"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:'# dependency_security.py\r\nimport hashlib\r\nimport requests\r\nfrom packaging.version import parse, Version\r\nfrom typing import Dict, List, Optional\r\nimport toml\r\n\r\n\r\nclass SecureDependencyManager:\r\n    """\r\n    Secure dependency management for robotics applications\r\n    """\r\n    def __init__(self):\r\n        self.vulnerability_db_url = "https://pyup.io/api/vulnerabilities/"\r\n        self.trusted_sources = [\r\n            "https://pypi.org/simple/",\r\n            "https://test.pypi.org/simple/"\r\n        ]\r\n        self.dependency_cache = {}\r\n\r\n    def verify_package_integrity(self, package_name: str, version: str, expected_hash: str) -> bool:\r\n        """\r\n        Verify package integrity using hash comparison\r\n        """\r\n        try:\r\n            # Download package info from PyPI\r\n            response = requests.get(f"https://pypi.org/pypi/{package_name}/{version}/json")\r\n            if response.status_code != 200:\r\n                return False\r\n\r\n            package_info = response.json()\r\n            download_url = None\r\n\r\n            # Find the correct download URL\r\n            for file_info in package_info[\'urls\']:\r\n                if file_info[\'filename\'].endswith((\'.whl\', \'.tar.gz\')):\r\n                    download_url = file_info[\'url\']\r\n                    break\r\n\r\n            if not download_url:\r\n                return False\r\n\r\n            # Download and hash the file\r\n            file_response = requests.get(download_url)\r\n            actual_hash = hashlib.sha256(file_response.content).hexdigest()\r\n\r\n            return actual_hash == expected_hash\r\n\r\n        except Exception as e:\r\n            print(f"Error verifying package integrity: {e}")\r\n            return False\r\n\r\n    def check_vulnerabilities(self, package_name: str, version: str) -> List[Dict[str, str]]:\r\n        """\r\n        Check for known vulnerabilities in package\r\n        """\r\n        vulnerabilities = []\r\n\r\n        try:\r\n            # Check against vulnerability database\r\n            # This is a simplified example - in practice, use a service like PyUp or Snyk\r\n            response = requests.get(f"{self.vulnerability_db_url}{package_name}/")\r\n\r\n            if response.status_code == 200:\r\n                vuln_data = response.json()\r\n\r\n                for vuln in vuln_data.get(\'vulnerabilities\', []):\r\n                    vuln_version = parse(vuln.get(\'affected_version\', \'0.0.0\'))\r\n                    if parse(version) >= vuln_version:\r\n                        vulnerabilities.append(vuln)\r\n\r\n        except Exception as e:\r\n            print(f"Error checking vulnerabilities: {e}")\r\n\r\n        return vulnerabilities\r\n\r\n    def generate_secure_requirements(self, requirements_file: str) -> str:\r\n        """\r\n        Generate secure requirements file with version pinning and hashes\r\n        """\r\n        with open(requirements_file, \'r\') as f:\r\n            lines = f.readlines()\r\n\r\n        secure_lines = []\r\n        for line in lines:\r\n            line = line.strip()\r\n            if line and not line.startswith(\'#\'):\r\n                # Parse package name and version\r\n                if \'==\' in line:\r\n                    package_name, version = line.split(\'==\')\r\n                else:\r\n                    package_name = line.split(\'>=\')[0].split(\'<=\')[0].split(\'>\')[0].split(\'<\')[0].split(\'~=\')[0]\r\n                    version = None\r\n\r\n                # Get latest secure version if not specified\r\n                if not version:\r\n                    version = self.get_latest_secure_version(package_name)\r\n\r\n                # Get hash for the specific version\r\n                package_hash = self.get_package_hash(package_name, version)\r\n\r\n                if package_hash:\r\n                    secure_lines.append(f"{package_name}=={version} --hash=sha256:{package_hash}")\r\n                else:\r\n                    secure_lines.append(f"{package_name}=={version}")\r\n\r\n        secure_requirements = "secure_requirements.txt"\r\n        with open(secure_requirements, \'w\') as f:\r\n            f.write(\'\\n\'.join(secure_lines))\r\n\r\n        return secure_requirements\r\n\r\n    def get_latest_secure_version(self, package_name: str) -> str:\r\n        """\r\n        Get the latest version without known vulnerabilities\r\n        """\r\n        try:\r\n            response = requests.get(f"https://pypi.org/pypi/{package_name}/json")\r\n            if response.status_code == 200:\r\n                data = response.json()\r\n\r\n                # Get all versions\r\n                versions = list(data[\'releases\'].keys())\r\n\r\n                # Sort versions\r\n                sorted_versions = sorted([parse(v) for v in versions], reverse=True)\r\n\r\n                # Check each version for vulnerabilities, starting from latest\r\n                for version in sorted_versions:\r\n                    vulns = self.check_vulnerabilities(package_name, str(version))\r\n                    if not vulns:  # No vulnerabilities found\r\n                        return str(version)\r\n\r\n                # If all versions have vulnerabilities, return the latest\r\n                return str(sorted_versions[0])\r\n\r\n        except Exception as e:\r\n            print(f"Error getting latest secure version: {e}")\r\n\r\n        return "latest"\r\n\r\n    def get_package_hash(self, package_name: str, version: str) -> Optional[str]:\r\n        """\r\n        Get SHA256 hash for a specific package version\r\n        """\r\n        try:\r\n            response = requests.get(f"https://pypi.org/pypi/{package_name}/{version}/json")\r\n            if response.status_code == 200:\r\n                data = response.json()\r\n\r\n                # Find the first .whl or .tar.gz file and get its hash\r\n                for file_info in data[\'urls\']:\r\n                    if file_info[\'filename\'].endswith((\'.whl\', \'.tar.gz\')):\r\n                        digests = file_info.get(\'digests\', {})\r\n                        return digests.get(\'sha256\')\r\n\r\n        except Exception as e:\r\n            print(f"Error getting package hash: {e}")\r\n\r\n        return None\n'})}),"\n",(0,i.jsx)(r.h2,{id:"hardware-security-best-practices",children:"Hardware Security Best Practices"}),"\n",(0,i.jsx)(r.h3,{id:"1-physical-security-measures",children:"1. Physical Security Measures"}),"\n",(0,i.jsx)(r.h4,{id:"a-secure-hardware-design",children:"A. Secure Hardware Design"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-yaml",children:"# hardware_security.yaml - Hardware security configuration\r\nhardware_security:\r\n  # Physical access control\r\n  physical_access:\r\n    tamper_resistant_enclosure: true\r\n    secure_boot_enabled: true\r\n    hardware_security_module: true\r\n    intrusion_detection: true\r\n\r\n  # Secure boot configuration\r\n  secure_boot:\r\n    trusted_execution_environment: true\r\n    measured_boot: true\r\n    verified_boot: true\r\n    rollback_protection: true\r\n\r\n  # Hardware security modules\r\n  hsm:\r\n    encryption_engine: true\r\n    key_storage: true\r\n    secure_element: true\r\n    random_number_generator: true\r\n\r\n  # Intrusion detection\r\n  intrusion_detection:\r\n    physical_tamper_detection: true\r\n    unauthorized_access_alerts: true\r\n    secure_storage_lock: true\r\n    biometric_access_control: false  # Enable if needed\n"})}),"\n",(0,i.jsx)(r.h3,{id:"2-firmware-security",children:"2. Firmware Security"}),"\n",(0,i.jsx)(r.h4,{id:"a-secure-firmware-updates",children:"A. Secure Firmware Updates"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:"# secure_firmware.py\r\nimport hashlib\r\nimport hmac\r\nimport struct\r\nfrom cryptography.hazmat.primitives import hashes\r\nfrom cryptography.hazmat.primitives.asymmetric import rsa, padding\r\nfrom cryptography.hazmat.primitives import serialization\r\nfrom typing import Dict, Optional, Tuple\r\nimport os\r\n\r\n\r\nclass SecureFirmwareManager:\r\n    \"\"\"\r\n    Secure firmware management system\r\n    \"\"\"\r\n    def __init__(self, private_key_path: str, public_key_path: str):\r\n        self.private_key = self._load_private_key(private_key_path)\r\n        self.public_key = self._load_public_key(public_key_path)\r\n\r\n    def _load_private_key(self, path: str) -> rsa.RSAPrivateKey:\r\n        \"\"\"\r\n        Load private key for signing\r\n        \"\"\"\r\n        with open(path, 'rb') as f:\r\n            private_key = serialization.load_pem_private_key(\r\n                f.read(),\r\n                password=None\r\n            )\r\n        return private_key\r\n\r\n    def _load_public_key(self, path: str) -> rsa.RSAPublicKey:\r\n        \"\"\"\r\n        Load public key for verification\r\n        \"\"\"\r\n        with open(path, 'rb') as f:\r\n            public_key = serialization.load_pem_public_key(f.read())\r\n        return public_key\r\n\r\n    def sign_firmware(self, firmware_path: str) -> Dict[str, bytes]:\r\n        \"\"\"\r\n        Sign firmware with digital signature\r\n        \"\"\"\r\n        with open(firmware_path, 'rb') as f:\r\n            firmware_data = f.read()\r\n\r\n        # Calculate hash of firmware\r\n        firmware_hash = hashlib.sha256(firmware_data).digest()\r\n\r\n        # Sign the hash\r\n        signature = self.private_key.sign(\r\n            firmware_hash,\r\n            padding.PKCS1v15(),\r\n            hashes.SHA256()\r\n        )\r\n\r\n        return {\r\n            'firmware_hash': firmware_hash,\r\n            'signature': signature,\r\n            'firmware_size': len(firmware_data)\r\n        }\r\n\r\n    def verify_firmware_signature(self, firmware_path: str, signature: bytes) -> bool:\r\n        \"\"\"\r\n        Verify firmware signature\r\n        \"\"\"\r\n        with open(firmware_path, 'rb') as f:\r\n            firmware_data = f.read()\r\n\r\n        # Calculate hash of received firmware\r\n        received_hash = hashlib.sha256(firmware_data).digest()\r\n\r\n        try:\r\n            # Verify signature\r\n            self.public_key.verify(\r\n                signature,\r\n                received_hash,\r\n                padding.PKCS1v15(),\r\n                hashes.SHA256()\r\n            )\r\n            return True\r\n        except Exception:\r\n            return False\r\n\r\n    def create_secure_firmware_package(self, firmware_path: str, output_path: str) -> bool:\r\n        \"\"\"\r\n        Create a secure firmware package with signature\r\n        \"\"\"\r\n        try:\r\n            # Sign the firmware\r\n            signature_data = self.sign_firmware(firmware_path)\r\n\r\n            # Create package with firmware + signature + metadata\r\n            with open(firmware_path, 'rb') as f:\r\n                firmware_data = f.read()\r\n\r\n            # Package format: [size][hash][signature][firmware_data]\r\n            size_bytes = struct.pack('<I', len(firmware_data))\r\n            package = (\r\n                size_bytes +\r\n                signature_data['firmware_hash'] +\r\n                signature_data['signature'] +\r\n                firmware_data\r\n            )\r\n\r\n            # Write secure package\r\n            with open(output_path, 'wb') as f:\r\n                f.write(package)\r\n\r\n            return True\r\n\r\n        except Exception as e:\r\n            print(f\"Error creating secure firmware package: {e}\")\r\n            return False\r\n\r\n    def validate_secure_package(self, package_path: str) -> Dict[str, bool]:\r\n        \"\"\"\r\n        Validate secure firmware package\r\n        \"\"\"\r\n        try:\r\n            with open(package_path, 'rb') as f:\r\n                package_data = f.read()\r\n\r\n            # Parse package: [size:4][hash:32][signature:256][firmware_data]\r\n            size = struct.unpack('<I', package_data[:4])[0]\r\n            firmware_hash = package_data[4:36]\r\n            signature = package_data[36:292]\r\n            firmware_data = package_data[292:]\r\n\r\n            # Verify size matches\r\n            if size != len(firmware_data):\r\n                return {'valid': False, 'reason': 'Size mismatch'}\r\n\r\n            # Verify signature\r\n            calculated_hash = hashlib.sha256(firmware_data).digest()\r\n            if calculated_hash != firmware_hash:\r\n                return {'valid': False, 'reason': 'Hash mismatch'}\r\n\r\n            # Verify signature using public key\r\n            if not self.verify_firmware_signature_from_data(firmware_data, signature):\r\n                return {'valid': False, 'reason': 'Invalid signature'}\r\n\r\n            return {'valid': True, 'reason': 'Package is valid'}\r\n\r\n        except Exception as e:\r\n            return {'valid': False, 'reason': f'Error validating package: {str(e)}'}\r\n\r\n    def verify_firmware_signature_from_data(self, firmware_data: bytes, signature: bytes) -> bool:\r\n        \"\"\"\r\n        Verify firmware signature from firmware data\r\n        \"\"\"\r\n        try:\r\n            firmware_hash = hashlib.sha256(firmware_data).digest()\r\n            self.public_key.verify(\r\n                signature,\r\n                firmware_hash,\r\n                padding.PKCS1v15(),\r\n                hashes.SHA256()\r\n            )\r\n            return True\r\n        except Exception:\r\n            return False\n"})}),"\n",(0,i.jsx)(r.h2,{id:"data-security-best-practices",children:"Data Security Best Practices"}),"\n",(0,i.jsx)(r.h3,{id:"1-data-encryption-and-privacy",children:"1. Data Encryption and Privacy"}),"\n",(0,i.jsx)(r.h4,{id:"a-data-protection-implementation",children:"A. Data Protection Implementation"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:"# data_security.py\r\nfrom cryptography.fernet import Fernet\r\nfrom cryptography.hazmat.primitives import hashes\r\nfrom cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\r\nimport base64\r\nimport os\r\nfrom typing import Dict, Any, Optional\r\nimport json\r\n\r\n\r\nclass DataSecurityManager:\r\n    \"\"\"\r\n    Data security manager for robotics applications\r\n    \"\"\"\r\n    def __init__(self):\r\n        self.key_cache = {}\r\n\r\n    def generate_key_from_password(self, password: str, salt: bytes = None) -> Tuple[bytes, bytes]:\r\n        \"\"\"\r\n        Generate encryption key from password\r\n        \"\"\"\r\n        if salt is None:\r\n            salt = os.urandom(16)\r\n\r\n        kdf = PBKDF2HMAC(\r\n            algorithm=hashes.SHA256(),\r\n            length=32,\r\n            salt=salt,\r\n            iterations=100000,\r\n        )\r\n        key = base64.urlsafe_b64encode(kdf.derive(password.encode()))\r\n        return key, salt\r\n\r\n    def encrypt_data(self, data: str, password: str) -> Dict[str, str]:\r\n        \"\"\"\r\n        Encrypt data using password-based key\r\n        \"\"\"\r\n        key, salt = self.generate_key_from_password(password)\r\n        f = Fernet(key)\r\n\r\n        encrypted_data = f.encrypt(data.encode())\r\n\r\n        return {\r\n            'encrypted_data': base64.b64encode(encrypted_data).decode(),\r\n            'salt': base64.b64encode(salt).decode()\r\n        }\r\n\r\n    def decrypt_data(self, encrypted_package: Dict[str, str], password: str) -> Optional[str]:\r\n        \"\"\"\r\n        Decrypt data using password\r\n        \"\"\"\r\n        try:\r\n            salt = base64.b64decode(encrypted_package['salt'])\r\n            encrypted_data = base64.b64decode(encrypted_package['encrypted_data'])\r\n\r\n            key, _ = self.generate_key_from_password(password, salt)\r\n            f = Fernet(key)\r\n\r\n            decrypted_data = f.decrypt(encrypted_data)\r\n            return decrypted_data.decode()\r\n        except Exception as e:\r\n            print(f\"Decryption failed: {e}\")\r\n            return None\r\n\r\n    def encrypt_robot_data(self, data: Dict[str, Any], encryption_level: str = 'medium') -> Dict[str, Any]:\r\n        \"\"\"\r\n        Encrypt sensitive robot data based on sensitivity level\r\n        \"\"\"\r\n        encrypted_data = data.copy()\r\n\r\n        # Define sensitive fields that need encryption\r\n        sensitive_fields = {\r\n            'high': ['user_credentials', 'api_keys', 'private_keys'],\r\n            'medium': ['user_data', 'location_data', 'personal_info'],\r\n            'low': ['sensor_data', 'operational_data']\r\n        }\r\n\r\n        fields_to_encrypt = sensitive_fields.get(encryption_level, [])\r\n\r\n        for field in fields_to_encrypt:\r\n            if field in encrypted_data and isinstance(encrypted_data[field], str):\r\n                encrypted_value = self.encrypt_data(encrypted_data[field], \"robot_security_key_2025\")\r\n                encrypted_data[field] = {\r\n                    'encrypted': True,\r\n                    'value': encrypted_value['encrypted_data'],\r\n                    'salt': encrypted_value['salt']\r\n                }\r\n\r\n        return encrypted_data\r\n\r\n    def create_secure_log_entry(self, log_data: Dict[str, Any]) -> str:\r\n        \"\"\"\r\n        Create a secure log entry with sensitive data protection\r\n        \"\"\"\r\n        # Remove or encrypt sensitive information\r\n        secure_log = log_data.copy()\r\n\r\n        # Sanitize sensitive fields\r\n        sensitive_keys = ['password', 'token', 'key', 'credential', 'secret']\r\n        for key in list(secure_log.keys()):\r\n            if any(sensitive in key.lower() for sensitive in sensitive_keys):\r\n                secure_log[key] = '[REDACTED]'\r\n\r\n        # Add timestamp and log level\r\n        secure_log['timestamp'] = str(log_data.get('timestamp', ''))\r\n        secure_log['level'] = log_data.get('level', 'INFO')\r\n\r\n        return json.dumps(secure_log, indent=2)\r\n\r\n    def implement_data_retention_policy(self, data_path: str, retention_days: int) -> bool:\r\n        \"\"\"\r\n        Implement data retention policy\r\n        \"\"\"\r\n        import shutil\r\n        from datetime import datetime, timedelta\r\n\r\n        try:\r\n            # Get file modification time\r\n            mod_time = datetime.fromtimestamp(os.path.getmtime(data_path))\r\n            current_time = datetime.now()\r\n\r\n            # Check if file is older than retention period\r\n            if current_time - mod_time > timedelta(days=retention_days):\r\n                # Archive or delete old data\r\n                archive_path = f\"{data_path}.archive\"\r\n                shutil.move(data_path, archive_path)\r\n                print(f\"Data archived: {archive_path}\")\r\n\r\n            return True\r\n        except Exception as e:\r\n            print(f\"Error implementing retention policy: {e}\")\r\n            return False\n"})}),"\n",(0,i.jsx)(r.h3,{id:"2-privacy-protection",children:"2. Privacy Protection"}),"\n",(0,i.jsx)(r.h4,{id:"a-privacy-enhancing-technologies",children:"A. Privacy-Enhancing Technologies"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:"# privacy_protection.py\r\nimport numpy as np\r\nfrom typing import List, Dict, Any\r\nimport random\r\n\r\n\r\nclass PrivacyProtectionSystem:\r\n    \"\"\"\r\n    Privacy protection system for robotics applications\r\n    \"\"\"\r\n    def __init__(self):\r\n        self.differential_privacy_epsilon = 1.0\r\n        self.anonymization_enabled = True\r\n\r\n    def add_differential_privacy_noise(self, data: List[float], sensitivity: float = 1.0) -> List[float]:\r\n        \"\"\"\r\n        Add differential privacy noise to data\r\n        \"\"\"\r\n        # Calculate noise scale based on epsilon and sensitivity\r\n        noise_scale = sensitivity / self.differential_privacy_epsilon\r\n\r\n        # Add Laplace noise\r\n        noisy_data = []\r\n        for value in data:\r\n            noise = np.random.laplace(0, noise_scale)\r\n            noisy_data.append(value + noise)\r\n\r\n        return noisy_data\r\n\r\n    def anonymize_sensor_data(self, sensor_data: Dict[str, Any]) -> Dict[str, Any]:\r\n        \"\"\"\r\n        Anonymize sensor data to protect privacy\r\n        \"\"\"\r\n        anonymized_data = sensor_data.copy()\r\n\r\n        # Remove or generalize location data\r\n        if 'location' in anonymized_data:\r\n            # Add noise to location coordinates\r\n            if isinstance(anonymized_data['location'], (list, tuple)) and len(anonymized_data['location']) >= 2:\r\n                lat, lon = anonymized_data['location'][0], anonymized_data['location'][1]\r\n                noise_lat = np.random.normal(0, 0.001)  # ~100m radius\r\n                noise_lon = np.random.normal(0, 0.001)\r\n                anonymized_data['location'] = [lat + noise_lat, lon + noise_lon]\r\n\r\n        # Generalize timestamp precision\r\n        if 'timestamp' in anonymized_data:\r\n            # Round to nearest minute to prevent precise tracking\r\n            timestamp = anonymized_data['timestamp']\r\n            anonymized_data['timestamp'] = timestamp - (timestamp % 60)\r\n\r\n        # Remove unique identifiers\r\n        unique_id_fields = ['user_id', 'device_id', 'session_id']\r\n        for field in unique_id_fields:\r\n            if field in anonymized_data:\r\n                anonymized_data[field] = 'ANONYMIZED'\r\n\r\n        return anonymized_data\r\n\r\n    def implement_k_anonymity(self, dataset: List[Dict[str, Any]], k: int = 5) -> List[Dict[str, Any]]:\r\n        \"\"\"\r\n        Implement k-anonymity for dataset\r\n        \"\"\"\r\n        # Generalize quasi-identifiers to achieve k-anonymity\r\n        generalized_dataset = []\r\n\r\n        for record in dataset:\r\n            generalized_record = record.copy()\r\n\r\n            # Example: Generalize age to ranges\r\n            if 'age' in generalized_record:\r\n                age = generalized_record['age']\r\n                if age < 20:\r\n                    generalized_record['age_range'] = '0-19'\r\n                elif age < 40:\r\n                    generalized_record['age_range'] = '20-39'\r\n                elif age < 60:\r\n                    generalized_record['age_range'] = '40-59'\r\n                else:\r\n                    generalized_record['age_range'] = '60+'\r\n\r\n            # Example: Generalize location to regions\r\n            if 'location' in generalized_record:\r\n                # Convert specific location to broader region\r\n                generalized_record['region'] = self._get_region_from_location(generalized_record['location'])\r\n\r\n            generalized_dataset.append(generalized_record)\r\n\r\n        return generalized_dataset\r\n\r\n    def _get_region_from_location(self, location: Any) -> str:\r\n        \"\"\"\r\n        Convert specific location to broader region\r\n        \"\"\"\r\n        # This would typically use a geocoding service\r\n        # For this example, return a generic region\r\n        return \"ANONYMIZED_REGION\"\r\n\r\n    def facial_blurring_simulation(self, image_data: List[List[int]]) -> List[List[int]]:\r\n        \"\"\"\r\n        Simulate facial blurring for privacy protection\r\n        \"\"\"\r\n        # This is a simplified simulation\r\n        # In practice, use computer vision libraries like OpenCV\r\n        blurred_image = [row[:] for row in image_data]  # Deep copy\r\n\r\n        # Simulate blurring by averaging pixel values in blocks\r\n        block_size = 8\r\n        height, width = len(image_data), len(image_data[0])\r\n\r\n        for i in range(0, height, block_size):\r\n            for j in range(0, width, block_size):\r\n                # Calculate average value for the block\r\n                block_sum = 0\r\n                count = 0\r\n                for bi in range(block_size):\r\n                    for bj in range(block_size):\r\n                        if i + bi < height and j + bj < width:\r\n                            block_sum += image_data[i + bi][j + bj]\r\n                            count += 1\r\n\r\n                if count > 0:\r\n                    avg_value = block_sum // count\r\n                    # Apply average value to the entire block\r\n                    for bi in range(block_size):\r\n                        for bj in range(block_size):\r\n                            if i + bi < height and j + bj < width:\r\n                                blurred_image[i + bi][j + bj] = avg_value\r\n\r\n        return blurred_image\n"})}),"\n",(0,i.jsx)(r.h2,{id:"security-monitoring-and-incident-response",children:"Security Monitoring and Incident Response"}),"\n",(0,i.jsx)(r.h3,{id:"1-security-monitoring-system",children:"1. Security Monitoring System"}),"\n",(0,i.jsx)(r.h4,{id:"a-security-event-monitoring",children:"A. Security Event Monitoring"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:"# security_monitoring.py\r\nimport time\r\nimport json\r\nfrom datetime import datetime\r\nfrom typing import Dict, List, Any\r\nimport logging\r\n\r\n\r\nclass SecurityMonitoringSystem:\r\n    \"\"\"\r\n    Security monitoring system for robotics applications\r\n    \"\"\"\r\n    def __init__(self):\r\n        self.security_events = []\r\n        self.alert_thresholds = {\r\n            'failed_login_attempts': 5,\r\n            'unauthorized_access_attempts': 3,\r\n            'network_anomalies': 10,\r\n            'data_access_violations': 2\r\n        }\r\n        self.security_log = []\r\n\r\n        # Setup logging\r\n        logging.basicConfig(\r\n            level=logging.INFO,\r\n            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\r\n            handlers=[\r\n                logging.FileHandler('security.log'),\r\n                logging.StreamHandler()\r\n            ]\r\n        )\r\n        self.logger = logging.getLogger('RobotSecurity')\r\n\r\n    def log_security_event(self, event_type: str, details: Dict[str, Any], severity: str = 'INFO'):\r\n        \"\"\"\r\n        Log security event\r\n        \"\"\"\r\n        event = {\r\n            'timestamp': datetime.now().isoformat(),\r\n            'event_type': event_type,\r\n            'details': details,\r\n            'severity': severity\r\n        }\r\n\r\n        self.security_events.append(event)\r\n        self.security_log.append(event)\r\n\r\n        # Log to file\r\n        self.logger.log(\r\n            getattr(logging, severity.upper(), logging.INFO),\r\n            f\"Security Event: {event_type} - {details}\"\r\n        )\r\n\r\n        # Check for alerts\r\n        self._check_for_alerts(event)\r\n\r\n    def _check_for_alerts(self, event: Dict[str, Any]):\r\n        \"\"\"\r\n        Check if event triggers security alert\r\n        \"\"\"\r\n        # Count recent events of same type\r\n        recent_events = [\r\n            e for e in self.security_events\r\n            if e['event_type'] == event['event_type']\r\n            and (datetime.now() - datetime.fromisoformat(e['timestamp'])).seconds < 300  # 5 minutes\r\n        ]\r\n\r\n        threshold = self.alert_thresholds.get(event['event_type'], 10)\r\n        if len(recent_events) >= threshold:\r\n            self._trigger_security_alert(event['event_type'], len(recent_events))\r\n\r\n    def _trigger_security_alert(self, event_type: str, count: int):\r\n        \"\"\"\r\n        Trigger security alert\r\n        \"\"\"\r\n        alert = {\r\n            'timestamp': datetime.now().isoformat(),\r\n            'alert_type': 'SECURITY_BREACH_POSSIBLE',\r\n            'event_type': event_type,\r\n            'count': count,\r\n            'action_required': 'INVESTIGATE_IMMEDIATELY'\r\n        }\r\n\r\n        self.logger.critical(f\"SECURITY ALERT: {event_type} occurred {count} times recently\")\r\n\r\n        # In a real system, this would trigger notifications, etc.\r\n        print(f\"\ud83d\udea8 SECURITY ALERT: {json.dumps(alert, indent=2)}\")\r\n\r\n    def monitor_network_traffic(self) -> Dict[str, Any]:\r\n        \"\"\"\r\n        Monitor network traffic for anomalies\r\n        \"\"\"\r\n        # This would integrate with network monitoring tools\r\n        # For this example, return simulated data\r\n        return {\r\n            'timestamp': datetime.now().isoformat(),\r\n            'traffic_volume': random.randint(100, 1000),\r\n            'connection_count': random.randint(1, 20),\r\n            'anomaly_detected': random.random() < 0.1  # 10% chance of anomaly\r\n        }\r\n\r\n    def monitor_system_integrity(self) -> Dict[str, Any]:\r\n        \"\"\"\r\n        Monitor system integrity\r\n        \"\"\"\r\n        # Check for unauthorized file changes, running processes, etc.\r\n        # For this example, return simulated data\r\n        return {\r\n            'timestamp': datetime.now().isoformat(),\r\n            'files_changed': 0,\r\n            'unauthorized_processes': 0,\r\n            'system_integrity': 'OK'\r\n        }\r\n\r\n    def generate_security_report(self) -> str:\r\n        \"\"\"\r\n        Generate security report\r\n        \"\"\"\r\n        report = f\"\"\"\r\n# Security Report - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\r\n\r\n## Summary\r\n- Total Security Events: {len(self.security_events)}\r\n- Security Alerts Triggered: {len([e for e in self.security_events if e['severity'] == 'CRITICAL'])}\r\n- Monitoring Period: Last 24 hours\r\n\r\n## Recent Events\r\n\"\"\"\r\n\r\n        recent_events = [\r\n            e for e in self.security_events\r\n            if (datetime.now() - datetime.fromisoformat(e['timestamp'])).days < 1\r\n        ][:10]  # Last 10 events\r\n\r\n        for event in recent_events:\r\n            report += f\"- {event['timestamp']}: {event['event_type']} ({event['severity']})\\n\"\r\n\r\n        report += f\"\"\"\r\n## Security Status\r\n- Network Security: {'MONITORED' if any('network' in e['event_type'] for e in recent_events) else 'OK'}\r\n- Access Control: {'ACTIVE' if any('login' in e['event_type'] for e in recent_events) else 'OK'}\r\n- Data Protection: {'ACTIVE' if any('data' in e['event_type'] for e in recent_events) else 'OK'}\r\n\r\n## Recommendations\r\n\"\"\"\r\n\r\n        if any(e['severity'] == 'CRITICAL' for e in recent_events):\r\n            report += \"- Immediate security review required\\n\"\r\n        if any('anomaly' in e['event_type'] for e in recent_events):\r\n            report += \"- Investigate network anomalies\\n\"\r\n\r\n        report += \"- Continue regular security monitoring\\n\"\r\n\r\n        return report\n"})}),"\n",(0,i.jsx)(r.p,{children:"This comprehensive security best practices guide covers all major aspects of security for robotics applications, including network security, software security, hardware security, data security, and monitoring. It provides practical examples and implementation guidance for securing robotics systems throughout the Physical AI and Humanoid Robotics curriculum."})]})}function u(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);