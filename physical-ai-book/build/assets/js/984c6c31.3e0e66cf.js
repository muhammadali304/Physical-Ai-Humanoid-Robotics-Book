"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[2426],{3339:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"isaac-platform/perception-navigation-integration","title":"Perception Pipeline Integration with Navigation System","description":"Overview","source":"@site/docs/isaac-platform/perception-navigation-integration.md","sourceDirName":"isaac-platform","slug":"/isaac-platform/perception-navigation-integration","permalink":"/./docs/isaac-platform/perception-navigation-integration","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/isaac-platform/perception-navigation-integration.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Path Execution Controller for Robot Movement","permalink":"/./docs/isaac-platform/path-execution-controller"},"next":{"title":"Isaac Navigation - Autonomous Navigation and Path Planning","permalink":"/./docs/isaac-platform/navigation"}}');var a=r(4848),i=r(7074);const s={},o="Perception Pipeline Integration with Navigation System",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Understanding Perception-Navigation Integration",id:"understanding-perception-navigation-integration",level:2},{value:"Key Integration Points",id:"key-integration-points",level:3},{value:"Benefits of Integration",id:"benefits-of-integration",level:3},{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"1. High-Level Integration Architecture",id:"1-high-level-integration-architecture",level:3},{value:"Integration Implementation",id:"integration-implementation",level:2},{value:"1. Perception-Enhanced Costmap Configuration",id:"1-perception-enhanced-costmap-configuration",level:3},{value:"2. Perception-Enhanced Localization Configuration",id:"2-perception-enhanced-localization-configuration",level:3},{value:"3. Perception-Enhanced Controller Configuration",id:"3-perception-enhanced-controller-configuration",level:3},{value:"Custom Integration Nodes",id:"custom-integration-nodes",level:2},{value:"1. Perception-Navigation Bridge Node",id:"1-perception-navigation-bridge-node",level:3},{value:"2. Semantic Navigation Node",id:"2-semantic-navigation-node",level:3},{value:"Launch Files for Integration",id:"launch-files-for-integration",level:2},{value:"1. Complete Integration Launch File",id:"1-complete-integration-launch-file",level:3},{value:"Performance Optimization for Integration",id:"performance-optimization-for-integration",level:2},{value:"1. Optimized Integration Configuration",id:"1-optimized-integration-configuration",level:3},{value:"2. Memory and Computation Optimization",id:"2-memory-and-computation-optimization",level:3},{value:"Quality Assurance and Testing",id:"quality-assurance-and-testing",level:2},{value:"1. Integration Testing Framework",id:"1-integration-testing-framework",level:3},{value:"Troubleshooting Integration Issues",id:"troubleshooting-integration-issues",level:2},{value:"1. Common Integration Problems and Solutions",id:"1-common-integration-problems-and-solutions",level:3},{value:"Issue: Perception data not affecting navigation",id:"issue-perception-data-not-affecting-navigation",level:4},{value:"Issue: High CPU usage with integration",id:"issue-high-cpu-usage-with-integration",level:4},{value:"Issue: Navigation conflicts with perception",id:"issue-navigation-conflicts-with-perception",level:4},{value:"2. Performance Monitoring",id:"2-performance-monitoring",level:3},{value:"Best Practices for Integration",id:"best-practices-for-integration",level:2},{value:"1. Design Guidelines",id:"1-design-guidelines",level:3},{value:"2. Testing Strategies",id:"2-testing-strategies",level:3},{value:"3. Performance Optimization",id:"3-performance-optimization",level:3},{value:"Resources",id:"resources",level:2},{value:"Conclusion",id:"conclusion",level:2}];function _(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"perception-pipeline-integration-with-navigation-system",children:"Perception Pipeline Integration with Navigation System"})}),"\n",(0,a.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(n.p,{children:"This guide provides comprehensive instructions for integrating Isaac ROS perception pipelines with Navigation2. The integration enables robots to use visual and sensor data for enhanced navigation, including dynamic obstacle detection, semantic mapping, and visual-inertial odometry for improved localization."}),"\n",(0,a.jsx)(n.h2,{id:"understanding-perception-navigation-integration",children:"Understanding Perception-Navigation Integration"}),"\n",(0,a.jsx)(n.h3,{id:"key-integration-points",children:"Key Integration Points"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Sensor Data Integration"}),": Feeding perception outputs to costmaps"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Localization Enhancement"}),": Using visual data to improve pose estimation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Dynamic Obstacle Detection"}),": Real-time detection and avoidance of moving objects"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Semantic Navigation"}),": Using object recognition for intelligent navigation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Visual-Inertial Odometry"}),": Enhanced motion estimation using visual data"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"benefits-of-integration",children:"Benefits of Integration"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Improved obstacle detection and classification"}),"\n",(0,a.jsx)(n.li,{children:"Enhanced navigation in dynamic environments"}),"\n",(0,a.jsx)(n.li,{children:"Better localization accuracy"}),"\n",(0,a.jsx)(n.li,{children:"Semantic-aware path planning"}),"\n",(0,a.jsx)(n.li,{children:"Robust operation in challenging conditions"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,a.jsx)(n.h3,{id:"1-high-level-integration-architecture",children:"1. High-Level Integration Architecture"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Isaac ROS Perception Pipeline\r\n\u251c\u2500\u2500 Visual SLAM \u2192 Pose/Odometry \u2192 AMCL/Localization\r\n\u251c\u2500\u2500 Stereo Processing \u2192 Depth \u2192 Costmap Obstacle Layer\r\n\u251c\u2500\u2500 Semantic Segmentation \u2192 Object Classification \u2192 Semantic Costmap\r\n\u251c\u2500\u2500 Object Detection \u2192 Dynamic Objects \u2192 Dynamic Obstacle Layer\r\n\u2514\u2500\u2500 IMU Integration \u2192 Visual-Inertial Odometry \u2192 Controller\r\n\r\nNavigation2 Stack\r\n\u251c\u2500\u2500 Global Planner (uses semantic map)\r\n\u251c\u2500\u2500 Local Planner (uses perception-enhanced costmaps)\r\n\u251c\u2500\u2500 Controller (uses enhanced localization)\r\n\u2514\u2500\u2500 Behavior Trees (uses semantic information)\n"})}),"\n",(0,a.jsx)(n.h2,{id:"integration-implementation",children:"Integration Implementation"}),"\n",(0,a.jsx)(n.h3,{id:"1-perception-enhanced-costmap-configuration",children:"1. Perception-Enhanced Costmap Configuration"}),"\n",(0,a.jsxs)(n.p,{children:["Create a configuration file ",(0,a.jsx)(n.code,{children:"perception_costmap_config.yaml"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'# Perception-enhanced costmap configuration\r\nglobal_costmap:\r\n  global_costmap:\r\n    ros__parameters:\r\n      update_frequency: 0.5\r\n      publish_frequency: 0.5\r\n      transform_tolerance: 1.0\r\n      use_sim_time: false\r\n\r\n      global_frame: map\r\n      robot_base_frame: base_link\r\n      robot_radius: 0.22\r\n      resolution: 0.05\r\n\r\n      plugins: [\r\n        "static_layer",\r\n        "obstacle_layer",\r\n        "isaac_perception_layer",\r\n        "semantic_layer",\r\n        "inflation_layer"\r\n      ]\r\n\r\n      static_layer:\r\n        plugin: "nav2_costmap_2d::StaticLayer"\r\n        map_subscribe_transient_local: True\r\n        transform_tolerance: 1.0\r\n\r\n      obstacle_layer:\r\n        plugin: "nav2_costmap_2d::ObstacleLayer"\r\n        enabled: True\r\n        observation_sources: scan\r\n        scan:\r\n          topic: /scan\r\n          max_obstacle_height: 2.0\r\n          clearing: True\r\n          marking: True\r\n          data_type: "LaserScan"\r\n          raytrace_max_range: 5.0\r\n          raytrace_min_range: 0.0\r\n          obstacle_max_range: 4.0\r\n          obstacle_min_range: 0.0\r\n\r\n      # Isaac ROS perception layer\r\n      isaac_perception_layer:\r\n        plugin: "nav2_isaac_perception_layer/IsaacPerceptionLayer"\r\n        enabled: True\r\n        observation_sources: stereo_depth segmentation\r\n        stereo_depth:\r\n          topic: /stereo/depth/disparity\r\n          sensor_frame: stereo_camera_link\r\n          data_type: "Disparity"\r\n          clearing: True\r\n          marking: True\r\n          obstacle_range: 3.0\r\n          raytrace_range: 4.0\r\n        segmentation:\r\n          topic: /segmentation/segmentation_map\r\n          sensor_frame: camera_link\r\n          data_type: "Image"\r\n          clearing: False\r\n          marking: True\r\n          obstacle_value: 254\r\n          free_space_value: 0\r\n\r\n      # Semantic layer for object classification\r\n      semantic_layer:\r\n        plugin: "nav2_semantic_costmap_layer/SemanticLayer"\r\n        enabled: True\r\n        observation_sources: semantic_input\r\n        semantic_input:\r\n          topic: /semantic_segmentation/output\r\n          sensor_frame: camera_frame\r\n          data_type: "Image"\r\n          clearing: False\r\n          marking: True\r\n          class_mappings:\r\n            - {class_id: 0, class_name: "free_space", cost: 0, is_obstacle: false}\r\n            - {class_id: 1, class_name: "wall", cost: 254, is_obstacle: true}\r\n            - {class_id: 2, class_name: "person", cost: 200, is_obstacle: true}\r\n            - {class_id: 3, class_name: "furniture", cost: 254, is_obstacle: true}\r\n            - {class_id: 4, class_name: "plant", cost: 100, is_obstacle: true}\r\n            - {class_id: 5, class_name: "clutter", cost: 150, is_obstacle: true}\r\n\r\n      inflation_layer:\r\n        plugin: "nav2_costmap_2d::InflationLayer"\r\n        cost_scaling_factor: 5.0\r\n        inflation_radius: 0.8\r\n        inflate_unknown: False\r\n\r\n  global_costmap_client:\r\n    ros__parameters:\r\n      use_sim_time: false\r\n  global_costmap_rclcpp_node:\r\n    ros__parameters:\r\n      use_sim_time: false\r\n\r\nlocal_costmap:\r\n  local_costmap:\r\n    ros__parameters:\r\n      update_frequency: 10.0\r\n      publish_frequency: 5.0\r\n      transform_tolerance: 0.2\r\n      use_sim_time: false\r\n\r\n      global_frame: odom\r\n      robot_base_frame: base_link\r\n      robot_radius: 0.22\r\n      resolution: 0.025\r\n\r\n      rolling_window: true\r\n      width: 6\r\n      height: 6\r\n      origin_x: -3.0\r\n      origin_y: -3.0\r\n\r\n      plugins: [\r\n        "voxel_layer",\r\n        "isaac_perception_layer",\r\n        "dynamic_object_layer",\r\n        "inflation_layer"\r\n      ]\r\n\r\n      voxel_layer:\r\n        plugin: "nav2_costmap_2d::VoxelLayer"\r\n        enabled: True\r\n        publish_voxel_map: True\r\n        origin_z: 0.0\r\n        z_resolution: 0.05\r\n        z_voxels: 16\r\n        max_obstacle_height: 2.0\r\n        mark_threshold: 0\r\n        observation_sources: scan\r\n        scan:\r\n          topic: /scan\r\n          max_obstacle_height: 2.0\r\n          clearing: True\r\n          marking: True\r\n          data_type: "LaserScan"\r\n          raytrace_max_range: 5.0\r\n          raytrace_min_range: 0.0\r\n          obstacle_max_range: 4.0\r\n          obstacle_min_range: 0.0\r\n\r\n      # Isaac ROS perception layer for local costmap\r\n      isaac_perception_layer:\r\n        plugin: "nav2_isaac_perception_layer/IsaacPerceptionLayer"\r\n        enabled: True\r\n        observation_sources: stereo_depth segmentation\r\n        stereo_depth:\r\n          topic: /stereo/depth/disparity\r\n          sensor_frame: stereo_camera_link\r\n          data_type: "Disparity"\r\n          clearing: True\r\n          marking: True\r\n        segmentation:\r\n          topic: /segmentation/segmentation_map\r\n          sensor_frame: camera_link\r\n          data_type: "Image"\r\n          clearing: False\r\n          marking: True\r\n\r\n      # Dynamic object layer for moving obstacles\r\n      dynamic_object_layer:\r\n        plugin: "nav2_dynamic_obstacles_layer/DynamicObstaclesLayer"\r\n        enabled: True\r\n        observation_sources: dynamic_objects\r\n        dynamic_objects:\r\n          topic: /dynamic_objects\r\n          sensor_frame: base_link\r\n          data_type: "PointCloud2"\r\n          clearing: True\r\n          marking: True\r\n          obstacle_value: 254\r\n          free_space_value: 0\r\n\r\n      inflation_layer:\r\n        plugin: "nav2_costmap_2d::InflationLayer"\r\n        cost_scaling_factor: 8.0\r\n        inflation_radius: 0.6\r\n        inflate_unknown: False\r\n\r\n  local_costmap_client:\r\n    ros__parameters:\r\n      use_sim_time: false\r\n  local_costmap_rclcpp_node:\r\n    ros__parameters:\r\n      use_sim_time: false\n'})}),"\n",(0,a.jsx)(n.h3,{id:"2-perception-enhanced-localization-configuration",children:"2. Perception-Enhanced Localization Configuration"}),"\n",(0,a.jsxs)(n.p,{children:["Create a localization configuration file ",(0,a.jsx)(n.code,{children:"perception_localization.yaml"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'# Perception-enhanced localization configuration\r\namcl:\r\n  ros__parameters:\r\n    use_sim_time: false\r\n    alpha1: 0.2\r\n    alpha2: 0.2\r\n    alpha3: 0.2\r\n    alpha4: 0.2\r\n    alpha5: 0.2\r\n    base_frame_id: "base_link"\r\n    beam_skip_distance: 0.5\r\n    beam_skip_error_threshold: 0.9\r\n    beam_skip_threshold: 0.3\r\n    do_beamskip: false\r\n    global_frame_id: "map"\r\n    lambda_short: 0.1\r\n    laser_likelihood_max_dist: 2.0\r\n    laser_max_range: 100.0\r\n    laser_min_range: -1.0\r\n    laser_model_type: "likelihood_field"\r\n    max_beams: 60\r\n    max_particles: 2000\r\n    min_particles: 500\r\n    odom_frame_id: "odom"\r\n    pf_err: 0.05\r\n    pf_z: 0.99\r\n    recovery_alpha_fast: 0.0\r\n    recovery_alpha_slow: 0.0\r\n    resample_interval: 1\r\n    robot_model_type: "nav2_amcl::DifferentialMotionModel"\r\n    save_pose_rate: 0.5\r\n    sigma_hit: 0.2\r\n    tf_broadcast: true\r\n    transform_tolerance: 1.0\r\n    update_min_a: 0.2\r\n    update_min_d: 0.25\r\n    z_hit: 0.5\r\n    z_max: 0.05\r\n    z_rand: 0.5\r\n    z_short: 0.05\r\n    scan_topic: scan\r\n\r\n# Robot localization for visual-inertial fusion\r\nrobot_localization:\r\n  ros__parameters:\r\n    # Visual SLAM as primary pose source\r\n    pose0: /visual_slam/odometry\r\n    pose0_config: [true, true, false,    # x, y, no z\r\n                   false, false, true,   # no roll, pitch, yes yaw\r\n                   false, false, false]  # no linear/angular velocity\r\n    pose0_differential: false\r\n    pose0_relative: false\r\n\r\n    # Wheel odometry for local motion\r\n    twist0: /wheel/odometry\r\n    twist0_config: [false, false, false,  # no position\r\n                    false, false, false,  # no orientation\r\n                    true, true, true]     # linear velocity x,y,z\r\n    twist0_differential: false\r\n    twist0_relative: false\r\n\r\n    # IMU for orientation\r\n    imu0: /imu/data\r\n    imu0_config: [false, false, false,    # no position\r\n                  true, true, true,       # orientation x,y,z\r\n                  false, false, false]    # no angular velocity/linear acceleration\r\n    imu0_differential: false\r\n    imu0_relative: false\r\n    imu0_remove_gravitational_acceleration: true\r\n\r\n    # Fusion parameters\r\n    frequency: 50.0\r\n    sensor_timeout: 0.1\r\n    two_d_mode: true\r\n    transform_time_offset: 0.0\r\n    transform_timeout: 0.0\r\n    print_diagnostics: false\r\n\r\n    # Process noise\r\n    process_noise_covariance: [0.05, 0.0,    0.0,    0.0,    0.0,    0.0,\r\n                              0.0,    0.05, 0.0,    0.0,    0.0,    0.0,\r\n                              0.0,    0.0,    0.06, 0.0,    0.0,    0.0,\r\n                              0.0,    0.0,    0.0,    0.03, 0.0,    0.0,\r\n                              0.0,    0.0,    0.0,    0.0,    0.03, 0.0,\r\n                              0.0,    0.0,    0.0,    0.0,    0.0,    0.06]\r\n\r\n    # Initial estimate covariance\r\n    initial_estimate_covariance: [0.1, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n                                 0.0, 0.1, 0.0, 0.0, 0.0, 0.0,\r\n                                 0.0, 0.0, 0.1, 0.0, 0.0, 0.0,\r\n                                 0.0, 0.0, 0.0, 0.05, 0.0, 0.0,\r\n                                 0.0, 0.0, 0.0, 0.0, 0.05, 0.0,\r\n                                 0.0, 0.0, 0.0, 0.0, 0.0, 0.05]\n'})}),"\n",(0,a.jsx)(n.h3,{id:"3-perception-enhanced-controller-configuration",children:"3. Perception-Enhanced Controller Configuration"}),"\n",(0,a.jsx)(n.p,{children:"Create a controller configuration with perception feedback:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'controller_server:\r\n  ros__parameters:\r\n    use_sim_time: false\r\n    controller_frequency: 30.0  # Higher for perception integration\r\n    min_x_velocity_threshold: 0.001\r\n    min_y_velocity_threshold: 0.001\r\n    min_theta_velocity_threshold: 0.001\r\n    failure_tolerance: 0.3\r\n    progress_checker_plugin: "perception_progress_checker"\r\n    goal_checker_plugins: ["perception_goal_checker"]\r\n    controller_plugins: ["PerceptionAwareController", "BackupController"]\r\n\r\n    # Perception-aware progress checker\r\n    perception_progress_checker:\r\n      plugin: "nav2_controller::PerceptionProgressChecker"\r\n      required_movement_radius: 0.3\r\n      movement_time_allowance: 5.0\r\n      visual_confidence_threshold: 0.6\r\n\r\n    # Perception-aware goal checker\r\n    perception_goal_checker:\r\n      plugin: "nav2_controller::PerceptionGoalChecker"\r\n      xy_goal_tolerance: 0.2\r\n      yaw_goal_tolerance: 0.2\r\n      stateful: True\r\n      visual_alignment_tolerance: 0.3\r\n\r\n    # Main perception-aware controller\r\n    PerceptionAwareController:\r\n      plugin: "dwb_core::DWBLocalPlanner"\r\n      debug_trajectory_details: False\r\n      min_vel_x: 0.05\r\n      min_vel_y: 0.0\r\n      max_vel_x: 0.6\r\n      max_vel_y: 0.0\r\n      max_vel_theta: 1.5\r\n      min_speed_xy: 0.05\r\n      max_speed_xy: 0.6\r\n      min_speed_theta: 0.1\r\n      acc_lim_x: 2.0\r\n      acc_lim_y: 0.0\r\n      acc_lim_theta: 3.0\r\n      decel_lim_x: -2.0\r\n      decel_lim_y: 0.0\r\n      decel_lim_theta: -3.0\r\n      vx_samples: 25\r\n      vy_samples: 5\r\n      vtheta_samples: 25\r\n      sim_time: 1.8\r\n      linear_granularity: 0.04\r\n      angular_granularity: 0.02\r\n      transform_tolerance: 0.1\r\n      xy_goal_tolerance: 0.2\r\n      yaw_goal_tolerance: 0.2\r\n      stateful: True\r\n      restore_defaults: False\r\n      publish_cost_grid_pc: False\r\n      use_dwb: True\r\n      max_vel_obstacle: 1.8\r\n      # Perception-specific parameters\r\n      perception_weight: 0.7\r\n      visual_inertial_fusion: true\r\n      dynamic_object_aware: true\r\n\r\n    # Backup controller for emergency situations\r\n    BackupController:\r\n      plugin: "nav2_controller::BackUpController"\r\n      min_vel_x: -0.2\r\n      max_vel_x: -0.1\r\n      acc_lim_x: 1.0\r\n      decel_lim_x: -1.0\r\n      sim_time: 1.0\r\n      vx_samples: 10\r\n      tolerance: 0.1\r\n      threshold_to_rotate: 0.2\n'})}),"\n",(0,a.jsx)(n.h2,{id:"custom-integration-nodes",children:"Custom Integration Nodes"}),"\n",(0,a.jsx)(n.h3,{id:"1-perception-navigation-bridge-node",children:"1. Perception-Navigation Bridge Node"}),"\n",(0,a.jsx)(n.p,{children:"Create a bridge node that connects perception outputs to navigation inputs:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n"""\r\nPerception-Navigation Integration Bridge\r\n"""\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import Image, PointCloud2, LaserScan\r\nfrom geometry_msgs.msg import Twist, PoseWithCovarianceStamped\r\nfrom visualization_msgs.msg import MarkerArray\r\nfrom std_msgs.msg import Header\r\nfrom builtin_interfaces.msg import Duration\r\nimport numpy as np\r\nfrom tf2_ros import TransformException\r\nfrom tf2_ros.buffer import Buffer\r\nfrom tf2_ros.transform_listener import TransformListener\r\n\r\n\r\nclass PerceptionNavigationBridge(Node):\r\n    def __init__(self):\r\n        super().__init__(\'perception_navigation_bridge\')\r\n\r\n        # Parameters\r\n        self.declare_parameter(\'perception_timeout\', 1.0)\r\n        self.declare_parameter(\'dynamic_object_threshold\', 0.5)\r\n        self.declare_parameter(\'semantic_confidence_threshold\', 0.7)\r\n\r\n        self.perception_timeout = self.get_parameter(\'perception_timeout\').value\r\n        self.dynamic_threshold = self.get_parameter(\'dynamic_object_threshold\').value\r\n        self.confidence_threshold = self.get_parameter(\'semantic_confidence_threshold\').value\r\n\r\n        # TF buffer for coordinate transformations\r\n        self.tf_buffer = Buffer()\r\n        self.tf_listener = TransformListener(self.tf_buffer, self)\r\n\r\n        # Perception input topics\r\n        self.semantic_sub = self.create_subscription(\r\n            Image, \'/segmentation/segmentation_map\', self.semantic_callback, 10)\r\n        self.dynamic_obj_sub = self.create_subscription(\r\n            MarkerArray, \'/dynamic_objects\', self.dynamic_objects_callback, 10)\r\n        self.stereo_depth_sub = self.create_subscription(\r\n            Image, \'/stereo/depth/disparity\', self.stereo_depth_callback, 10)\r\n\r\n        # Navigation output topics\r\n        self.dynamic_costmap_pub = self.create_publisher(\r\n            PointCloud2, \'/local_costmap/dynamic_layer/clearing_endpoints\', 10)\r\n        self.semantic_costmap_pub = self.create_publisher(\r\n            Image, \'/semantic_costmap_input\', 10)\r\n        self.perception_status_pub = self.create_publisher(\r\n            Header, \'/perception_navigation_status\', 10)\r\n\r\n        # Internal state\r\n        self.last_perception_time = self.get_clock().now()\r\n        self.dynamic_objects = []\r\n        self.semantic_map = None\r\n        self.stereo_depth = None\r\n\r\n        # Timer for periodic processing\r\n        self.process_timer = self.create_timer(0.1, self.process_perception_data)\r\n\r\n        self.get_logger().info(\'Perception-Navigation Bridge initialized\')\r\n\r\n    def semantic_callback(self, msg):\r\n        """Process semantic segmentation data"""\r\n        self.semantic_map = msg\r\n        self.last_perception_time = self.get_clock().now()\r\n        self.get_logger().debug(\'Received semantic segmentation data\')\r\n\r\n    def dynamic_objects_callback(self, msg):\r\n        """Process dynamic object detections"""\r\n        self.dynamic_objects = msg.markers\r\n        self.last_perception_time = self.get_clock().now()\r\n        self.get_logger().debug(f\'Received {len(msg.markers)} dynamic objects\')\r\n\r\n    def stereo_depth_callback(self, msg):\r\n        """Process stereo depth data"""\r\n        self.stereo_depth = msg\r\n        self.last_perception_time = self.get_clock().now()\r\n        self.get_logger().debug(\'Received stereo depth data\')\r\n\r\n    def process_perception_data(self):\r\n        """Process perception data and publish to navigation system"""\r\n        current_time = self.get_clock().now()\r\n\r\n        # Check if perception data is still valid\r\n        if (current_time - self.last_perception_time).nanoseconds / 1e9 > self.perception_timeout:\r\n            self.get_logger().warn(\'Perception data timeout, navigation may be degraded\')\r\n            return\r\n\r\n        # Process dynamic objects for costmap\r\n        if self.dynamic_objects:\r\n            self.publish_dynamic_objects_to_costmap()\r\n\r\n        # Process semantic data for semantic costmap\r\n        if self.semantic_map:\r\n            self.publish_semantic_to_costmap()\r\n\r\n        # Process stereo depth for obstacle layer\r\n        if self.stereo_depth:\r\n            self.publish_depth_to_costmap()\r\n\r\n        # Publish status\r\n        status_msg = Header()\r\n        status_msg.stamp = current_time.to_msg()\r\n        status_msg.frame_id = "perception_active"\r\n        self.perception_status_pub.publish(status_msg)\r\n\r\n    def publish_dynamic_objects_to_costmap(self):\r\n        """Convert dynamic objects to costmap-compatible format"""\r\n        # Create point cloud from dynamic objects\r\n        points = []\r\n        for obj in self.dynamic_objects:\r\n            if obj.type == 1:  # Sphere type\r\n                # Check if object is moving (dynamic)\r\n                if self.is_moving_object(obj):\r\n                    points.append([obj.pose.position.x, obj.pose.position.y, obj.pose.position.z])\r\n\r\n        if points:\r\n            # Convert to PointCloud2 message\r\n            pc2_msg = self.create_pointcloud2(points, "odom")\r\n            self.dynamic_costmap_pub.publish(pc2_msg)\r\n\r\n    def is_moving_object(self, marker):\r\n        """Determine if a detected object is moving"""\r\n        # In a real implementation, this would check object velocity\r\n        # For now, we\'ll assume all detected objects are potentially dynamic\r\n        return True\r\n\r\n    def publish_semantic_to_costmap(self):\r\n        """Publish semantic data to semantic costmap layer"""\r\n        # In a real implementation, this would convert semantic segmentation\r\n        # to a format compatible with semantic costmap layer\r\n        # For now, we just republish the semantic map\r\n        self.semantic_costmap_pub.publish(self.semantic_map)\r\n\r\n    def publish_depth_to_costmap(self):\r\n        """Convert depth data to costmap-compatible format"""\r\n        # Process depth image and convert to obstacle points\r\n        # This would typically involve:\r\n        # 1. Converting disparity to depth\r\n        # 2. Transforming to costmap frame\r\n        # 3. Creating obstacle points\r\n        pass\r\n\r\n    def create_pointcloud2(self, points, frame_id):\r\n        """Create a PointCloud2 message from a list of points"""\r\n        from sensor_msgs.msg import PointCloud2, PointField\r\n        import struct\r\n\r\n        # Create PointCloud2 message\r\n        pc2_msg = PointCloud2()\r\n        pc2_msg.header = Header()\r\n        pc2_msg.header.stamp = self.get_clock().now().to_msg()\r\n        pc2_msg.header.frame_id = frame_id\r\n        pc2_msg.height = 1\r\n        pc2_msg.width = len(points)\r\n        pc2_msg.is_dense = False\r\n        pc2_msg.is_bigendian = False\r\n\r\n        # Define point fields\r\n        pc2_msg.fields = [\r\n            PointField(name=\'x\', offset=0, datatype=PointField.FLOAT32, count=1),\r\n            PointField(name=\'y\', offset=4, datatype=PointField.FLOAT32, count=1),\r\n            PointField(name=\'z\', offset=8, datatype=PointField.FLOAT32, count=1)\r\n        ]\r\n\r\n        pc2_msg.point_step = 12  # 3 floats * 4 bytes\r\n        pc2_msg.row_step = pc2_msg.point_step * pc2_msg.width\r\n\r\n        # Pack the data\r\n        data = []\r\n        for point in points:\r\n            data.append(struct.pack(\'fff\', point[0], point[1], point[2]))\r\n\r\n        pc2_msg.data = b\'\'.join(data)\r\n        return pc2_msg\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    bridge = PerceptionNavigationBridge()\r\n\r\n    try:\r\n        rclpy.spin(bridge)\r\n    except KeyboardInterrupt:\r\n        bridge.get_logger().info(\'Perception-Navigation Bridge stopped by user\')\r\n    finally:\r\n        bridge.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,a.jsx)(n.h3,{id:"2-semantic-navigation-node",children:"2. Semantic Navigation Node"}),"\n",(0,a.jsx)(n.p,{children:"Create a node that uses semantic information for intelligent navigation:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n"""\r\nSemantic Navigation Node\r\n"""\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import PoseStamped, Point\r\nfrom nav_msgs.msg import Path\r\nfrom sensor_msgs.msg import Image\r\nfrom visualization_msgs.msg import MarkerArray\r\nfrom std_msgs.msg import String, Int32\r\nfrom action_msgs.msg import GoalStatus\r\nfrom nav2_msgs.action import NavigateToPose\r\nfrom rclpy.action import ActionClient\r\nimport numpy as np\r\n\r\n\r\nclass SemanticNavigationNode(Node):\r\n    def __init__(self):\r\n        super().__init__(\'semantic_navigation_node\')\r\n\r\n        # Parameters\r\n        self.declare_parameter(\'semantic_class_weights\', [0.1, 10.0, 8.0, 10.0, 5.0, 6.0])\r\n        self.declare_parameter(\'navigation_priority_threshold\', 0.8)\r\n\r\n        self.class_weights = self.get_parameter(\'semantic_class_weights\').value\r\n        self.priority_threshold = self.get_parameter(\'navigation_priority_threshold\').value\r\n\r\n        # Semantic class mapping\r\n        self.semantic_classes = {\r\n            0: "free_space",\r\n            1: "wall",\r\n            2: "person",\r\n            3: "furniture",\r\n            4: "plant",\r\n            5: "clutter"\r\n        }\r\n\r\n        # Navigation action client\r\n        self.nav_client = ActionClient(self, NavigateToPose, \'navigate_to_pose\')\r\n\r\n        # Subscriptions\r\n        self.semantic_sub = self.create_subscription(\r\n            Image, \'/segmentation/segmentation_map\', self.semantic_callback, 10)\r\n        self.dynamic_objects_sub = self.create_subscription(\r\n            MarkerArray, \'/dynamic_objects\', self.dynamic_objects_callback, 10)\r\n\r\n        # Publishers\r\n        self.semantic_path_pub = self.create_publisher(\r\n            Path, \'/semantic_plan\', 10)\r\n        self.navigation_intent_pub = self.create_publisher(\r\n            String, \'/navigation_intent\', 10)\r\n\r\n        # Internal state\r\n        self.current_semantic_map = None\r\n        self.dynamic_objects = []\r\n        self.navigation_goals = []\r\n\r\n        self.get_logger().info(\'Semantic Navigation Node initialized\')\r\n\r\n    def semantic_callback(self, msg):\r\n        """Process semantic segmentation data"""\r\n        self.current_semantic_map = msg\r\n        self.get_logger().debug(\'Processed semantic segmentation data\')\r\n\r\n    def dynamic_objects_callback(self, msg):\r\n        """Process dynamic object detections"""\r\n        self.dynamic_objects = msg.markers\r\n        self.get_logger().debug(f\'Processed {len(msg.markers)} dynamic objects\')\r\n\r\n    def navigate_with_semantic_awareness(self, goal_pose, target_object_class=None):\r\n        """Navigate with semantic awareness"""\r\n        if target_object_class:\r\n            # If navigating to a specific object, use semantic guidance\r\n            goal_pose = self.adjust_goal_for_target_object(goal_pose, target_object_class)\r\n\r\n        # Send navigation goal\r\n        goal_msg = NavigateToPose.Goal()\r\n        goal_msg.pose = goal_pose\r\n\r\n        self.nav_client.wait_for_server()\r\n        future = self.nav_client.send_goal_async(goal_msg)\r\n\r\n        # Publish navigation intent\r\n        intent_msg = String()\r\n        intent_msg.data = f"navigating_to_{target_object_class if target_object_class else \'position\'}"\r\n        self.navigation_intent_pub.publish(intent_msg)\r\n\r\n        return future\r\n\r\n    def adjust_goal_for_target_object(self, goal_pose, target_class):\r\n        """Adjust navigation goal based on target object class"""\r\n        if not self.current_semantic_map:\r\n            return goal_pose\r\n\r\n        # In a real implementation, this would:\r\n        # 1. Analyze semantic map to find instances of target_class\r\n        # 2. Adjust goal to approach the target object appropriately\r\n        # 3. Consider object orientation and approach angle\r\n\r\n        # For now, just return the original goal\r\n        return goal_pose\r\n\r\n    def get_semantic_path_cost(self, path):\r\n        """Calculate cost of a path based on semantic information"""\r\n        if not self.current_semantic_map:\r\n            return float(\'inf\')\r\n\r\n        total_cost = 0\r\n        for pose in path.poses:\r\n            # Get semantic class at this position\r\n            semantic_class = self.get_semantic_class_at_position(\r\n                pose.pose.position.x, pose.pose.position.y)\r\n\r\n            # Apply class-specific cost\r\n            if semantic_class < len(self.class_weights):\r\n                cost = self.class_weights[semantic_class]\r\n                total_cost += cost\r\n\r\n        return total_cost\r\n\r\n    def get_semantic_class_at_position(self, x, y):\r\n        """Get semantic class at a specific world position"""\r\n        # This would involve transforming world coordinates to image coordinates\r\n        # and sampling the semantic segmentation map\r\n        # For now, return a default value\r\n        return 0  # free space\r\n\r\n    def create_semantic_aware_path(self, start, goal, preferred_classes=None):\r\n        """Create a path that considers semantic information"""\r\n        # This would implement a semantic-aware path planning algorithm\r\n        # that prefers certain semantic classes over others\r\n        path = Path()\r\n        path.header.frame_id = "map"\r\n\r\n        # For now, create a simple straight-line path\r\n        # In reality, this would use semantic information to guide path planning\r\n        current = start\r\n        steps = 10\r\n        for i in range(steps + 1):\r\n            t = i / steps\r\n            x = start.x + t * (goal.x - start.x)\r\n            y = start.y + t * (goal.y - start.y)\r\n            z = start.z + t * (goal.z - start.z)\r\n\r\n            pose_stamped = PoseStamped()\r\n            pose_stamped.pose.position.x = x\r\n            pose_stamped.pose.position.y = y\r\n            pose_stamped.pose.position.z = z\r\n            path.poses.append(pose_stamped)\r\n\r\n        return path\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    semantic_nav = SemanticNavigationNode()\r\n\r\n    try:\r\n        rclpy.spin(semantic_nav)\r\n    except KeyboardInterrupt:\r\n        semantic_nav.get_logger().info(\'Semantic Navigation Node stopped by user\')\r\n    finally:\r\n        semantic_nav.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,a.jsx)(n.h2,{id:"launch-files-for-integration",children:"Launch Files for Integration"}),"\n",(0,a.jsx)(n.h3,{id:"1-complete-integration-launch-file",children:"1. Complete Integration Launch File"}),"\n",(0,a.jsxs)(n.p,{children:["Create a launch file ",(0,a.jsx)(n.code,{children:"perception_navigation_integration_launch.py"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"import os\r\nfrom launch import LaunchDescription\r\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription, RegisterEventHandler\r\nfrom launch.conditions import IfCondition\r\nfrom launch.event_handlers import OnProcessExit\r\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\r\nfrom launch.substitutions import LaunchConfiguration\r\nfrom launch_ros.actions import Node\r\nfrom ament_index_python.packages import get_package_share_directory\r\n\r\n\r\ndef generate_launch_description():\r\n    # Launch configuration variables\r\n    use_sim_time = LaunchConfiguration('use_sim_time', default='false')\r\n    params_file = LaunchConfiguration('params_file')\r\n    run_rviz = LaunchConfiguration('run_rviz', default='true')\r\n    autostart = LaunchConfiguration('autostart', default='true')\r\n\r\n    # Declare launch arguments\r\n    declare_use_sim_time = DeclareLaunchArgument(\r\n        'use_sim_time',\r\n        default_value='false',\r\n        description='Use simulation clock if true')\r\n\r\n    declare_params_file = DeclareLaunchArgument(\r\n        'params_file',\r\n        default_value=os.path.join(\r\n            get_package_share_directory('your_robot_navigation'),\r\n            'config', 'perception_navigation.yaml'),\r\n        description='Full path to the ROS2 parameters file to use for all launched nodes')\r\n\r\n    declare_autostart = DeclareLaunchArgument(\r\n        'autostart',\r\n        default_value='true',\r\n        description='Automatically startup the nav2 stack')\r\n\r\n    declare_run_rviz = DeclareLaunchArgument(\r\n        'run_rviz',\r\n        default_value='true',\r\n        description='Whether to start RViz')\r\n\r\n    # Isaac ROS Visual SLAM node\r\n    visual_slam_node = Node(\r\n        package='isaac_ros_visual_slam',\r\n        executable='visual_slam_node',\r\n        parameters=[{\r\n            'use_sim_time': use_sim_time,\r\n            'enable_occupancy_map': True,\r\n            'enable_point_cloud_output': True\r\n        }],\r\n        remappings=[\r\n            ('/stereo_camera/left/image', '/camera/left/image_rect_color'),\r\n            ('/stereo_camera/left/camera_info', '/camera/left/camera_info'),\r\n            ('/stereo_camera/right/image', '/camera/right/image_rect_color'),\r\n            ('/stereo_camera/right/camera_info', '/camera/right/camera_info'),\r\n        ],\r\n        output='screen'\r\n    )\r\n\r\n    # Isaac ROS stereo image processing\r\n    stereo_image_proc_node = Node(\r\n        package='isaac_ros_stereo_image_proc',\r\n        executable='stereo_image_proc',\r\n        parameters=[{'use_sim_time': use_sim_time}],\r\n        output='screen'\r\n    )\r\n\r\n    # Isaac ROS segmentation\r\n    segmentation_node = Node(\r\n        package='isaac_ros_dnn_segmentation',\r\n        executable='dnn_segmentation_node',\r\n        parameters=[{\r\n            'use_sim_time': use_sim_time,\r\n            'model_name': 'unet',\r\n            'input_topic': '/camera/image_raw',\r\n            'output_topic': '/segmentation/segmentation_map'\r\n        }],\r\n        output='screen'\r\n    )\r\n\r\n    # Perception-Navigation bridge\r\n    perception_bridge_node = Node(\r\n        package='your_robot_navigation',\r\n        executable='perception_navigation_bridge',\r\n        parameters=[{\r\n            'use_sim_time': use_sim_time,\r\n            'perception_timeout': 1.0,\r\n            'dynamic_object_threshold': 0.5\r\n        }],\r\n        output='screen'\r\n    )\r\n\r\n    # Semantic navigation node\r\n    semantic_navigation_node = Node(\r\n        package='your_robot_navigation',\r\n        executable='semantic_navigation_node',\r\n        parameters=[{\r\n            'use_sim_time': use_sim_time,\r\n            'semantic_class_weights': [0.1, 10.0, 8.0, 10.0, 5.0, 6.0]\r\n        }],\r\n        output='screen'\r\n    )\r\n\r\n    # Navigation2 stack\r\n    navigation2_launch = IncludeLaunchDescription(\r\n        PythonLaunchDescriptionSource(\r\n            os.path.join(\r\n                get_package_share_directory('nav2_bringup'),\r\n                'launch', 'navigation_launch.py')),\r\n        launch_arguments={\r\n            'use_sim_time': use_sim_time,\r\n            'params_file': params_file,\r\n            'autostart': autostart\r\n        }.items()\r\n    )\r\n\r\n    # RViz2\r\n    rviz_node = Node(\r\n        condition=IfCondition(run_rviz),\r\n        package='rviz2',\r\n        executable='rviz2',\r\n        name='rviz2',\r\n        arguments=['-d', os.path.join(\r\n            get_package_share_directory('nav2_bringup'),\r\n            'rviz', 'nav2_default_view.rviz')],\r\n        parameters=[{'use_sim_time': use_sim_time}]\r\n    )\r\n\r\n    # Create launch description\r\n    ld = LaunchDescription()\r\n\r\n    # Add launch arguments\r\n    ld.add_action(declare_use_sim_time)\r\n    ld.add_action(declare_params_file)\r\n    ld.add_action(declare_autostart)\r\n    ld.add_action(declare_run_rviz)\r\n\r\n    # Add Isaac ROS nodes\r\n    ld.add_action(stereo_image_proc_node)\r\n    ld.add_action(visual_slam_node)\r\n    ld.add_action(segmentation_node)\r\n\r\n    # Add perception-navigation bridge\r\n    ld.add_action(perception_bridge_node)\r\n    ld.add_action(semantic_navigation_node)\r\n\r\n    # Add Navigation2 stack\r\n    ld.add_action(navigation2_launch)\r\n\r\n    # Add RViz2\r\n    ld.add_action(rviz_node)\r\n\r\n    return ld\n"})}),"\n",(0,a.jsx)(n.h2,{id:"performance-optimization-for-integration",children:"Performance Optimization for Integration"}),"\n",(0,a.jsx)(n.h3,{id:"1-optimized-integration-configuration",children:"1. Optimized Integration Configuration"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'# Optimized perception-navigation integration\r\nglobal_costmap:\r\n  global_costmap:\r\n    ros__parameters:\r\n      update_frequency: 0.5  # Lower for global map\r\n      publish_frequency: 0.5\r\n      transform_tolerance: 1.0\r\n      use_sim_time: false\r\n\r\n      global_frame: map\r\n      robot_base_frame: base_link\r\n      robot_radius: 0.22\r\n      resolution: 0.05\r\n\r\n      plugins: ["static_layer", "isaac_perception_layer", "inflation_layer"]\r\n\r\n      static_layer:\r\n        plugin: "nav2_costmap_2d::StaticLayer"\r\n        map_subscribe_transient_local: True\r\n\r\n      # Optimized Isaac perception layer\r\n      isaac_perception_layer:\r\n        plugin: "nav2_isaac_perception_layer/IsaacPerceptionLayer"\r\n        enabled: True\r\n        observation_sources: segmentation\r\n        segmentation:\r\n          topic: /segmentation/segmentation_map\r\n          sensor_frame: camera_link\r\n          data_type: "Image"\r\n          clearing: False\r\n          marking: True\r\n          obstacle_value: 254\r\n          free_space_value: 0\r\n          observation_persistence: 0.5  # Keep observations for 0.5s\r\n\r\n      inflation_layer:\r\n        plugin: "nav2_costmap_2d::InflationLayer"\r\n        cost_scaling_factor: 3.0\r\n        inflation_radius: 0.5\r\n\r\nlocal_costmap:\r\n  local_costmap:\r\n    ros__parameters:\r\n      update_frequency: 15.0  # Higher for local planning\r\n      publish_frequency: 10.0\r\n      transform_tolerance: 0.2\r\n      use_sim_time: false\r\n\r\n      global_frame: odom\r\n      robot_base_frame: base_link\r\n      robot_radius: 0.22\r\n      resolution: 0.025\r\n\r\n      rolling_window: true\r\n      width: 4\r\n      height: 4\r\n      origin_x: -2.0\r\n      origin_y: -2.0\r\n\r\n      plugins: ["voxel_layer", "isaac_perception_layer", "inflation_layer"]\r\n\r\n      voxel_layer:\r\n        plugin: "nav2_costmap_2d::VoxelLayer"\r\n        enabled: True\r\n        publish_voxel_map: False  # Disable for performance\r\n        origin_z: 0.0\r\n        z_resolution: 0.05\r\n        z_voxels: 8  # Reduce for performance\r\n        max_obstacle_height: 2.0\r\n        mark_threshold: 0\r\n        observation_sources: scan\r\n        scan:\r\n          topic: /scan\r\n\r\n      # Optimized perception layer for local costmap\r\n      isaac_perception_layer:\r\n        plugin: "nav2_isaac_perception_layer/IsaacPerceptionLayer"\r\n        enabled: True\r\n        observation_sources: stereo_depth\r\n        stereo_depth:\r\n          topic: /stereo/depth/disparity\r\n          sensor_frame: stereo_camera_link\r\n          data_type: "Disparity"\r\n          clearing: True\r\n          marking: True\r\n          obstacle_range: 2.0  # Shorter range for local planning\r\n          raytrace_range: 3.0\r\n\r\n      inflation_layer:\r\n        plugin: "nav2_costmap_2d::InflationLayer"\r\n        cost_scaling_factor: 5.0\r\n        inflation_radius: 0.4\n'})}),"\n",(0,a.jsx)(n.h3,{id:"2-memory-and-computation-optimization",children:"2. Memory and Computation Optimization"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'# Memory-optimized integration configuration\r\ncontroller_server:\r\n  ros__parameters:\r\n    use_sim_time: false\r\n    controller_frequency: 20.0  # Balance performance and control quality\r\n    min_x_velocity_threshold: 0.001\r\n    min_theta_velocity_threshold: 0.001\r\n    failure_tolerance: 0.5\r\n    progress_checker_plugin: "simple_progress_checker"\r\n    goal_checker_plugins: ["simple_goal_checker"]\r\n    controller_plugins: ["SimplePerceptionController"]\r\n\r\n    simple_progress_checker:\r\n      plugin: "nav2_controller::SimpleProgressChecker"\r\n      required_movement_radius: 0.5\r\n      movement_time_allowance: 10.0\r\n\r\n    simple_goal_checker:\r\n      plugin: "nav2_controller::SimpleGoalChecker"\r\n      xy_goal_tolerance: 0.3\r\n      yaw_goal_tolerance: 0.3\r\n      stateful: False  # Disable stateful behavior for performance\r\n\r\n    SimplePerceptionController:\r\n      plugin: "dwb_core::DWBLocalPlanner"\r\n      debug_trajectory_details: False\r\n      min_vel_x: 0.1\r\n      max_vel_x: 0.4\r\n      max_vel_theta: 1.0\r\n      vx_samples: 15  # Reduce samples for performance\r\n      vtheta_samples: 15\r\n      sim_time: 1.0  # Shorter simulation time\r\n      linear_granularity: 0.1\r\n      angular_granularity: 0.05\r\n      transform_tolerance: 0.2\r\n      xy_goal_tolerance: 0.3\r\n      stateful: False\r\n      publish_cost_grid_pc: False  # Disable for performance\n'})}),"\n",(0,a.jsx)(n.h2,{id:"quality-assurance-and-testing",children:"Quality Assurance and Testing"}),"\n",(0,a.jsx)(n.h3,{id:"1-integration-testing-framework",children:"1. Integration Testing Framework"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n"""\r\nPerception-Navigation Integration Testing\r\n"""\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import Bool, Float32\r\nfrom geometry_msgs.msg import PoseStamped\r\nfrom nav2_msgs.action import NavigateToPose\r\nfrom rclpy.action import ActionClient\r\nimport time\r\n\r\n\r\nclass IntegrationTester(Node):\r\n    def __init__(self):\r\n        super().__init__(\'integration_tester\')\r\n\r\n        # Parameters\r\n        self.declare_parameter(\'test_duration\', 30.0)\r\n        self.declare_parameter(\'success_threshold\', 0.9)\r\n\r\n        self.test_duration = self.get_parameter(\'test_duration\').value\r\n        self.success_threshold = self.get_parameter(\'success_threshold\').value\r\n\r\n        # Publishers and subscribers\r\n        self.test_status_pub = self.create_publisher(Bool, \'/integration_test_status\', 10)\r\n        self.test_result_pub = self.create_publisher(Float32, \'/integration_test_result\', 10)\r\n\r\n        # Navigation action client\r\n        self.nav_client = ActionClient(self, NavigateToPose, \'navigate_to_pose\')\r\n\r\n        # Test parameters\r\n        self.test_start_time = None\r\n        self.test_active = False\r\n        self.success_count = 0\r\n        self.total_attempts = 0\r\n\r\n        # Timer for periodic testing\r\n        self.test_timer = self.create_timer(5.0, self.run_test_cycle)\r\n\r\n        self.get_logger().info(\'Integration Tester initialized\')\r\n\r\n    def run_test_cycle(self):\r\n        """Run a navigation test cycle"""\r\n        if not self.test_active:\r\n            self.start_test()\r\n            return\r\n\r\n        # Check if test duration has elapsed\r\n        if (self.get_clock().now().nanoseconds / 1e9 - self.test_start_time) > self.test_duration:\r\n            self.end_test()\r\n            return\r\n\r\n        # Run navigation test\r\n        self.run_navigation_test()\r\n\r\n    def start_test(self):\r\n        """Start integration test"""\r\n        self.test_active = True\r\n        self.test_start_time = self.get_clock().now().nanoseconds / 1e9\r\n        self.get_logger().info(f\'Starting integration test for {self.test_duration} seconds\')\r\n\r\n    def run_navigation_test(self):\r\n        """Run a single navigation test"""\r\n        # Define test goal (this would be more sophisticated in practice)\r\n        goal_pose = PoseStamped()\r\n        goal_pose.header.frame_id = "map"\r\n        goal_pose.pose.position.x = 2.0\r\n        goal_pose.pose.position.y = 2.0\r\n        goal_pose.pose.position.z = 0.0\r\n        goal_pose.pose.orientation.w = 1.0\r\n\r\n        # Send navigation goal\r\n        goal_msg = NavigateToPose.Goal()\r\n        goal_msg.pose = goal_pose\r\n\r\n        if self.nav_client.wait_for_server(timeout_sec=1.0):\r\n            self.total_attempts += 1\r\n\r\n            # Send goal and wait for result\r\n            future = self.nav_client.send_goal_async(goal_msg)\r\n            # In a real test, we\'d wait for the result and check success\r\n            # For this example, we\'ll simulate success/failure\r\n            success = True  # Simulated result\r\n            if success:\r\n                self.success_count += 1\r\n\r\n    def end_test(self):\r\n        """End integration test and report results"""\r\n        success_rate = self.success_count / self.total_attempts if self.total_attempts > 0 else 0\r\n        self.get_logger().info(f\'Test completed - Success rate: {success_rate:.2f} ({self.success_count}/{self.total_attempts})\')\r\n\r\n        # Publish results\r\n        result_msg = Float32()\r\n        result_msg.data = success_rate\r\n        self.test_result_pub.publish(result_msg)\r\n\r\n        status_msg = Bool()\r\n        status_msg.data = success_rate >= self.success_threshold\r\n        self.test_status_pub.publish(status_msg)\r\n\r\n        self.test_active = False\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    tester = IntegrationTester()\r\n\r\n    try:\r\n        rclpy.spin(tester)\r\n    except KeyboardInterrupt:\r\n        tester.get_logger().info(\'Integration tester stopped by user\')\r\n    finally:\r\n        tester.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,a.jsx)(n.h2,{id:"troubleshooting-integration-issues",children:"Troubleshooting Integration Issues"}),"\n",(0,a.jsx)(n.h3,{id:"1-common-integration-problems-and-solutions",children:"1. Common Integration Problems and Solutions"}),"\n",(0,a.jsx)(n.h4,{id:"issue-perception-data-not-affecting-navigation",children:"Issue: Perception data not affecting navigation"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Symptoms"}),": Robot doesn't respond to dynamic objects or semantic information\r\n",(0,a.jsx)(n.strong,{children:"Solutions"}),":"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Check topic connections:","\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"ros2 topic echo /segmentation/segmentation_map\r\nros2 topic list | grep costmap\n"})}),"\n"]}),"\n",(0,a.jsx)(n.li,{children:"Verify costmap configuration includes perception layers"}),"\n",(0,a.jsx)(n.li,{children:"Check TF tree for proper frame relationships"}),"\n",(0,a.jsx)(n.li,{children:"Confirm perception nodes are publishing data"}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"issue-high-cpu-usage-with-integration",children:"Issue: High CPU usage with integration"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Symptoms"}),": System becomes unresponsive when perception is active\r\n",(0,a.jsx)(n.strong,{children:"Solutions"}),":"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Reduce perception processing frequency"}),"\n",(0,a.jsx)(n.li,{children:"Lower costmap resolution"}),"\n",(0,a.jsx)(n.li,{children:"Simplify perception algorithms"}),"\n",(0,a.jsx)(n.li,{children:"Use hardware acceleration for perception"}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"issue-navigation-conflicts-with-perception",children:"Issue: Navigation conflicts with perception"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Symptoms"}),": Robot stops frequently due to false obstacle detections\r\n",(0,a.jsx)(n.strong,{children:"Solutions"}),":"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Adjust perception confidence thresholds"}),"\n",(0,a.jsx)(n.li,{children:"Increase obstacle filtering"}),"\n",(0,a.jsx)(n.li,{children:"Tune costmap inflation parameters"}),"\n",(0,a.jsx)(n.li,{children:"Implement perception validation"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"2-performance-monitoring",children:"2. Performance Monitoring"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"# Monitor integration performance\r\nros2 run topic_tools relay /perception_processing_time\r\nros2 run topic_tools relay /navigation_compute_time\r\nros2 run topic_tools relay /perception_navigation_status\r\n\r\n# Check TF tree\r\nros2 run tf2_tools view_frames\r\n\r\n# Monitor node performance\r\nros2 run top top\n"})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices-for-integration",children:"Best Practices for Integration"}),"\n",(0,a.jsx)(n.h3,{id:"1-design-guidelines",children:"1. Design Guidelines"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Use appropriate data fusion techniques"}),"\n",(0,a.jsx)(n.li,{children:"Implement proper error handling and fallbacks"}),"\n",(0,a.jsx)(n.li,{children:"Design for graceful degradation when perception fails"}),"\n",(0,a.jsx)(n.li,{children:"Maintain real-time performance requirements"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"2-testing-strategies",children:"2. Testing Strategies"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Test in simulation before real-world deployment"}),"\n",(0,a.jsx)(n.li,{children:"Validate individual components before integration"}),"\n",(0,a.jsx)(n.li,{children:"Test with various environmental conditions"}),"\n",(0,a.jsx)(n.li,{children:"Verify safety and reliability requirements"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"3-performance-optimization",children:"3. Performance Optimization"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Use appropriate data structures for real-time processing"}),"\n",(0,a.jsx)(n.li,{children:"Implement efficient algorithms for perception tasks"}),"\n",(0,a.jsx)(n.li,{children:"Optimize communication between nodes"}),"\n",(0,a.jsx)(n.li,{children:"Consider hardware acceleration where possible"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"resources",children:"Resources"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://nvidia-isaac-ros.github.io/concepts/navigation_integration/index.html",children:"Isaac ROS Navigation Integration Guide"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://navigation.ros.org/tutorials/docs/navigation2_with_vslam.html",children:"Navigation2 Perception Tutorials"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://navigation.ros.org/plugins/costmap_plugins/index.html",children:"Costmap Layer Development"})}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(n.p,{children:"This guide provides comprehensive instructions for integrating Isaac ROS perception with Navigation2. The integration enables robots to leverage visual and sensor data for enhanced navigation capabilities, including better obstacle detection, semantic awareness, and improved localization. Proper integration requires careful attention to data flow, timing, and performance considerations. The key to successful integration is starting with basic configurations and gradually adding complexity while maintaining system stability and performance."})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(_,{...e})}):_(e)}},7074:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>o});var t=r(6540);const a={},i=t.createContext(a);function s(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);