"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[8206],{7074:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>o});var r=i(6540);const s={},a=r.createContext(s);function t(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),r.createElement(a.Provider,{value:n},e.children)}},9889:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>t,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"simulation/sensor-data-verification","title":"How to Verify Accurate Sensor Data Generation","description":"Overview","source":"@site/docs/simulation/sensor-data-verification.md","sourceDirName":"simulation","slug":"/simulation/sensor-data-verification","permalink":"/./docs/simulation/sensor-data-verification","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/simulation/sensor-data-verification.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Sensor Visualization Guide Using RViz2","permalink":"/./docs/simulation/sensor-visualization-rviz2"},"next":{"title":"Physics Simulation Performance Optimization Guide","permalink":"/./docs/simulation/physics-performance-optimization"}}');var s=i(4848),a=i(7074);const t={},o="How to Verify Accurate Sensor Data Generation",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Verification Methods",id:"verification-methods",level:2},{value:"1. LIDAR Sensor Verification",id:"1-lidar-sensor-verification",level:3},{value:"Check Data Range and Resolution",id:"check-data-range-and-resolution",level:4},{value:"Visual Verification in RViz2",id:"visual-verification-in-rviz2",level:4},{value:"Range Verification Script",id:"range-verification-script",level:4},{value:"2. Camera Sensor Verification",id:"2-camera-sensor-verification",level:3},{value:"Image Quality Check",id:"image-quality-check",level:4},{value:"Visual Verification",id:"visual-verification",level:4},{value:"Image Analysis Script",id:"image-analysis-script",level:4},{value:"3. IMU Sensor Verification",id:"3-imu-sensor-verification",level:3},{value:"Data Consistency Check",id:"data-consistency-check",level:4},{value:"Expected Values",id:"expected-values",level:4},{value:"IMU Verification Script",id:"imu-verification-script",level:4},{value:"Verification Tools and Techniques",id:"verification-tools-and-techniques",level:2},{value:"1. ros2 topic Command Line Tools",id:"1-ros2-topic-command-line-tools",level:3},{value:"Check Topic Health",id:"check-topic-health",level:4},{value:"Verify Message Rates",id:"verify-message-rates",level:4},{value:"2. RQT Tools for Visualization",id:"2-rqt-tools-for-visualization",level:3},{value:"Install RQT Tools",id:"install-rqt-tools",level:4},{value:"Launch RQT for Sensor Analysis",id:"launch-rqt-for-sensor-analysis",level:4},{value:"3. Custom Verification Scripts",id:"3-custom-verification-scripts",level:3},{value:"Comprehensive Sensor Verification",id:"comprehensive-sensor-verification",level:4},{value:"Environmental Verification",id:"environmental-verification",level:2},{value:"1. Ground Truth Comparison",id:"1-ground-truth-comparison",level:3},{value:"2. Static Environment Verification",id:"2-static-environment-verification",level:3},{value:"3. Dynamic Verification",id:"3-dynamic-verification",level:3},{value:"Performance Verification",id:"performance-verification",level:2},{value:"1. Timing Analysis",id:"1-timing-analysis",level:3},{value:"2. Latency Measurement",id:"2-latency-measurement",level:3},{value:"3. Resource Usage",id:"3-resource-usage",level:3},{value:"Common Issues and Solutions",id:"common-issues-and-solutions",level:2},{value:"Issue: Sensor Data Not Publishing",id:"issue-sensor-data-not-publishing",level:3},{value:"Issue: Invalid Data Values",id:"issue-invalid-data-values",level:3},{value:"Issue: Delayed or Stale Data",id:"issue-delayed-or-stale-data",level:3},{value:"Automated Verification Framework",id:"automated-verification-framework",level:2},{value:"Best Practices for Sensor Verification",id:"best-practices-for-sensor-verification",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"how-to-verify-accurate-sensor-data-generation",children:"How to Verify Accurate Sensor Data Generation"})}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"This guide provides methods to verify that robot sensors in Gazebo simulation are generating accurate and reliable data. Proper sensor verification is critical for ensuring that simulation results are trustworthy and that algorithms will work correctly when deployed to real robots."}),"\n",(0,s.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Running Gazebo simulation with robot containing sensors"}),"\n",(0,s.jsx)(n.li,{children:"ROS 2 Humble Hawksbill"}),"\n",(0,s.jsx)(n.li,{children:"RViz2 for visualization"}),"\n",(0,s.jsx)(n.li,{children:"Basic understanding of ROS 2 topics and message types"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"verification-methods",children:"Verification Methods"}),"\n",(0,s.jsx)(n.h3,{id:"1-lidar-sensor-verification",children:"1. LIDAR Sensor Verification"}),"\n",(0,s.jsx)(n.h4,{id:"check-data-range-and-resolution",children:"Check Data Range and Resolution"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Echo LIDAR data to verify range values\r\nros2 topic echo /scan --field ranges | head -20\n"})}),"\n",(0,s.jsx)(n.p,{children:"Expected results:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Range values should be within sensor limits (e.g., 0.1m to 10.0m for typical LIDAR)"}),"\n",(0,s.jsx)(n.li,{children:"No invalid values (inf, NaN)"}),"\n",(0,s.jsx)(n.li,{children:"Consistent number of range readings matching sensor configuration"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"visual-verification-in-rviz2",children:"Visual Verification in RViz2"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:'Add a "LaserScan" display in RViz2'}),"\n",(0,s.jsxs)(n.li,{children:["Set the topic to your LIDAR topic (e.g., ",(0,s.jsx)(n.code,{children:"/scan"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:["Check that:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Points form coherent shapes matching obstacles in the world"}),"\n",(0,s.jsx)(n.li,{children:"No ghost points or artifacts"}),"\n",(0,s.jsx)(n.li,{children:"Range values match visual distance to obstacles"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"range-verification-script",children:"Range Verification Script"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import LaserScan\r\nimport numpy as np\r\n\r\nclass LidarVerifier(Node):\r\n    def __init__(self):\r\n        super().__init__('lidar_verifier')\r\n        self.subscription = self.create_subscription(\r\n            LaserScan,\r\n            '/scan',\r\n            self.lidar_callback,\r\n            10)\r\n        self.get_logger().info('LIDAR verifier started')\r\n\r\n    def lidar_callback(self, msg):\r\n        # Check for invalid values\r\n        ranges = np.array(msg.ranges)\r\n        invalid_mask = np.isnan(ranges) | np.isinf(ranges)\r\n\r\n        if np.any(invalid_mask):\r\n            self.get_logger().warn(f'Invalid range values detected: {np.sum(invalid_mask)}')\r\n\r\n        # Check range bounds\r\n        if np.any(ranges < msg.range_min) or np.any(ranges > msg.range_max):\r\n            self.get_logger().warn('Range values outside sensor bounds')\r\n\r\n        # Check for expected number of readings\r\n        expected_readings = int((msg.angle_max - msg.angle_min) / msg.angle_increment) + 1\r\n        if len(ranges) != expected_readings:\r\n            self.get_logger().warn(f'Unexpected number of readings: {len(ranges)} vs {expected_readings}')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    lidar_verifier = LidarVerifier()\r\n    rclpy.spin(lidar_verifier)\r\n    lidar_verifier.destroy_node()\r\n    rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-camera-sensor-verification",children:"2. Camera Sensor Verification"}),"\n",(0,s.jsx)(n.h4,{id:"image-quality-check",children:"Image Quality Check"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Check image topic\r\nros2 topic echo /camera/image_raw --field header.stamp\n"})}),"\n",(0,s.jsx)(n.h4,{id:"visual-verification",children:"Visual Verification"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:'Add an "Image" display in RViz2'}),"\n",(0,s.jsxs)(n.li,{children:["Set the topic to your camera topic (e.g., ",(0,s.jsx)(n.code,{children:"/camera/image_raw"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:["Verify:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Image is not black or corrupted"}),"\n",(0,s.jsx)(n.li,{children:"Objects in the image match the simulated environment"}),"\n",(0,s.jsx)(n.li,{children:"Colors and lighting appear realistic"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"image-analysis-script",children:"Image Analysis Script"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import Image\r\nfrom cv_bridge import CvBridge\r\nimport cv2\r\nimport numpy as np\r\n\r\nclass CameraVerifier(Node):\r\n    def __init__(self):\r\n        super().__init__('camera_verifier')\r\n        self.bridge = CvBridge()\r\n        self.subscription = self.create_subscription(\r\n            Image,\r\n            '/camera/image_raw',\r\n            self.image_callback,\r\n            10)\r\n        self.get_logger().info('Camera verifier started')\r\n\r\n    def image_callback(self, msg):\r\n        try:\r\n            # Convert ROS Image message to OpenCV image\r\n            cv_image = self.bridge.imgmsg_to_cv2(msg, \"bgr8\")\r\n\r\n            # Check image properties\r\n            height, width, channels = cv_image.shape\r\n\r\n            # Verify image is not all black\r\n            if np.mean(cv_image) < 5:  # Very dark image\r\n                self.get_logger().warn('Image appears to be too dark')\r\n\r\n            # Verify image is not all white\r\n            if np.mean(cv_image) > 250:  # Very bright image\r\n                self.get_logger().warn('Image appears to be too bright')\r\n\r\n            # Check for common image artifacts\r\n            # Check for uniform regions (could indicate rendering issues)\r\n            if len(np.unique(cv_image)) < 100:  # Too few unique values\r\n                self.get_logger().warn('Image may have rendering artifacts')\r\n\r\n        except Exception as e:\r\n            self.get_logger().error(f'Error processing image: {e}')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    camera_verifier = CameraVerifier()\r\n    rclpy.spin(camera_verifier)\r\n    camera_verifier.destroy_node()\r\n    rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-imu-sensor-verification",children:"3. IMU Sensor Verification"}),"\n",(0,s.jsx)(n.h4,{id:"data-consistency-check",children:"Data Consistency Check"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Echo IMU data\r\nros2 topic echo /imu/data --field orientation\n"})}),"\n",(0,s.jsx)(n.h4,{id:"expected-values",children:"Expected Values"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Orientation quaternion should be normalized (magnitude \u2248 1.0)"}),"\n",(0,s.jsx)(n.li,{children:"Linear acceleration should include gravity (\u2248 9.8 m/s\xb2 in z-axis when robot is upright)"}),"\n",(0,s.jsx)(n.li,{children:"Angular velocity should be close to zero when robot is stationary"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"imu-verification-script",children:"IMU Verification Script"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import Imu\r\nimport math\r\n\r\nclass ImuVerifier(Node):\r\n    def __init__(self):\r\n        super().__init__('imu_verifier')\r\n        self.subscription = self.create_subscription(\r\n            Imu,\r\n            '/imu/data',\r\n            self.imu_callback,\r\n            10)\r\n        self.get_logger().info('IMU verifier started')\r\n\r\n    def imu_callback(self, msg):\r\n        # Check quaternion normalization\r\n        quat = msg.orientation\r\n        magnitude = math.sqrt(quat.x**2 + quat.y**2 + quat.z**2 + quat.w**2)\r\n\r\n        if abs(magnitude - 1.0) > 0.01:\r\n            self.get_logger().warn(f'Quaternion not normalized: {magnitude}')\r\n\r\n        # Check linear acceleration (should be ~9.8 m/s\xb2 when stationary)\r\n        accel = msg.linear_acceleration\r\n        total_accel = math.sqrt(accel.x**2 + accel.y**2 + accel.z**2)\r\n\r\n        # When robot is upright and stationary, z should be ~9.8\r\n        if abs(accel.z - 9.8) > 1.0 and total_accel > 10.8:\r\n            self.get_logger().warn(f'Unexpected acceleration: {total_accel} m/s\xb2')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    imu_verifier = ImuVerifier()\r\n    rclpy.spin(imu_verifier)\r\n    imu_verifier.destroy_node()\r\n    rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"verification-tools-and-techniques",children:"Verification Tools and Techniques"}),"\n",(0,s.jsx)(n.h3,{id:"1-ros2-topic-command-line-tools",children:"1. ros2 topic Command Line Tools"}),"\n",(0,s.jsx)(n.h4,{id:"check-topic-health",children:"Check Topic Health"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# List all topics\r\nros2 topic list\r\n\r\n# Check topic type\r\nros2 topic type /scan\r\n\r\n# Check topic info\r\nros2 topic info /scan\r\n\r\n# Echo messages\r\nros2 topic echo /scan | head -10\r\n\r\n# Get topic statistics\r\nros2 topic hz /scan\n"})}),"\n",(0,s.jsx)(n.h4,{id:"verify-message-rates",children:"Verify Message Rates"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Check if topics are publishing at expected rates\r\nros2 topic hz /scan\r\nros2 topic hz /camera/image_raw\r\nros2 topic hz /imu/data\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-rqt-tools-for-visualization",children:"2. RQT Tools for Visualization"}),"\n",(0,s.jsx)(n.h4,{id:"install-rqt-tools",children:"Install RQT Tools"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"sudo apt install ros-humble-rqt ros-humble-rqt-common-plugins ros-humble-rqt-robot-plugins\n"})}),"\n",(0,s.jsx)(n.h4,{id:"launch-rqt-for-sensor-analysis",children:"Launch RQT for Sensor Analysis"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"rqt\n"})}),"\n",(0,s.jsx)(n.p,{children:"In RQT, use:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"rqt_plot"}),": Plot sensor values over time"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"rqt_image_view"}),": View camera images"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"rqt_robot_monitor"}),": Monitor robot status"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"rqt_topic"}),": Browse topics and messages"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"3-custom-verification-scripts",children:"3. Custom Verification Scripts"}),"\n",(0,s.jsx)(n.h4,{id:"comprehensive-sensor-verification",children:"Comprehensive Sensor Verification"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import LaserScan, Image, Imu\r\nfrom std_msgs.msg import Header\r\nimport time\r\n\r\nclass ComprehensiveSensorVerifier(Node):\r\n    def __init__(self):\r\n        super().__init__('comprehensive_sensor_verifier')\r\n\r\n        # Track sensor data timestamps\r\n        self.last_scan_time = None\r\n        self.last_image_time = None\r\n        self.last_imu_time = None\r\n\r\n        # Subscriptions\r\n        self.scan_sub = self.create_subscription(LaserScan, '/scan', self.scan_callback, 10)\r\n        self.image_sub = self.create_subscription(Image, '/camera/image_raw', self.image_callback, 10)\r\n        self.imu_sub = self.create_subscription(Imu, '/imu/data', self.imu_callback, 10)\r\n\r\n        # Timer for periodic checks\r\n        self.timer = self.create_timer(5.0, self.periodic_check)\r\n\r\n        self.get_logger().info('Comprehensive sensor verifier started')\r\n\r\n    def scan_callback(self, msg):\r\n        self.last_scan_time = msg.header.stamp\r\n        # Additional validation can be added here\r\n\r\n    def image_callback(self, msg):\r\n        self.last_image_time = msg.header.stamp\r\n        # Additional validation can be added here\r\n\r\n    def imu_callback(self, msg):\r\n        self.last_imu_time = msg.header.stamp\r\n        # Additional validation can be added here\r\n\r\n    def periodic_check(self):\r\n        current_time = self.get_clock().now().to_msg()\r\n\r\n        # Check if sensors are publishing data\r\n        if self.last_scan_time is None:\r\n            self.get_logger().warn('No LIDAR data received yet')\r\n        else:\r\n            time_diff = (current_time.sec - self.last_scan_time.sec) + \\\r\n                       (current_time.nanosec - self.last_scan_time.nanosec) * 1e-9\r\n            if time_diff > 2.0:  # No data for 2 seconds\r\n                self.get_logger().warn(f'LIDAR data stale: {time_diff:.2f}s')\r\n\r\n        if self.last_image_time is None:\r\n            self.get_logger().warn('No camera data received yet')\r\n        else:\r\n            time_diff = (current_time.sec - self.last_image_time.sec) + \\\r\n                       (current_time.nanosec - self.last_image_time.nanosec) * 1e-9\r\n            if time_diff > 2.0:  # No data for 2 seconds\r\n                self.get_logger().warn(f'Camera data stale: {time_diff:.2f}s')\r\n\r\n        if self.last_imu_time is None:\r\n            self.get_logger().warn('No IMU data received yet')\r\n        else:\r\n            time_diff = (current_time.sec - self.last_imu_time.sec) + \\\r\n                       (current_time.nanosec - self.last_imu_time.nanosec) * 1e-9\r\n            if time_diff > 0.1:  # No data for 0.1 seconds (high frequency sensor)\r\n                self.get_logger().warn(f'IMU data stale: {time_diff:.2f}s')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    verifier = ComprehensiveSensorVerifier()\r\n\r\n    try:\r\n        rclpy.spin(verifier)\r\n    except KeyboardInterrupt:\r\n        verifier.get_logger().info('Sensor verifier stopped by user')\r\n\r\n    verifier.destroy_node()\r\n    rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"environmental-verification",children:"Environmental Verification"}),"\n",(0,s.jsx)(n.h3,{id:"1-ground-truth-comparison",children:"1. Ground Truth Comparison"}),"\n",(0,s.jsx)(n.p,{children:"For validation, compare sensor readings with known ground truth values:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# If available, use ground truth topics for comparison\r\nros2 topic echo /ground_truth/pose\r\nros2 topic echo /ground_truth/velocity\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-static-environment-verification",children:"2. Static Environment Verification"}),"\n",(0,s.jsx)(n.p,{children:"Place known objects in the simulation environment and verify:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"LIDAR detects objects at expected locations"}),"\n",(0,s.jsx)(n.li,{children:"Camera sees objects with expected appearance"}),"\n",(0,s.jsx)(n.li,{children:"IMU shows correct orientation when robot is placed in known poses"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"3-dynamic-verification",children:"3. Dynamic Verification"}),"\n",(0,s.jsx)(n.p,{children:"Move the robot in the simulation and verify:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Sensor data changes appropriately with robot motion"}),"\n",(0,s.jsx)(n.li,{children:"No unexpected delays or lags in sensor updates"}),"\n",(0,s.jsx)(n.li,{children:"Data consistency during motion"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"performance-verification",children:"Performance Verification"}),"\n",(0,s.jsx)(n.h3,{id:"1-timing-analysis",children:"1. Timing Analysis"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Check timing of sensor messages\r\nros2 topic echo /scan --field header.stamp | head -20\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-latency-measurement",children:"2. Latency Measurement"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Use rqt_plot to visualize timing differences between sensor readings\r\nrqt_plot /scan/header/stamp/sec /camera/image_raw/header/stamp/sec\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-resource-usage",children:"3. Resource Usage"}),"\n",(0,s.jsx)(n.p,{children:"Monitor CPU and memory usage during sensor operation:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Monitor system resources\r\nhtop\r\n# Or use ROS 2 tools\r\nros2 run top top\n"})}),"\n",(0,s.jsx)(n.h2,{id:"common-issues-and-solutions",children:"Common Issues and Solutions"}),"\n",(0,s.jsx)(n.h3,{id:"issue-sensor-data-not-publishing",children:"Issue: Sensor Data Not Publishing"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Symptoms"}),": No data on sensor topics\r\n",(0,s.jsx)(n.strong,{children:"Solutions"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Verify Gazebo plugins are correctly configured in URDF"}),"\n",(0,s.jsx)(n.li,{children:"Check that Gazebo simulation is running"}),"\n",(0,s.jsx)(n.li,{children:"Ensure robot is properly spawned in the world"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"issue-invalid-data-values",children:"Issue: Invalid Data Values"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Symptoms"}),": NaN, infinity, or out-of-range values\r\n",(0,s.jsx)(n.strong,{children:"Solutions"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Check sensor configuration parameters in URDF"}),"\n",(0,s.jsx)(n.li,{children:"Verify physics properties of objects in the world"}),"\n",(0,s.jsx)(n.li,{children:"Adjust sensor noise parameters if too high"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"issue-delayed-or-stale-data",children:"Issue: Delayed or Stale Data"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Symptoms"}),": Old timestamps, delayed updates\r\n",(0,s.jsx)(n.strong,{children:"Solutions"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Check simulation update rates"}),"\n",(0,s.jsx)(n.li,{children:"Verify network QoS settings"}),"\n",(0,s.jsx)(n.li,{children:"Adjust queue sizes in publishers/subscribers"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"automated-verification-framework",children:"Automated Verification Framework"}),"\n",(0,s.jsx)(n.p,{children:"For continuous verification, implement automated checks:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\"\"\"\r\nAutomated Sensor Verification Framework\r\n\"\"\"\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import LaserScan, Image, Imu\r\nfrom std_msgs.msg import Bool\r\nimport numpy as np\r\n\r\nclass AutomatedSensorChecker(Node):\r\n    def __init__(self):\r\n        super().__init__('automated_sensor_checker')\r\n\r\n        # Publishers for verification results\r\n        self.verification_pub = self.create_publisher(Bool, '/sensor_verification_result', 10)\r\n\r\n        # Initialize verification parameters\r\n        self.verification_results = {\r\n            'lidar_valid': False,\r\n            'camera_valid': False,\r\n            'imu_valid': False\r\n        }\r\n\r\n        # Subscriptions\r\n        self.scan_sub = self.create_subscription(LaserScan, '/scan', self.scan_callback, 10)\r\n        self.image_sub = self.create_subscription(Image, '/camera/image_raw', self.image_callback, 10)\r\n        self.imu_sub = self.create_subscription(Imu, '/imu/data', self.imu_callback, 10)\r\n\r\n        # Timer for periodic verification\r\n        self.timer = self.create_timer(1.0, self.verification_timer_callback)\r\n\r\n        self.get_logger().info('Automated sensor checker started')\r\n\r\n    def scan_callback(self, msg):\r\n        # Validate LIDAR data\r\n        ranges = np.array(msg.ranges)\r\n        valid_mask = np.isfinite(ranges) & (ranges >= msg.range_min) & (ranges <= msg.range_max)\r\n        self.verification_results['lidar_valid'] = np.mean(valid_mask) > 0.95  # 95% valid readings\r\n\r\n    def image_callback(self, msg):\r\n        # Basic image validation\r\n        # In a real implementation, you'd convert and analyze the image\r\n        self.verification_results['camera_valid'] = True  # Placeholder\r\n\r\n    def imu_callback(self, msg):\r\n        # Validate IMU data\r\n        quat = msg.orientation\r\n        magnitude = np.sqrt(quat.x**2 + quat.y**2 + quat.z**2 + quat.w**2)\r\n        self.verification_results['imu_valid'] = abs(magnitude - 1.0) < 0.01\r\n\r\n    def verification_timer_callback(self):\r\n        # Overall verification result\r\n        all_valid = all(self.verification_results.values())\r\n\r\n        result_msg = Bool()\r\n        result_msg.data = all_valid\r\n        self.verification_pub.publish(result_msg)\r\n\r\n        if all_valid:\r\n            self.get_logger().info('All sensors verified successfully')\r\n        else:\r\n            self.get_logger().warn(f'Sensor verification failed: {self.verification_results}')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    checker = AutomatedSensorChecker()\r\n\r\n    try:\r\n        rclpy.spin(checker)\r\n    except KeyboardInterrupt:\r\n        checker.get_logger().info('Sensor checker stopped by user')\r\n\r\n    checker.destroy_node()\r\n    rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices-for-sensor-verification",children:"Best Practices for Sensor Verification"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Regular Testing"}),": Verify sensors regularly during development"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Baseline Comparisons"}),": Establish baseline values for normal operation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Automated Checks"}),": Implement automated verification where possible"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Documentation"}),": Keep records of verification results"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Environmental Consistency"}),": Test in consistent environments"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Incremental Verification"}),": Start simple and add complexity gradually"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"Proper sensor verification is essential for reliable robotics simulation and development. By following the methods outlined in this guide, you can ensure that your simulated sensors provide accurate and reliable data that matches real-world expectations. Regular verification helps catch issues early and ensures that your algorithms will work correctly when deployed to real robots."})]})}function m(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);