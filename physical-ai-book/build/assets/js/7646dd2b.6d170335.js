"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[5830],{2633:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>t,default:()=>m,frontMatter:()=>s,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"isaac-platform/navigation","title":"Isaac Navigation - Autonomous Navigation and Path Planning","description":"Learning Objectives","source":"@site/docs/isaac-platform/navigation.md","sourceDirName":"isaac-platform","slug":"/isaac-platform/navigation","permalink":"/./docs/isaac-platform/navigation","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/isaac-platform/navigation.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Perception Pipeline Integration with Navigation System","permalink":"/./docs/isaac-platform/perception-navigation-integration"},"next":{"title":"Navigation Validation Guide","permalink":"/./docs/isaac-platform/navigation-validation-guide"}}');var i=r(4848),o=r(7074);const s={sidebar_position:3},t="Isaac Navigation - Autonomous Navigation and Path Planning",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Conceptual Overview",id:"conceptual-overview",level:2},{value:"Navigation Stack Components",id:"navigation-stack-components",level:3},{value:"Key Navigation Concepts",id:"key-navigation-concepts",level:3},{value:"Isaac Navigation Features",id:"isaac-navigation-features",level:3},{value:"Hands-On Implementation",id:"hands-on-implementation",level:2},{value:"Installing Navigation Packages",id:"installing-navigation-packages",level:3},{value:"Basic Navigation Setup",id:"basic-navigation-setup",level:3},{value:"Creating a Navigation Configuration Package",id:"creating-a-navigation-configuration-package",level:4},{value:"Costmap Configuration",id:"costmap-configuration",level:4},{value:"Creating Navigation Launch Files",id:"creating-navigation-launch-files",level:3},{value:"Creating a Navigation Controller Node",id:"creating-a-navigation-controller-node",level:3},{value:"Creating a SLAM Integration Node",id:"creating-a-slam-integration-node",level:3},{value:"Isaac-Specific Navigation Features",id:"isaac-specific-navigation-features",level:3},{value:"Visual SLAM Integration",id:"visual-slam-integration",level:4},{value:"Testing &amp; Verification",id:"testing--verification",level:2},{value:"Running Navigation System",id:"running-navigation-system",level:3},{value:"Useful Navigation Commands",id:"useful-navigation-commands",level:3},{value:"Navigation Tuning Parameters",id:"navigation-tuning-parameters",level:3},{value:"Common Issues",id:"common-issues",level:2},{value:"Issue: Robot oscillates or cannot reach goal",id:"issue-robot-oscillates-or-cannot-reach-goal",level:3},{value:"Issue: Navigation fails with &quot;No valid path found&quot;",id:"issue-navigation-fails-with-no-valid-path-found",level:3},{value:"Issue: Robot gets stuck in local minima",id:"issue-robot-gets-stuck-in-local-minima",level:3},{value:"Issue: Localization drifts during navigation",id:"issue-localization-drifts-during-navigation",level:3},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Next Steps",id:"next-steps",level:2}];function _(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"isaac-navigation---autonomous-navigation-and-path-planning",children:"Isaac Navigation - Autonomous Navigation and Path Planning"})}),"\n",(0,i.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsx)(e.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Understand the navigation stack in ROS 2 and Isaac ecosystem"}),"\n",(0,i.jsx)(e.li,{children:"Implement SLAM (Simultaneous Localization and Mapping) systems"}),"\n",(0,i.jsx)(e.li,{children:"Create navigation pipelines for autonomous robot movement"}),"\n",(0,i.jsx)(e.li,{children:"Integrate perception data with navigation for obstacle avoidance"}),"\n",(0,i.jsx)(e.li,{children:"Configure and tune navigation parameters for optimal performance"}),"\n",(0,i.jsx)(e.li,{children:"Implement recovery behaviors and safety mechanisms"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,i.jsx)(e.p,{children:"Before starting this chapter, you should:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Have ROS 2 Humble Hawksbill installed and configured"}),"\n",(0,i.jsx)(e.li,{children:"Understand ROS 2 nodes, topics, and the navigation stack"}),"\n",(0,i.jsx)(e.li,{children:"Completed the perception chapter for sensor integration"}),"\n",(0,i.jsx)(e.li,{children:"Basic knowledge of SLAM concepts and path planning algorithms"}),"\n",(0,i.jsx)(e.li,{children:"Experience with URDF modeling and simulation"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"conceptual-overview",children:"Conceptual Overview"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Navigation"})," in robotics refers to the ability of a robot to move autonomously from one location to another while avoiding obstacles and localizing itself within its environment. The Isaac Navigation system builds upon the ROS 2 Navigation2 stack with additional optimizations and features."]}),"\n",(0,i.jsx)(e.h3,{id:"navigation-stack-components",children:"Navigation Stack Components"}),"\n",(0,i.jsx)(e.p,{children:"The navigation stack typically consists of:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Localization"}),": Determining the robot's position in the environment"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Mapping"}),": Creating a representation of the environment"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Path Planning"}),": Finding a route from start to goal"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Path Execution"}),": Following the planned path while avoiding obstacles"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Recovery"}),": Handling situations where the robot gets stuck"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"key-navigation-concepts",children:"Key Navigation Concepts"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"SLAM (Simultaneous Localization and Mapping)"}),": Building a map while localizing"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"AMCL (Adaptive Monte Carlo Localization)"}),": Probabilistic localization in known maps"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Costmaps"}),": 2D/3D representations of the environment with obstacle information"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Path Planners"}),": Global and local planners for route computation"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Controllers"}),": Low-level systems to execute planned paths"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"isaac-navigation-features",children:"Isaac Navigation Features"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"GPU Acceleration"}),": Optimized algorithms for NVIDIA hardware"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Deep Learning Integration"}),": ML-based perception and planning"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Multi-Sensor Fusion"}),": Integration of various sensor types"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Real-time Performance"}),": Optimized for real-time applications"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Simulation Integration"}),": Seamless transition from sim to real hardware"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"hands-on-implementation",children:"Hands-On Implementation"}),"\n",(0,i.jsx)(e.h3,{id:"installing-navigation-packages",children:"Installing Navigation Packages"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"# Install Navigation2 packages\r\nsudo apt update\r\nsudo apt install ros-humble-navigation2 ros-humble-nav2-bringup\r\nsudo apt install ros-humble-slam-toolbox ros-humble-navigation-msgs\r\nsudo apt install ros-humble-robot-localization ros-humble-interactive-markers\r\n\r\n# For Isaac-specific navigation\r\ncd ~/isaac_ros_ws/src\r\ngit clone -b ros2-humble https://github.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam.git\r\ngit clone -b ros2-humble https://github.com/NVIDIA-ISAAC-ROS/isaac_ros_occupancy_grid_localizer.git\r\n\r\n# Build the workspace\r\ncd ~/isaac_ros_ws\r\nrosdep install --from-paths src --ignore-src -r -y\r\ncolcon build\n"})}),"\n",(0,i.jsx)(e.h3,{id:"basic-navigation-setup",children:"Basic Navigation Setup"}),"\n",(0,i.jsx)(e.h4,{id:"creating-a-navigation-configuration-package",children:"Creating a Navigation Configuration Package"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"cd ~/ros2_ws/src\r\nros2 pkg create --build-type ament_python navigation_config\n"})}),"\n",(0,i.jsx)(e.h4,{id:"costmap-configuration",children:"Costmap Configuration"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Create navigation_config/config/costmap_common_params.yaml:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:"# Common costmap parameters\r\nmap_topic: /map\r\ntrack_unknown_space: true\r\nuse_dijkstra: true\r\nuse_grid_path: false\r\n\r\nalways_send_full_costmap: true\r\n\r\nunknown_cost_value: 255\r\nlethal_cost_threshold: 254\r\n\r\n# Robot footprint\r\nrobot_radius: 0.3  # For circular robots\r\n# footprint: [[x1, y1], [x2, y2], ...]  # For polygonal robots\r\n\r\n# Obstacle parameters\r\nobstacle_layer:\r\n  enabled: true\r\n  obstacle_range: 3.0\r\n  raytrace_range: 4.0\r\n  observation_sources: laser_scan\r\n  laser_scan:\r\n    topic: /scan\r\n    sensor_frame: laser_link\r\n    observation_persistence: 0.0\r\n    max_obstacle_height: 2.0\r\n    min_obstacle_height: 0.0\r\n    inf_is_valid: true\r\n    clearing: true\r\n    marking: true\r\n\r\n# Inflation layer\r\ninflation_layer:\r\n  enabled: true\r\n  cost_scaling_factor: 3.0\r\n  inflation_radius: 0.55\n"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Create navigation_config/config/local_costmap_params.yaml:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:'local_costmap:\r\n  global_frame: odom\r\n  robot_base_frame: base_link\r\n  update_frequency: 10.0\r\n  publish_frequency: 10.0\r\n  static_map: false\r\n  rolling_window: true\r\n  width: 3\r\n  height: 3\r\n  resolution: 0.05\r\n  origin_x: 0.0\r\n  origin_y: 0.0\r\n  plugins:\r\n    - {name: obstacle_layer, type: "nav2_costmap_2d::ObstacleLayer"}\r\n    - {name: inflation_layer, type: "nav2_costmap_2d::InflationLayer"}\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Create navigation_config/config/global_costmap_params.yaml:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:'global_costmap:\r\n  global_frame: map\r\n  robot_base_frame: base_link\r\n  update_frequency: 1.0\r\n  publish_frequency: 1.0\r\n  static_map: true\r\n  rolling_window: false\r\n  plugins:\r\n    - {name: static_layer, type: "nav2_costmap_2d::StaticLayer"}\r\n    - {name: obstacle_layer, type: "nav2_costmap_2d::ObstacleLayer"}\r\n    - {name: inflation_layer, type: "nav2_costmap_2d::InflationLayer"}\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Create navigation_config/config/nav2_params.yaml:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:'amcl:\r\n  ros__parameters:\r\n    use_sim_time: False\r\n    alpha1: 0.2\r\n    alpha2: 0.2\r\n    alpha3: 0.2\r\n    alpha4: 0.2\r\n    alpha5: 0.2\r\n    base_frame_id: "base_link"\r\n    beam_skip_distance: 0.5\r\n    beam_skip_error_threshold: 0.9\r\n    beam_skip_threshold: 0.3\r\n    do_beamskip: false\r\n    global_frame_id: "map"\r\n    lambda_short: 0.1\r\n    laser_likelihood_max_dist: 2.0\r\n    laser_max_range: 100.0\r\n    laser_min_range: -1.0\r\n    laser_model_type: "likelihood_field"\r\n    max_beams: 60\r\n    max_particles: 2000\r\n    min_particles: 500\r\n    odom_frame_id: "odom"\r\n    pf_err: 0.05\r\n    pf_z: 0.99\r\n    recovery_alpha_fast: 0.0\r\n    recovery_alpha_slow: 0.0\r\n    resample_interval: 1\r\n    robot_model_type: "nav2_amcl::DifferentialMotionModel"\r\n    save_pose_rate: 0.5\r\n    sigma_hit: 0.2\r\n    tf_broadcast: true\r\n    transform_tolerance: 1.0\r\n    update_min_a: 0.2\r\n    update_min_d: 0.25\r\n    z_hit: 0.5\r\n    z_max: 0.05\r\n    z_rand: 0.5\r\n    z_short: 0.05\r\n    scan_topic: scan\r\n\r\namcl_map_client:\r\n  ros__parameters:\r\n    use_sim_time: False\r\n\r\namcl_rclcpp_node:\r\n  ros__parameters:\r\n    use_sim_time: False\r\n\r\nbt_navigator:\r\n  ros__parameters:\r\n    use_sim_time: False\r\n    global_frame: map\r\n    robot_base_frame: base_link\r\n    odom_topic: /odom\r\n    bt_loop_duration: 10\r\n    default_server_timeout: 20\r\n    enable_groot_monitoring: True\r\n    groot_zmq_publisher_port: 1666\r\n    groot_zmq_server_port: 1667\r\n    default_nav_through_poses_bt_xml: nav2_bt_navigator/nav_through_poses_w_replanning_and_recovery.xml\r\n    default_nav_to_pose_bt_xml: nav2_bt_navigator/nav_to_pose_w_replanning_and_recovery.xml\r\n    plugin_lib_names:\r\n    - nav2_compute_path_to_pose_action_bt_node\r\n    - nav2_compute_path_through_poses_action_bt_node\r\n    - nav2_smooth_path_action_bt_node\r\n    - nav2_follow_path_action_bt_node\r\n    - nav2_spin_action_bt_node\r\n    - nav2_wait_action_bt_node\r\n    - nav2_assisted_teleop_action_bt_node\r\n    - nav2_back_up_action_bt_node\r\n    - nav2_drive_on_heading_bt_node\r\n    - nav2_clear_costmap_service_bt_node\r\n    - nav2_is_stuck_condition_bt_node\r\n    - nav2_goal_reached_condition_bt_node\r\n    - nav2_goal_updated_condition_bt_node\r\n    - nav2_initial_pose_received_condition_bt_node\r\n    - nav2_reinitialize_global_localization_service_bt_node\r\n    - nav2_rate_controller_bt_node\r\n    - nav2_distance_controller_bt_node\r\n    - nav2_speed_controller_bt_node\r\n    - nav2_truncate_path_action_bt_node\r\n    - nav2_truncate_path_local_action_bt_node\r\n    - nav2_goal_updater_node_bt_node\r\n    - nav2_recovery_node_bt_node\r\n    - nav2_pipeline_sequence_bt_node\r\n    - nav2_round_robin_node_bt_node\r\n    - nav2_transform_available_condition_bt_node\r\n    - nav2_time_expired_condition_bt_node\r\n    - nav2_path_expiring_timer_condition\r\n    - nav2_distance_traveled_condition_bt_node\r\n    - nav2_single_trigger_bt_node\r\n    - nav2_is_battery_low_condition_bt_node\r\n    - nav2_navigate_through_poses_action_bt_node\r\n    - nav2_navigate_to_pose_action_bt_node\r\n    - nav2_remove_passed_goals_action_bt_node\r\n    - nav2_planner_selector_bt_node\r\n    - nav2_controller_selector_bt_node\r\n    - nav2_goal_checker_selector_bt_node\r\n    - nav2_controller_cancel_bt_node\r\n    - nav2_path_longer_on_approach_bt_node\r\n    - nav2_wait_cancel_bt_node\r\n    - nav2_spin_cancel_bt_node\r\n    - nav2_back_up_cancel_bt_node\r\n    - nav2_assisted_teleop_cancel_bt_node\r\n    - nav2_drive_on_heading_cancel_bt_node\r\n\r\nbt_navigator_rclcpp_node:\r\n  ros__parameters:\r\n    use_sim_time: False\r\n\r\ncontroller_server:\r\n  ros__parameters:\r\n    use_sim_time: False\r\n    controller_frequency: 20.0\r\n    min_x_velocity_threshold: 0.001\r\n    min_y_velocity_threshold: 0.5\r\n    min_theta_velocity_threshold: 0.001\r\n    failure_tolerance: 0.3\r\n    progress_checker_plugin: "progress_checker"\r\n    goal_checker_plugins: ["general_goal_checker"] # "precise_goal_checker"\r\n    controller_plugins: ["FollowPath"]\r\n\r\n    # Progress checker parameters\r\n    progress_checker:\r\n      plugin: "nav2_controller::SimpleProgressChecker"\r\n      required_movement_radius: 0.5\r\n      movement_time_allowance: 10.0\r\n\r\n    # Goal checker parameters\r\n    general_goal_checker:\r\n      plugin: "nav2_controller::SimpleGoalChecker"\r\n      xy_goal_tolerance: 0.25\r\n      yaw_goal_tolerance: 0.25\r\n      stateful: True\r\n\r\n    # Controller parameters\r\n    FollowPath:\r\n      plugin: "nav2_rotation_shim::RotationShimController"\r\n      rotational_scaler: 1.5\r\n      velocity_deadband: 0.05\r\n      velocity_scale_to_min: 0.25\r\n      velocity_scaling_type: 0 # 0: Disabled, 1: Time, 2: Distance\r\n      min_approach_velocity: 0.05\r\n      max_allowed_time_to_collision: 1.0\r\n      carrot_planner:\r\n        plugin: "nav2_navfn_planner::NavfnPlanner"\r\n        tolerance: 0.5\r\n        use_astar: false\r\n        allow_unknown: true\r\n\r\nlocal_costmap:\r\n  local_costmap:\r\n    ros__parameters:\r\n      update_frequency: 5.0\r\n      publish_frequency: 2.0\r\n      global_frame: odom\r\n      robot_base_frame: base_link\r\n      use_sim_time: False\r\n      rolling_window: true\r\n      width: 3\r\n      height: 3\r\n      resolution: 0.05\r\n      robot_radius: 0.22\r\n      plugins: ["obstacle_layer", "inflation_layer"]\r\n      inflation_layer:\r\n        plugin: "nav2_costmap_2d::InflationLayer"\r\n        cost_scaling_factor: 3.0\r\n        inflation_radius: 0.55\r\n      obstacle_layer:\r\n        plugin: "nav2_costmap_2d::ObstacleLayer"\r\n        enabled: True\r\n        observation_sources: scan\r\n        scan:\r\n          topic: /scan\r\n          max_obstacle_height: 2.0\r\n          clearing: True\r\n          marking: True\r\n          data_type: "LaserScan"\r\n          raytrace_max_range: 3.0\r\n          raytrace_min_range: 0.0\r\n          obstacle_max_range: 2.5\r\n          obstacle_min_range: 0.0\r\n      always_send_full_costmap: True\r\n\r\nglobal_costmap:\r\n  global_costmap:\r\n    ros__parameters:\r\n      update_frequency: 1.0\r\n      publish_frequency: 1.0\r\n      global_frame: map\r\n      robot_base_frame: base_link\r\n      use_sim_time: False\r\n      robot_radius: 0.22\r\n      resolution: 0.05\r\n      track_unknown_space: true\r\n      plugins: ["static_layer", "obstacle_layer", "inflation_layer"]\r\n      obstacle_layer:\r\n        plugin: "nav2_costmap_2d::ObstacleLayer"\r\n        enabled: True\r\n        observation_sources: scan\r\n        scan:\r\n          topic: /scan\r\n          max_obstacle_height: 2.0\r\n          clearing: True\r\n          marking: True\r\n          data_type: "LaserScan"\r\n          raytrace_max_range: 3.0\r\n          raytrace_min_range: 0.0\r\n          obstacle_max_range: 2.5\r\n          obstacle_min_range: 0.0\r\n      static_layer:\r\n        plugin: "nav2_costmap_2d::StaticLayer"\r\n        map_subscribe_transient_local: True\r\n      inflation_layer:\r\n        plugin: "nav2_costmap_2d::InflationLayer"\r\n        cost_scaling_factor: 3.0\r\n        inflation_radius: 0.55\r\n      always_send_full_costmap: True\r\n\r\nmap_server:\r\n  ros__parameters:\r\n    use_sim_time: False\r\n    yaml_filename: "turtlebot3_world.yaml"\r\n\r\nmap_saver:\r\n  ros__parameters:\r\n    use_sim_time: False\r\n    save_map_timeout: 5.0\r\n    free_thresh_default: 0.25\r\n    occupied_thresh_default: 0.65\r\n\r\nplanner_server:\r\n  ros__parameters:\r\n    expected_planner_frequency: 20.0\r\n    use_sim_time: False\r\n    planner_plugins: ["GridBased"]\r\n    GridBased:\r\n      plugin: "nav2_navfn_planner::NavfnPlanner"\r\n      tolerance: 0.5\r\n      use_astar: false\r\n      allow_unknown: true\r\n\r\nsmoother_server:\r\n  ros__parameters:\r\n    use_sim_time: False\r\n    smoother_plugins: ["simple_smoother"]\r\n    simple_smoother:\r\n      plugin: "nav2_smoother::SimpleSmoother"\r\n      tolerance: 0.01\r\n      max_its: 1000\r\n      do_refinement: True\r\n\r\nbehavior_server:\r\n  ros__parameters:\r\n    costmap_topic: local_costmap/costmap_raw\r\n    footprint_topic: local_costmap/published_footprint\r\n    cycle_frequency: 10.0\r\n    behavior_plugins: ["spin", "backup", "wait"]\r\n    spin:\r\n      plugin: "nav2_behaviors::Spin"\r\n      spin_dist: 1.57\r\n    backup:\r\n      plugin: "nav2_behaviors::BackUp"\r\n      backup_dist: 0.15\r\n      backup_speed: 0.025\r\n    wait:\r\n      plugin: "nav2_behaviors::Wait"\r\n      wait_duration: 1.0\r\n\r\nwaypoint_follower:\r\n  ros__parameters:\r\n    loop_rate: 20\r\n    stop_on_failure: false\r\n    waypoint_task_executor_plugin: "wait_at_waypoint"\r\n    wait_at_waypoint:\r\n      plugin: "nav2_waypoint_follower::WaitAtWaypoint"\r\n      enabled: true\r\n      wait_time: 1\n'})}),"\n",(0,i.jsx)(e.h3,{id:"creating-navigation-launch-files",children:"Creating Navigation Launch Files"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Create navigation_config/launch/navigation_launch.py:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"from launch import LaunchDescription\r\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription\r\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\r\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution\r\nfrom launch_ros.actions import Node\r\nfrom launch_ros.substitutions import FindPackageShare\r\n\r\n\r\ndef generate_launch_description():\r\n    # Declare launch arguments\r\n    use_sim_time = DeclareLaunchArgument(\r\n        'use_sim_time',\r\n        default_value='false',\r\n        description='Use simulation time if true'\r\n    )\r\n\r\n    params_file = DeclareLaunchArgument(\r\n        'params_file',\r\n        default_value=PathJoinSubstitution([\r\n            FindPackageShare('navigation_config'),\r\n            'config',\r\n            'nav2_params.yaml'\r\n        ]),\r\n        description='Full path to params file for navigation nodes'\r\n    )\r\n\r\n    # Navigation server\r\n    navigation_server = Node(\r\n        package='nav2_controller',\r\n        executable='controller_server',\r\n        name='controller_server',\r\n        parameters=[LaunchConfiguration('params_file'), {'use_sim_time': LaunchConfiguration('use_sim_time')}],\r\n        remappings=[('/cmd_vel', '/cmd_vel_nav')]\r\n    )\r\n\r\n    # Planner server\r\n    planner_server = Node(\r\n        package='nav2_planner',\r\n        executable='planner_server',\r\n        name='planner_server',\r\n        parameters=[LaunchConfiguration('params_file'), {'use_sim_time': LaunchConfiguration('use_sim_time')}],\r\n        remappings=[('~/global_costmap/costmap', 'global_costmap/costmap'),\r\n                   ('~/global_costmap/costmap_updates', 'global_costmap/costmap_updates'),\r\n                   ('~/local_costmap/costmap', 'local_costmap/costmap'),\r\n                   ('~/local_costmap/costmap_updates', 'local_costmap/costmap_updates')]\r\n    )\r\n\r\n    # Recoveries server\r\n    recoveries_server = Node(\r\n        package='nav2_recoveries',\r\n        executable='recoveries_server',\r\n        name='recoveries_server',\r\n        parameters=[LaunchConfiguration('params_file'), {'use_sim_time': LaunchConfiguration('use_sim_time')}]\r\n    )\r\n\r\n    # BT navigator\r\n    bt_navigator = Node(\r\n        package='nav2_bt_navigator',\r\n        executable='bt_navigator',\r\n        name='bt_navigator',\r\n        parameters=[LaunchConfiguration('params_file'), {'use_sim_time': LaunchConfiguration('use_sim_time')}],\r\n        remappings=[('~/local_costmap/costmap', 'local_costmap/costmap'),\r\n                   ('~/local_costmap/costmap_updates', 'local_costmap/costmap_updates'),\r\n                   ('~/global_costmap/costmap', 'global_costmap/costmap'),\r\n                   ('~/global_costmap/costmap_updates', 'global_costmap/costmap_updates')]\r\n    )\r\n\r\n    # Lifecycle manager for navigation\r\n    lifecycle_manager = Node(\r\n        package='nav2_lifecycle_manager',\r\n        executable='lifecycle_manager',\r\n        name='lifecycle_manager_navigation',\r\n        parameters=[{'use_sim_time': LaunchConfiguration('use_sim_time')},\r\n                   {'autostart': True},\r\n                   {'node_names': ['controller_server',\r\n                                  'planner_server',\r\n                                  'recoveries_server',\r\n                                  'bt_navigator']}]\r\n    )\r\n\r\n    return LaunchDescription([\r\n        use_sim_time,\r\n        params_file,\r\n        navigation_server,\r\n        planner_server,\r\n        recoveries_server,\r\n        bt_navigator,\r\n        lifecycle_manager\r\n    ])\n"})}),"\n",(0,i.jsx)(e.h3,{id:"creating-a-navigation-controller-node",children:"Creating a Navigation Controller Node"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\r\n\"\"\"\r\nNavigation controller node that sends goals to the navigation system.\r\n\"\"\"\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom rclpy.action import ActionClient\r\nfrom geometry_msgs.msg import PoseStamped\r\nfrom nav2_msgs.action import NavigateToPose\r\nfrom std_msgs.msg import String\r\nimport random\r\n\r\n\r\nclass NavigationController(Node):\r\n    \"\"\"\r\n    Node to control navigation by sending goals to the navigation system.\r\n    \"\"\"\r\n\r\n    def __init__(self):\r\n        super().__init__('navigation_controller')\r\n\r\n        # Create action client for navigation\r\n        self.nav_client = ActionClient(self, NavigateToPose, 'navigate_to_pose')\r\n\r\n        # Create publisher for status\r\n        self.status_pub = self.create_publisher(String, 'navigation_status', 10)\r\n\r\n        # Wait for navigation server\r\n        self.get_logger().info('Waiting for navigation server...')\r\n        self.nav_client.wait_for_server()\r\n\r\n        # Timer to send goals periodically\r\n        self.timer = self.create_timer(10.0, self.send_goal)\r\n\r\n        # Goal counter\r\n        self.goal_count = 0\r\n\r\n        self.get_logger().info('Navigation controller initialized')\r\n\r\n    def send_goal(self):\r\n        \"\"\"Send a random goal to the navigation system.\"\"\"\r\n        # Wait for server\r\n        if not self.nav_client.wait_for_server(timeout_sec=1.0):\r\n            self.get_logger().error('Navigation server not available')\r\n            return\r\n\r\n        # Create a goal message\r\n        goal_msg = NavigateToPose.Goal()\r\n        goal_msg.pose.header.frame_id = 'map'\r\n        goal_msg.pose.header.stamp = self.get_clock().now().to_msg()\r\n\r\n        # Set a random goal position (in a real scenario, these would be meaningful coordinates)\r\n        goal_msg.pose.pose.position.x = random.uniform(-5.0, 5.0)\r\n        goal_msg.pose.pose.position.y = random.uniform(-5.0, 5.0)\r\n        goal_msg.pose.pose.position.z = 0.0\r\n\r\n        # Set orientation (pointing along positive x-axis)\r\n        goal_msg.pose.pose.orientation.x = 0.0\r\n        goal_msg.pose.pose.orientation.y = 0.0\r\n        goal_msg.pose.pose.orientation.z = 0.0\r\n        goal_msg.pose.pose.orientation.w = 1.0\r\n\r\n        # Send the goal\r\n        self.get_logger().info(f'Sending navigation goal #{self.goal_count}: '\r\n                              f'({goal_msg.pose.pose.position.x:.2f}, {goal_msg.pose.pose.position.y:.2f})')\r\n\r\n        send_goal_future = self.nav_client.send_goal_async(\r\n            goal_msg,\r\n            feedback_callback=self.feedback_callback\r\n        )\r\n\r\n        send_goal_future.add_done_callback(self.goal_response_callback)\r\n        self.goal_count += 1\r\n\r\n    def goal_response_callback(self, future):\r\n        \"\"\"Handle the response from the navigation server.\"\"\"\r\n        goal_handle = future.result()\r\n        if not goal_handle.accepted:\r\n            self.get_logger().info('Goal rejected')\r\n            return\r\n\r\n        self.get_logger().info('Goal accepted')\r\n        get_result_future = goal_handle.get_result_async()\r\n        get_result_future.add_done_callback(self.get_result_callback)\r\n\r\n    def get_result_callback(self, future):\r\n        \"\"\"Handle the result from the navigation server.\"\"\"\r\n        result = future.result().result\r\n        status = future.result().status\r\n        self.get_logger().info(f'Navigation completed with status: {status}')\r\n\r\n        status_msg = String()\r\n        if status == 3:  # SUCCEEDED\r\n            status_msg.data = 'Navigation succeeded'\r\n        elif status == 4:  # CANCELED\r\n            status_msg.data = 'Navigation canceled'\r\n        else:\r\n            status_msg.data = f'Navigation failed with status: {status}'\r\n\r\n        self.status_pub.publish(status_msg)\r\n\r\n    def feedback_callback(self, feedback_msg):\r\n        \"\"\"Handle feedback from the navigation server.\"\"\"\r\n        feedback = feedback_msg.feedback\r\n        # In a real implementation, you might process feedback here\r\n        self.get_logger().debug('Received feedback')\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = NavigationController()\r\n\r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        node.get_logger().info('Navigation controller stopped by user')\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,i.jsx)(e.h3,{id:"creating-a-slam-integration-node",children:"Creating a SLAM Integration Node"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n\r\n"""\r\nSLAM integration node that combines mapping with navigation.\r\n"""\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import LaserScan\r\nfrom nav_msgs.msg import OccupancyGrid, Odometry\r\nfrom geometry_msgs.msg import PoseWithCovarianceStamped\r\nfrom tf2_ros import TransformBroadcaster\r\nimport numpy as np\r\n\r\n\r\nclass SLAMIntegrationNode(Node):\r\n    """\r\n    Node to integrate SLAM with navigation.\r\n    """\r\n\r\n    def __init__(self):\r\n        super().__init__(\'slam_integration_node\')\r\n\r\n        # Create subscribers\r\n        self.scan_sub = self.create_subscription(\r\n            LaserScan,\r\n            \'/scan\',\r\n            self.scan_callback,\r\n            10\r\n        )\r\n\r\n        self.odom_sub = self.create_subscription(\r\n            Odometry,\r\n            \'/odom\',\r\n            self.odom_callback,\r\n            10\r\n        )\r\n\r\n        # Create publishers\r\n        self.map_pub = self.create_publisher(\r\n            OccupancyGrid,\r\n            \'/map\',\r\n            10\r\n        )\r\n\r\n        self.initial_pose_pub = self.create_publisher(\r\n            PoseWithCovarianceStamped,\r\n            \'/initialpose\',\r\n            10\r\n        )\r\n\r\n        # Initialize variables\r\n        self.current_pose = None\r\n        self.map_resolution = 0.05  # meters per cell\r\n        self.map_width = 400  # cells\r\n        self.map_height = 400  # cells\r\n        self.map_origin_x = -10.0  # meters\r\n        self.map_origin_y = -10.0  # meters\r\n\r\n        # Create empty map\r\n        self.map_data = np.full(self.map_width * self.map_height, -1, dtype=np.int8)  # -1 = unknown\r\n\r\n        self.get_logger().info(\'SLAM integration node initialized\')\r\n\r\n    def scan_callback(self, msg):\r\n        """Process laser scan data for mapping."""\r\n        if self.current_pose is None:\r\n            return\r\n\r\n        # Convert laser scan to map coordinates and update map\r\n        # This is a simplified approach - real SLAM would be more complex\r\n        robot_x = self.current_pose.pose.pose.position.x\r\n        robot_y = self.current_pose.pose.pose.position.y\r\n        robot_yaw = self.get_yaw_from_quaternion(self.current_pose.pose.pose.orientation)\r\n\r\n        # Process each laser reading\r\n        for i, range_val in enumerate(msg.ranges):\r\n            if not (msg.range_min < range_val < msg.range_max):\r\n                continue  # Skip invalid ranges\r\n\r\n            # Calculate angle of this reading\r\n            angle = msg.angle_min + i * msg.angle_increment + robot_yaw\r\n\r\n            # Calculate end point of this laser beam\r\n            end_x = robot_x + range_val * np.cos(angle)\r\n            end_y = robot_y + range_val * np.sin(angle)\r\n\r\n            # Convert to map coordinates\r\n            map_x = int((end_x - self.map_origin_x) / self.map_resolution)\r\n            map_y = int((end_y - self.map_origin_y) / self.map_resolution)\r\n\r\n            # Check bounds\r\n            if 0 <= map_x < self.map_width and 0 <= map_y < self.map_height:\r\n                # Mark as occupied (value 100)\r\n                idx = map_y * self.map_width + map_x\r\n                self.map_data[idx] = 100\r\n\r\n    def odom_callback(self, msg):\r\n        """Process odometry data."""\r\n        self.current_pose = msg\r\n        # Could also update robot pose in map frame here\r\n\r\n    def get_yaw_from_quaternion(self, quat):\r\n        """Extract yaw from quaternion."""\r\n        siny_cosp = 2 * (quat.w * quat.z + quat.x * quat.y)\r\n        cosy_cosp = 1 - 2 * (quat.y * quat.y + quat.z * quat.z)\r\n        return np.arctan2(siny_cosp, cosy_cosp)\r\n\r\n    def publish_map(self):\r\n        """Publish the occupancy grid map."""\r\n        if self.map_data is None:\r\n            return\r\n\r\n        # Create occupancy grid message\r\n        map_msg = OccupancyGrid()\r\n        map_msg.header.stamp = self.get_clock().now().to_msg()\r\n        map_msg.header.frame_id = \'map\'\r\n\r\n        map_msg.info.resolution = self.map_resolution\r\n        map_msg.info.width = self.map_width\r\n        map_msg.info.height = self.map_height\r\n        map_msg.info.origin.position.x = self.map_origin_x\r\n        map_msg.info.origin.position.y = self.map_origin_y\r\n        map_msg.info.origin.position.z = 0.0\r\n        map_msg.info.origin.orientation.x = 0.0\r\n        map_msg.info.origin.orientation.y = 0.0\r\n        map_msg.info.origin.orientation.z = 0.0\r\n        map_msg.info.origin.orientation.w = 1.0\r\n\r\n        # Convert numpy array to list for message\r\n        map_msg.data = self.map_data.tolist()\r\n\r\n        # Publish map\r\n        self.map_pub.publish(map_msg)\r\n\r\n        self.get_logger().info(f\'Published map with {len(self.map_data)} cells\')\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = SLAMIntegrationNode()\r\n\r\n    # Timer to publish map periodically\r\n    node.create_timer(2.0, node.publish_map)\r\n\r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        node.get_logger().info(\'SLAM integration node stopped by user\')\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,i.jsx)(e.h3,{id:"isaac-specific-navigation-features",children:"Isaac-Specific Navigation Features"}),"\n",(0,i.jsx)(e.h4,{id:"visual-slam-integration",children:"Visual SLAM Integration"}),"\n",(0,i.jsx)(e.p,{children:"Isaac provides advanced visual SLAM capabilities:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n\r\n"""\r\nIsaac Visual SLAM integration node.\r\n"""\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import Image, CameraInfo\r\nfrom geometry_msgs.msg import PoseStamped\r\nfrom nav_msgs.msg import Odometry\r\nfrom cv_bridge import CvBridge\r\nimport numpy as np\r\n\r\n\r\nclass IsaacVisualSLAMNode(Node):\r\n    """\r\n    Node to demonstrate Isaac Visual SLAM concepts.\r\n    """\r\n\r\n    def __init__(self):\r\n        super().__init__(\'isaac_visual_slam_node\')\r\n\r\n        # Create subscribers for stereo camera or RGB-D\r\n        self.left_image_sub = self.create_subscription(\r\n            Image,\r\n            \'/camera/left/image_rect_color\',\r\n            self.left_image_callback,\r\n            10\r\n        )\r\n\r\n        self.right_image_sub = self.create_subscription(\r\n            Image,\r\n            \'/camera/right/image_rect_color\',\r\n            self.right_image_callback,\r\n            10\r\n        )\r\n\r\n        self.camera_info_sub = self.create_subscription(\r\n            CameraInfo,\r\n            \'/camera/left/camera_info\',\r\n            self.camera_info_callback,\r\n            10\r\n        )\r\n\r\n        # Create publisher for visual odometry\r\n        self.odom_pub = self.create_publisher(\r\n            Odometry,\r\n            \'/visual_odom\',\r\n            10\r\n        )\r\n\r\n        # Initialize variables\r\n        self.bridge = CvBridge()\r\n        self.left_image = None\r\n        self.right_image = None\r\n        self.camera_info = None\r\n        self.previous_pose = None\r\n\r\n        self.get_logger().info(\'Isaac Visual SLAM node initialized\')\r\n\r\n    def left_image_callback(self, msg):\r\n        """Process left camera image."""\r\n        try:\r\n            self.left_image = self.bridge.imgmsg_to_cv2(msg, "bgr8")\r\n            self.process_stereo_pair()\r\n        except Exception as e:\r\n            self.get_logger().error(f\'Error processing left image: {e}\')\r\n\r\n    def right_image_callback(self, msg):\r\n        """Process right camera image."""\r\n        try:\r\n            self.right_image = self.bridge.imgmsg_to_cv2(msg, "bgr8")\r\n            self.process_stereo_pair()\r\n        except Exception as e:\r\n            self.get_logger().error(f\'Error processing right image: {e}\')\r\n\r\n    def camera_info_callback(self, msg):\r\n        """Process camera information."""\r\n        self.camera_info = msg\r\n\r\n    def process_stereo_pair(self):\r\n        """Process stereo images for visual SLAM."""\r\n        if self.left_image is None or self.right_image is None or self.camera_info is None:\r\n            return\r\n\r\n        # In a real implementation, you would use Isaac\'s visual SLAM pipeline\r\n        # This is a simplified example showing the concept\r\n\r\n        # Compute stereo disparity (simplified)\r\n        # In practice, Isaac uses optimized GPU-accelerated algorithms\r\n        gray_left = cv2.cvtColor(self.left_image, cv2.COLOR_BGR2GRAY)\r\n        gray_right = cv2.cvtColor(self.right_image, cv2.COLOR_BGR2GRAY)\r\n\r\n        # Use OpenCV\'s stereo matcher as an example\r\n        stereo = cv2.StereoSGBM_create(\r\n            minDisparity=0,\r\n            numDisparities=16*10,  # Must be divisible by 16\r\n            blockSize=5,\r\n            P1=8*3*5**2,\r\n            P2=32*3*5**2,\r\n            disp12MaxDiff=1,\r\n            uniquenessRatio=15,\r\n            speckleWindowSize=0,\r\n            speckleRange=2,\r\n            preFilterCap=63,\r\n            mode=cv2.STEREO_SGBM_MODE_SGBM_3WAY\r\n        )\r\n\r\n        disparity = stereo.compute(gray_left, gray_right).astype(np.float32) / 16.0\r\n\r\n        # Convert disparity to 3D points and estimate motion\r\n        # This would integrate with the navigation system in a real implementation\r\n\r\n        # Publish odometry estimate\r\n        odom_msg = Odometry()\r\n        odom_msg.header.stamp = self.get_clock().now().to_msg()\r\n        odom_msg.header.frame_id = \'odom\'\r\n        odom_msg.child_frame_id = \'base_link\'\r\n\r\n        # Set pose (simplified - would come from actual SLAM algorithm)\r\n        if self.previous_pose is None:\r\n            # Initial pose\r\n            odom_msg.pose.pose.position.x = 0.0\r\n            odom_msg.pose.pose.position.y = 0.0\r\n            odom_msg.pose.pose.position.z = 0.0\r\n            odom_msg.pose.pose.orientation.w = 1.0\r\n            self.previous_pose = odom_msg.pose.pose\r\n        else:\r\n            # Update based on estimated motion\r\n            odom_msg.pose.pose.position.x = self.previous_pose.position.x + 0.01\r\n            odom_msg.pose.pose.position.y = self.previous_pose.position.y + 0.01\r\n            odom_msg.pose.pose.orientation.w = 1.0\r\n            self.previous_pose = odom_msg.pose.pose\r\n\r\n        # Set velocity (simplified)\r\n        odom_msg.twist.twist.linear.x = 0.1\r\n        odom_msg.twist.twist.angular.z = 0.05\r\n\r\n        self.odom_pub.publish(odom_msg)\r\n\r\n        self.get_logger().info(\'Processed stereo pair for visual SLAM\')\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = IsaacVisualSLAMNode()\r\n\r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        node.get_logger().info(\'Visual SLAM node stopped by user\')\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,i.jsx)(e.h2,{id:"testing--verification",children:"Testing & Verification"}),"\n",(0,i.jsx)(e.h3,{id:"running-navigation-system",children:"Running Navigation System"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.strong,{children:"Start your robot with sensors:"})}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"# This could be a real robot or simulation\r\n# Make sure you have /scan, /odom, /tf topics available\n"})}),"\n",(0,i.jsxs)(e.ol,{start:"2",children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.strong,{children:"Launch navigation:"})}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"cd ~/ros2_ws\r\nsource install/setup.bash\r\nros2 launch navigation_config navigation_launch.py\n"})}),"\n",(0,i.jsxs)(e.ol,{start:"3",children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.strong,{children:"Send navigation goals:"})}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:'# Using navigation controller node\r\nros2 run navigation_config navigation_controller\r\n\r\n# Or manually with RViz2\r\nros2 run rviz2 rviz2\r\n# Then use the "Navigation 2" plugin to send goals\n'})}),"\n",(0,i.jsxs)(e.ol,{start:"4",children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.strong,{children:"Monitor navigation performance:"})}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"# Check navigation status\r\nros2 topic echo /navigation_status\r\n\r\n# Monitor costmaps\r\nros2 run rviz2 rviz2  # Add costmap displays\r\n\r\n# Check robot position\r\nros2 topic echo /amcl_pose\n"})}),"\n",(0,i.jsx)(e.h3,{id:"useful-navigation-commands",children:"Useful Navigation Commands"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.strong,{children:"Check navigation topics:"})}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:'ros2 topic list | grep -E "(nav|costmap|localization)"\n'})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.strong,{children:"Send a goal programmatically:"})}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"ros2 action send_goal /navigate_to_pose nav2_msgs/action/NavigateToPose \"{pose: {header: {frame_id: 'map'}, pose: {position: {x: 1.0, y: 1.0, z: 0.0}, orientation: {w: 1.0}}}}\"\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.strong,{children:"Reset navigation:"})}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"ros2 service call /global_costmap/clear_entirely_global_costmap std_srvs/srv/Empty\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.strong,{children:"Monitor navigation performance:"})}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"# Use navigation tools\r\nros2 run nav2_util navigation_metrics\n"})}),"\n",(0,i.jsx)(e.h3,{id:"navigation-tuning-parameters",children:"Navigation Tuning Parameters"}),"\n",(0,i.jsx)(e.p,{children:"Navigation performance can be tuned by adjusting parameters in the config files:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Costmap resolution"}),": Higher resolution = more precise but slower"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Inflation radius"}),": Larger radius = safer but more conservative paths"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Controller frequency"}),": Higher frequency = more responsive but more CPU usage"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Goal tolerances"}),": Smaller values = more precise goal achievement"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"common-issues",children:"Common Issues"}),"\n",(0,i.jsx)(e.h3,{id:"issue-robot-oscillates-or-cannot-reach-goal",children:"Issue: Robot oscillates or cannot reach goal"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Solution"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Check costmap inflation parameters"}),"\n",(0,i.jsx)(e.li,{children:"Verify robot footprint is correctly configured"}),"\n",(0,i.jsx)(e.li,{children:"Adjust controller parameters (XY goal tolerance, yaw goal tolerance)"}),"\n",(0,i.jsx)(e.li,{children:"Check that the goal is in a navigable area"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"issue-navigation-fails-with-no-valid-path-found",children:'Issue: Navigation fails with "No valid path found"'}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Solution"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Verify map quality and resolution"}),"\n",(0,i.jsx)(e.li,{children:"Check that obstacles are properly detected"}),"\n",(0,i.jsx)(e.li,{children:"Ensure global planner can find a path"}),"\n",(0,i.jsx)(e.li,{children:"Verify robot can physically navigate to the goal"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"issue-robot-gets-stuck-in-local-minima",children:"Issue: Robot gets stuck in local minima"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Solution"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Improve local planner parameters"}),"\n",(0,i.jsx)(e.li,{children:"Add recovery behaviors"}),"\n",(0,i.jsx)(e.li,{children:"Use more sophisticated path planning algorithms"}),"\n",(0,i.jsx)(e.li,{children:"Check for proper obstacle inflation"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"issue-localization-drifts-during-navigation",children:"Issue: Localization drifts during navigation"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Solution"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Improve sensor quality and calibration"}),"\n",(0,i.jsx)(e.li,{children:"Use more robust localization methods"}),"\n",(0,i.jsx)(e.li,{children:"Add landmark-based relocalization"}),"\n",(0,i.jsx)(e.li,{children:"Verify odometry quality"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Navigation combines localization, mapping, path planning, and control"}),"\n",(0,i.jsx)(e.li,{children:"Costmaps are crucial for obstacle avoidance and path planning"}),"\n",(0,i.jsx)(e.li,{children:"Parameter tuning is essential for optimal navigation performance"}),"\n",(0,i.jsx)(e.li,{children:"Isaac provides GPU-accelerated navigation algorithms"}),"\n",(0,i.jsx)(e.li,{children:"Integration with perception systems enables robust autonomous navigation"}),"\n",(0,i.jsx)(e.li,{children:"Recovery behaviors are important for handling edge cases"}),"\n",(0,i.jsx)(e.li,{children:"Simulation testing is crucial before real-world deployment"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsx)(e.p,{children:"In the next chapter, you'll learn about Vision-Language-Action (VLA) systems, which integrate computer vision, natural language processing, and robotic action for advanced human-robot interaction."})]})}function m(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(_,{...n})}):_(n)}},7074:(n,e,r)=>{r.d(e,{R:()=>s,x:()=>t});var a=r(6540);const i={},o=a.createContext(i);function s(n){const e=a.useContext(o);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function t(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:s(n.components),a.createElement(o.Provider,{value:e},n.children)}}}]);