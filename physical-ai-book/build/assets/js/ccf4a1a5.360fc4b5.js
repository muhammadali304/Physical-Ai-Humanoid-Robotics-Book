"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[7547],{4720:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>o,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"vla/llm-planning","title":"LLM Planning - Cognitive Planning with Large Language Models","description":"Learning Objectives","source":"@site/docs/vla/llm-planning.md","sourceDirName":"vla","slug":"/vla/llm-planning","permalink":"/./docs/vla/llm-planning","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/vla/llm-planning.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"VLA Integration - Vision-Language-Action Systems","permalink":"/./docs/vla/integration"},"next":{"title":"Voice Commands - Natural Language Interaction with Robots","permalink":"/./docs/vla/voice-commands"}}');var t=r(4848),s=r(7074);const i={sidebar_position:2},l="LLM Planning - Cognitive Planning with Large Language Models",o={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Conceptual Overview",id:"conceptual-overview",level:2},{value:"Key Capabilities of LLMs in Robotics",id:"key-capabilities-of-llms-in-robotics",level:3},{value:"LLM Integration Architecture",id:"llm-integration-architecture",level:3},{value:"Advantages of LLM-Based Planning",id:"advantages-of-llm-based-planning",level:3},{value:"Hands-On Implementation",id:"hands-on-implementation",level:2},{value:"Installing LLM Dependencies",id:"installing-llm-dependencies",level:3},{value:"Creating an LLM Planning Node",id:"creating-an-llm-planning-node",level:3},{value:"Creating a Plan Execution Node",id:"creating-a-plan-execution-node",level:3},{value:"Creating a Task Manager Node",id:"creating-a-task-manager-node",level:3},{value:"Creating a Local LLM Integration (Alternative to API-based)",id:"creating-a-local-llm-integration-alternative-to-api-based",level:3},{value:"Creating a Safety and Validation Node",id:"creating-a-safety-and-validation-node",level:3},{value:"Creating a Complete LLM Planning Package",id:"creating-a-complete-llm-planning-package",level:3},{value:"Creating a Launch File",id:"creating-a-launch-file",level:3},{value:"Testing &amp; Verification",id:"testing--verification",level:2},{value:"Running LLM Planning System",id:"running-llm-planning-system",level:3},{value:"Useful LLM Planning Commands",id:"useful-llm-planning-commands",level:3},{value:"Performance Testing",id:"performance-testing",level:3},{value:"Common Issues",id:"common-issues",level:2},{value:"Issue: API rate limits or costs with remote LLMs",id:"issue-api-rate-limits-or-costs-with-remote-llms",level:3},{value:"Issue: Hallucinations or incorrect plans from LLM",id:"issue-hallucinations-or-incorrect-plans-from-llm",level:3},{value:"Issue: Latency in plan generation",id:"issue-latency-in-plan-generation",level:3},{value:"Issue: Safety and validation challenges",id:"issue-safety-and-validation-challenges",level:3},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Next Steps",id:"next-steps",level:2}];function p(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"llm-planning---cognitive-planning-with-large-language-models",children:"LLM Planning - Cognitive Planning with Large Language Models"})}),"\n",(0,t.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsx)(e.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Understand how Large Language Models (LLMs) can be integrated with robotic planning"}),"\n",(0,t.jsx)(e.li,{children:"Implement cognitive planning systems using LLMs for high-level reasoning"}),"\n",(0,t.jsx)(e.li,{children:"Create natural language interfaces for robot task specification"}),"\n",(0,t.jsx)(e.li,{children:"Design prompting strategies for effective robot planning"}),"\n",(0,t.jsx)(e.li,{children:"Integrate LLM-based planning with low-level robot control"}),"\n",(0,t.jsx)(e.li,{children:"Evaluate and validate LLM-generated plans for safety and feasibility"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,t.jsx)(e.p,{children:"Before starting this chapter, you should:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Have ROS 2 Humble Hawksbill installed and configured"}),"\n",(0,t.jsx)(e.li,{children:"Understand ROS 2 nodes, services, and action interfaces"}),"\n",(0,t.jsx)(e.li,{children:"Completed the voice commands chapter for natural language understanding"}),"\n",(0,t.jsx)(e.li,{children:"Basic knowledge of Python and machine learning concepts"}),"\n",(0,t.jsx)(e.li,{children:"Understanding of robotic planning and navigation systems"}),"\n",(0,t.jsx)(e.li,{children:"Familiarity with API calls and external service integration"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"conceptual-overview",children:"Conceptual Overview"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Large Language Models (LLMs)"})," bring cognitive reasoning capabilities to robotics by enabling natural language understanding, task decomposition, and high-level planning. Unlike traditional symbolic planners, LLMs can interpret natural language instructions, reason about complex multi-step tasks, and adapt to novel situations."]}),"\n",(0,t.jsx)(e.h3,{id:"key-capabilities-of-llms-in-robotics",children:"Key Capabilities of LLMs in Robotics"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Natural Language Understanding"}),": Interpret human instructions in natural language"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Task Decomposition"}),": Break complex tasks into executable steps"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"World Modeling"}),": Understand spatial relationships and environmental constraints"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Commonsense Reasoning"}),": Apply general knowledge to novel situations"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Adaptive Planning"}),": Modify plans based on changing conditions"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Human-Robot Interaction"}),": Engage in natural dialogue about tasks and goals"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"llm-integration-architecture",children:"LLM Integration Architecture"}),"\n",(0,t.jsx)(e.p,{children:"The typical LLM integration architecture includes:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Natural Language \u2192 LLM \u2192 Task Plan \u2192 ROS Actions \u2192 Robot Execution\n"})}),"\n",(0,t.jsx)(e.p,{children:"With feedback loops for:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Execution monitoring and error handling"}),"\n",(0,t.jsx)(e.li,{children:"Plan refinement based on real-world observations"}),"\n",(0,t.jsx)(e.li,{children:"Natural language responses to human operators"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"advantages-of-llm-based-planning",children:"Advantages of LLM-Based Planning"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Natural Interaction"}),": Humans can specify tasks in everyday language"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Flexibility"}),": Handle novel tasks without pre-programming"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Reasoning"}),": Apply general knowledge to specific situations"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Adaptability"}),": Adjust plans based on context and constraints"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Scalability"}),": Leverage pre-trained models without extensive training"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"hands-on-implementation",children:"Hands-On Implementation"}),"\n",(0,t.jsx)(e.h3,{id:"installing-llm-dependencies",children:"Installing LLM Dependencies"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"# Install LLM libraries\r\npip3 install openai anthropic transformers torch accelerate\r\npip3 install python-dotenv openai gymnasium numpy\r\n\r\n# For local models (optional)\r\npip3 install llama-cpp-python\n"})}),"\n",(0,t.jsx)(e.h3,{id:"creating-an-llm-planning-node",children:"Creating an LLM Planning Node"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n\r\n"""\r\nLLM-based planning node for cognitive robotics.\r\n"""\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\nfrom geometry_msgs.msg import PoseStamped\r\nfrom nav_msgs.msg import Path\r\nfrom action_msgs.msg import GoalStatus\r\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy\r\nimport openai\r\nimport os\r\nimport json\r\nimport asyncio\r\nfrom typing import Dict, List, Optional\r\nfrom dataclasses import dataclass\r\n\r\n\r\n@dataclass\r\nclass RobotCapability:\r\n    """Defines a robot\'s capabilities."""\r\n    name: str\r\n    description: str\r\n    parameters: Dict[str, str]\r\n\r\n\r\n@dataclass\r\nclass PlanningStep:\r\n    """Represents a single step in a plan."""\r\n    action: str\r\n    parameters: Dict[str, str]\r\n    description: str\r\n\r\n\r\nclass LLMPlanningNode(Node):\r\n    """\r\n    Node to use LLM for cognitive planning and task decomposition.\r\n    """\r\n\r\n    def __init__(self):\r\n        super().__init__(\'llm_planning_node\')\r\n\r\n        # Initialize OpenAI API (use your API key)\r\n        # For local models, use different approach\r\n        self.api_key = os.getenv(\'OPENAI_API_KEY\')\r\n        if self.api_key:\r\n            openai.api_key = self.api_key\r\n            self.use_remote_llm = True\r\n        else:\r\n            self.get_logger().warn(\'OPENAI_API_KEY not found, using mock responses\')\r\n            self.use_remote_llm = False\r\n\r\n        # Define robot capabilities\r\n        self.capabilities = [\r\n            RobotCapability(\r\n                name="move_to",\r\n                description="Move the robot to a specific location",\r\n                parameters={"x": "float", "y": "float", "theta": "float", "frame_id": "string"}\r\n            ),\r\n            RobotCapability(\r\n                name="pick_object",\r\n                description="Pick up an object at the current location",\r\n                parameters={"object_id": "string", "height": "float"}\r\n            ),\r\n            RobotCapability(\r\n                name="place_object",\r\n                description="Place an object at the current location",\r\n                parameters={"object_id": "string", "height": "float"}\r\n            ),\r\n            RobotCapability(\r\n                name="navigate_to",\r\n                description="Navigate to a named location in the environment",\r\n                parameters={"location_name": "string"}\r\n            ),\r\n            RobotCapability(\r\n                name="detect_object",\r\n                description="Detect and identify objects in the environment",\r\n                parameters={"object_type": "string", "range": "float"}\r\n            ),\r\n            RobotCapability(\r\n                name="follow_path",\r\n                description="Follow a predefined path",\r\n                parameters={"path_name": "string"}\r\n            ),\r\n            RobotCapability(\r\n                name="report_status",\r\n                description="Report the current status of the robot",\r\n                parameters={}\r\n            )\r\n        ]\r\n\r\n        # Create subscribers\r\n        self.task_sub = self.create_subscription(\r\n            String,\r\n            \'natural_language_task\',\r\n            self.task_callback,\r\n            10\r\n        )\r\n\r\n        # Create publishers\r\n        self.plan_pub = self.create_publisher(String, \'generated_plan\', 10)\r\n        self.response_pub = self.create_publisher(String, \'llm_response\', 10)\r\n\r\n        # Initialize variables\r\n        self.current_plan = []\r\n        self.task_history = []\r\n\r\n        self.get_logger().info(\'LLM planning node initialized\')\r\n\r\n    def task_callback(self, msg):\r\n        """Handle incoming natural language tasks."""\r\n        task_description = msg.data\r\n        self.get_logger().info(f\'Received task: {task_description}\')\r\n\r\n        # Generate plan using LLM\r\n        plan = self.generate_plan(task_description)\r\n\r\n        if plan:\r\n            # Publish the generated plan\r\n            plan_msg = String()\r\n            plan_msg.data = json.dumps(plan)\r\n            self.plan_pub.publish(plan_msg)\r\n\r\n            # Publish response\r\n            response_msg = String()\r\n            response_msg.data = f\'Generated plan with {len(plan)} steps for task: {task_description}\'\r\n            self.response_pub.publish(response_msg)\r\n\r\n            self.get_logger().info(f\'Published plan with {len(plan)} steps\')\r\n        else:\r\n            self.get_logger().error(\'Failed to generate plan\')\r\n\r\n    def generate_plan(self, task_description: str) -> Optional[List[Dict]]:\r\n        """Generate a plan for the given task using LLM."""\r\n        try:\r\n            # Create a prompt for the LLM\r\n            prompt = self.create_planning_prompt(task_description)\r\n\r\n            if self.use_remote_llm:\r\n                # Call OpenAI API\r\n                response = openai.ChatCompletion.create(\r\n                    model="gpt-3.5-turbo",\r\n                    messages=[\r\n                        {"role": "system", "content": self.get_system_prompt()},\r\n                        {"role": "user", "content": prompt}\r\n                    ],\r\n                    temperature=0.3,\r\n                    max_tokens=1000\r\n                )\r\n\r\n                plan_text = response.choices[0].message.content.strip()\r\n            else:\r\n                # Mock response for testing without API key\r\n                plan_text = self.mock_plan_generation(task_description)\r\n\r\n            # Parse the response\r\n            plan = self.parse_plan_response(plan_text)\r\n            return plan\r\n\r\n        except Exception as e:\r\n            self.get_logger().error(f\'Error generating plan: {e}\')\r\n            return None\r\n\r\n    def create_planning_prompt(self, task_description: str) -> str:\r\n        """Create a prompt for the LLM to generate a plan."""\r\n        capabilities_str = "\\n".join([\r\n            f"- {cap.name}: {cap.description} (params: {\', \'.join(cap.parameters.keys())})"\r\n            for cap in self.capabilities\r\n        ])\r\n\r\n        prompt = f"""\r\nYou are a helpful assistant that generates robot action plans from natural language descriptions.\r\nThe robot has the following capabilities:\r\n{capabilities_str}\r\n\r\nThe environment has known locations like: kitchen, bedroom, living room, office, charging_station.\r\n\r\nGiven the task: "{task_description}"\r\n\r\nGenerate a step-by-step plan using the available robot capabilities. Return only a JSON array of steps with the following format:\r\n[\r\n  {{\r\n    "action": "...",\r\n    "parameters": {{"param1": "value1", "param2": "value2"}},\r\n    "description": "..."\r\n  }}\r\n]\r\n\r\nBe specific about locations and objects. If you need to navigate to a named location, use "navigate_to". If you need to go to specific coordinates, use "move_to".\r\n"""\r\n\r\n        return prompt\r\n\r\n    def get_system_prompt(self) -> str:\r\n        """Get the system prompt for the LLM."""\r\n        return """\r\nYou are a helpful assistant that generates robot action plans from natural language descriptions.\r\nAlways respond with a valid JSON array of steps.\r\nEach step should have "action", "parameters", and "description" fields.\r\nOnly use the robot capabilities that are available.\r\nBe specific about locations and objects.\r\nIf information is missing, make reasonable assumptions based on common sense.\r\n"""\r\n\r\n    def parse_plan_response(self, response: str) -> Optional[List[Dict]]:\r\n        """Parse the LLM response into a structured plan."""\r\n        try:\r\n            # Try to extract JSON from the response\r\n            start_idx = response.find(\'[\')\r\n            end_idx = response.rfind(\']\') + 1\r\n\r\n            if start_idx != -1 and end_idx != 0:\r\n                json_str = response[start_idx:end_idx]\r\n                plan = json.loads(json_str)\r\n\r\n                # Validate the plan structure\r\n                for step in plan:\r\n                    if \'action\' not in step or \'parameters\' not in step or \'description\' not in step:\r\n                        raise ValueError("Invalid plan format")\r\n\r\n                return plan\r\n            else:\r\n                self.get_logger().error(f\'Could not find JSON in response: {response}\')\r\n                return None\r\n\r\n        except json.JSONDecodeError as e:\r\n            self.get_logger().error(f\'Error parsing JSON response: {e}\')\r\n            self.get_logger().info(f\'Response: {response}\')\r\n            return None\r\n        except Exception as e:\r\n            self.get_logger().error(f\'Error parsing plan response: {e}\')\r\n            return None\r\n\r\n    def mock_plan_generation(self, task_description: str) -> str:\r\n        """Generate a mock plan for testing without API key."""\r\n        # This is a simplified mock - in reality, you\'d want more sophisticated logic\r\n        if "kitchen" in task_description.lower():\r\n            return \'\'\'[\r\n  {\r\n    "action": "navigate_to",\r\n    "parameters": {"location_name": "kitchen"},\r\n    "description": "Navigate to the kitchen area"\r\n  },\r\n  {\r\n    "action": "report_status",\r\n    "parameters": {},\r\n    "description": "Report arrival at kitchen"\r\n  }\r\n]\'\'\'\r\n        elif "bedroom" in task_description.lower():\r\n            return \'\'\'[\r\n  {\r\n    "action": "navigate_to",\r\n    "parameters": {"location_name": "bedroom"},\r\n    "description": "Navigate to the bedroom area"\r\n  },\r\n  {\r\n    "action": "report_status",\r\n    "parameters": {},\r\n    "description": "Report arrival at bedroom"\r\n  }\r\n]\'\'\'\r\n        else:\r\n            return \'\'\'[\r\n  {\r\n    "action": "report_status",\r\n    "parameters": {},\r\n    "description": "Received task and ready to execute"\r\n  }\r\n]\'\'\'\r\n\r\n    def validate_plan(self, plan: List[Dict]) -> bool:\r\n        """Validate that the plan contains only valid actions."""\r\n        valid_actions = [cap.name for cap in self.capabilities]\r\n\r\n        for step in plan:\r\n            if step[\'action\'] not in valid_actions:\r\n                self.get_logger().error(f\'Invalid action in plan: {step["action"]}\')\r\n                return False\r\n\r\n        return True\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = LLMPlanningNode()\r\n\r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        node.get_logger().info(\'LLM planning node stopped by user\')\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,t.jsx)(e.h3,{id:"creating-a-plan-execution-node",children:"Creating a Plan Execution Node"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\r\n\"\"\"\r\nNode to execute plans generated by the LLM planning node.\r\n\"\"\"\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\nfrom geometry_msgs.msg import Twist, PoseStamped\r\nfrom nav_msgs.msg import Odometry\r\nfrom action_msgs.msg import GoalStatus\r\nimport json\r\nimport time\r\nfrom typing import Dict, Any\r\n\r\n\r\nclass PlanExecutionNode(Node):\r\n    \"\"\"\r\n    Node to execute plans generated by the LLM planning node.\r\n    \"\"\"\r\n\r\n    def __init__(self):\r\n        super().__init__('plan_execution_node')\r\n\r\n        # Create subscribers\r\n        self.plan_sub = self.create_subscription(\r\n            String,\r\n            'generated_plan',\r\n            self.plan_callback,\r\n            10\r\n        )\r\n\r\n        # Create publishers\r\n        self.cmd_vel_pub = self.create_publisher(Twist, 'cmd_vel', 10)\r\n        self.execution_status_pub = self.create_publisher(String, 'execution_status', 10)\r\n\r\n        # Subscribe to odometry for position feedback\r\n        self.odom_sub = self.create_subscription(\r\n            Odometry,\r\n            'odom',\r\n            self.odom_callback,\r\n            10\r\n        )\r\n\r\n        # Initialize variables\r\n        self.current_odom = None\r\n        self.current_plan = []\r\n        self.current_step_index = 0\r\n        self.is_executing = False\r\n\r\n        self.get_logger().info('Plan execution node initialized')\r\n\r\n    def odom_callback(self, msg):\r\n        \"\"\"Update current robot position.\"\"\"\r\n        self.current_odom = msg\r\n\r\n    def plan_callback(self, msg):\r\n        \"\"\"Handle incoming plan.\"\"\"\r\n        try:\r\n            plan_data = json.loads(msg.data)\r\n            self.get_logger().info(f'Received plan with {len(plan_data)} steps')\r\n\r\n            # Store the plan and start execution\r\n            self.current_plan = plan_data\r\n            self.current_step_index = 0\r\n            self.is_executing = True\r\n\r\n            # Start executing the plan\r\n            self.execute_next_step()\r\n\r\n        except json.JSONDecodeError as e:\r\n            self.get_logger().error(f'Error decoding plan: {e}')\r\n        except Exception as e:\r\n            self.get_logger().error(f'Error processing plan: {e}')\r\n\r\n    def execute_next_step(self):\r\n        \"\"\"Execute the next step in the plan.\"\"\"\r\n        if not self.is_executing or self.current_step_index >= len(self.current_plan):\r\n            self.is_executing = False\r\n            self.publish_status('Plan completed')\r\n            return\r\n\r\n        step = self.current_plan[self.current_step_index]\r\n        self.get_logger().info(f'Executing step {self.current_step_index + 1}: {step[\"action\"]}')\r\n\r\n        # Execute based on action type\r\n        success = self.execute_action(step)\r\n\r\n        if success:\r\n            self.publish_status(f'Step completed: {step[\"description\"]}')\r\n            self.current_step_index += 1\r\n\r\n            # Schedule next step after a delay\r\n            self.create_timer(1.0, self.execute_next_step)\r\n        else:\r\n            self.publish_status(f'Step failed: {step[\"description\"]}')\r\n            self.is_executing = False\r\n\r\n    def execute_action(self, step: Dict[str, Any]) -> bool:\r\n        \"\"\"Execute a single action from the plan.\"\"\"\r\n        action = step['action']\r\n        parameters = step['parameters']\r\n\r\n        try:\r\n            if action == 'move_to':\r\n                return self.execute_move_to(parameters)\r\n            elif action == 'navigate_to':\r\n                return self.execute_navigate_to(parameters)\r\n            elif action == 'pick_object':\r\n                return self.execute_pick_object(parameters)\r\n            elif action == 'place_object':\r\n                return self.execute_place_object(parameters)\r\n            elif action == 'detect_object':\r\n                return self.execute_detect_object(parameters)\r\n            elif action == 'follow_path':\r\n                return self.execute_follow_path(parameters)\r\n            elif action == 'report_status':\r\n                return self.execute_report_status(parameters)\r\n            else:\r\n                self.get_logger().error(f'Unknown action: {action}')\r\n                return False\r\n\r\n        except Exception as e:\r\n            self.get_logger().error(f'Error executing action {action}: {e}')\r\n            return False\r\n\r\n    def execute_move_to(self, params: Dict[str, Any]) -> bool:\r\n        \"\"\"Execute move_to action.\"\"\"\r\n        x = float(params.get('x', 0.0))\r\n        y = float(params.get('y', 0.0))\r\n        theta = float(params.get('theta', 0.0))\r\n\r\n        # Create and publish velocity command\r\n        twist = Twist()\r\n        twist.linear.x = 0.5  # Simple movement for demonstration\r\n        twist.angular.z = 0.2\r\n\r\n        # In a real implementation, this would interface with navigation stack\r\n        self.cmd_vel_pub.publish(twist)\r\n\r\n        self.get_logger().info(f'Moving to ({x}, {y}, {theta})')\r\n        time.sleep(2)  # Simulate movement time\r\n\r\n        # Stop the robot\r\n        stop_twist = Twist()\r\n        self.cmd_vel_pub.publish(stop_twist)\r\n\r\n        return True\r\n\r\n    def execute_navigate_to(self, params: Dict[str, Any]) -> bool:\r\n        \"\"\"Execute navigate_to action.\"\"\"\r\n        location_name = params.get('location_name', '')\r\n\r\n        self.get_logger().info(f'Navigating to {location_name}')\r\n\r\n        # In a real implementation, this would send goals to navigation system\r\n        # For now, just simulate the action\r\n        time.sleep(3)  # Simulate navigation time\r\n\r\n        return True\r\n\r\n    def execute_pick_object(self, params: Dict[str, Any]) -> bool:\r\n        \"\"\"Execute pick_object action.\"\"\"\r\n        object_id = params.get('object_id', '')\r\n        height = float(params.get('height', 0.5))\r\n\r\n        self.get_logger().info(f'Picking up object {object_id} at height {height}')\r\n\r\n        # Simulate picking action\r\n        time.sleep(2)\r\n\r\n        return True\r\n\r\n    def execute_place_object(self, params: Dict[str, Any]) -> bool:\r\n        \"\"\"Execute place_object action.\"\"\"\r\n        object_id = params.get('object_id', '')\r\n        height = float(params.get('height', 0.5))\r\n\r\n        self.get_logger().info(f'Placing object {object_id} at height {height}')\r\n\r\n        # Simulate placing action\r\n        time.sleep(2)\r\n\r\n        return True\r\n\r\n    def execute_detect_object(self, params: Dict[str, Any]) -> bool:\r\n        \"\"\"Execute detect_object action.\"\"\"\r\n        object_type = params.get('object_type', '')\r\n        range_val = float(params.get('range', 1.0))\r\n\r\n        self.get_logger().info(f'Detecting {object_type} within {range_val}m')\r\n\r\n        # Simulate detection\r\n        time.sleep(1)\r\n\r\n        return True\r\n\r\n    def execute_follow_path(self, params: Dict[str, Any]) -> bool:\r\n        \"\"\"Execute follow_path action.\"\"\"\r\n        path_name = params.get('path_name', '')\r\n\r\n        self.get_logger().info(f'Following path {path_name}')\r\n\r\n        # Simulate path following\r\n        time.sleep(3)\r\n\r\n        return True\r\n\r\n    def execute_report_status(self, params: Dict[str, Any]) -> bool:\r\n        \"\"\"Execute report_status action.\"\"\"\r\n        self.get_logger().info('Reporting status')\r\n        return True\r\n\r\n    def publish_status(self, status: str):\r\n        \"\"\"Publish execution status.\"\"\"\r\n        status_msg = String()\r\n        status_msg.data = status\r\n        self.execution_status_pub.publish(status_msg)\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = PlanExecutionNode()\r\n\r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        node.get_logger().info('Plan execution node stopped by user')\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,t.jsx)(e.h3,{id:"creating-a-task-manager-node",children:"Creating a Task Manager Node"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\r\n\"\"\"\r\nTask manager node to coordinate LLM planning and execution.\r\n\"\"\"\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\nfrom geometry_msgs.msg import PoseStamped\r\nimport json\r\nimport asyncio\r\nfrom typing import Dict, List, Optional\r\n\r\n\r\nclass TaskManagerNode(Node):\r\n    \"\"\"\r\n    Node to manage the overall task execution flow.\r\n    \"\"\"\r\n\r\n    def __init__(self):\r\n        super().__init__('task_manager_node')\r\n\r\n        # Create subscribers\r\n        self.voice_command_sub = self.create_subscription(\r\n            String,\r\n            'voice_commands',  # From voice command node\r\n            self.voice_command_callback,\r\n            10\r\n        )\r\n\r\n        self.execution_status_sub = self.create_subscription(\r\n            String,\r\n            'execution_status',\r\n            self.execution_status_callback,\r\n            10\r\n        )\r\n\r\n        # Create publishers\r\n        self.natural_task_pub = self.create_publisher(String, 'natural_language_task', 10)\r\n        self.system_status_pub = self.create_publisher(String, 'system_status', 10)\r\n\r\n        # Initialize variables\r\n        self.current_task = None\r\n        self.task_queue = []\r\n\r\n        self.get_logger().info('Task manager node initialized')\r\n\r\n    def voice_command_callback(self, msg):\r\n        \"\"\"Handle voice commands and convert to natural language tasks.\"\"\"\r\n        command = msg.data\r\n        self.get_logger().info(f'Received voice command: {command}')\r\n\r\n        # Convert voice command to natural language task\r\n        # In a real system, you might do more sophisticated NLP here\r\n        natural_task = self.convert_to_natural_task(command)\r\n\r\n        if natural_task:\r\n            # Publish the natural language task for LLM planning\r\n            task_msg = String()\r\n            task_msg.data = natural_task\r\n            self.natural_task_pub.publish(task_msg)\r\n\r\n            self.get_logger().info(f'Published natural task: {natural_task}')\r\n        else:\r\n            self.get_logger().warn(f'Could not convert command to natural task: {command}')\r\n\r\n    def convert_to_natural_task(self, command: str) -> Optional[str]:\r\n        \"\"\"Convert voice command to natural language task.\"\"\"\r\n        # This is a simplified conversion - in practice, you'd have more sophisticated NLP\r\n        command_lower = command.lower()\r\n\r\n        # Define common command patterns and their natural language equivalents\r\n        if 'move to' in command_lower or 'go to' in command_lower:\r\n            # Extract location if specified\r\n            if 'kitchen' in command_lower:\r\n                return 'Navigate to the kitchen and wait there'\r\n            elif 'bedroom' in command_lower:\r\n                return 'Go to the bedroom and report your arrival'\r\n            elif 'living room' in command_lower:\r\n                return 'Move to the living room'\r\n            else:\r\n                # Try to extract a general location\r\n                import re\r\n                location_match = re.search(r'(?:to|the)\\s+(\\w+)', command_lower)\r\n                if location_match:\r\n                    location = location_match.group(1)\r\n                    return f'Go to the {location} area'\r\n\r\n        elif 'pick' in command_lower or 'grasp' in command_lower:\r\n            # Extract object if specified\r\n            import re\r\n            object_match = re.search(r'(?:pick|grasp|take)\\s+(?:up\\s+)?(\\w+)', command_lower)\r\n            if object_match:\r\n                obj = object_match.group(1)\r\n                return f'Pick up the {obj} from the current location'\r\n\r\n        elif 'place' in command_lower or 'put' in command_lower:\r\n            # Extract object if specified\r\n            import re\r\n            object_match = re.search(r'(?:place|put)\\s+(?:down\\s+)?(\\w+)', command_lower)\r\n            if object_match:\r\n                obj = object_match.group(1)\r\n                return f'Put down the {obj} at the current location'\r\n\r\n        elif 'stop' in command_lower or 'halt' in command_lower:\r\n            return 'Stop all current activities and remain in place'\r\n\r\n        elif 'status' in command_lower or 'where' in command_lower:\r\n            return 'Report your current status and location'\r\n\r\n        # If no specific pattern matched, use the command as-is with some context\r\n        if len(command) > 3:  # At least 3 characters\r\n            return f'{command.capitalize()}. Perform this task using your available capabilities.'\r\n\r\n        return None\r\n\r\n    def execution_status_callback(self, msg):\r\n        \"\"\"Handle execution status updates.\"\"\"\r\n        status = msg.data\r\n        self.get_logger().info(f'Execution status: {status}')\r\n\r\n        # Publish system status\r\n        system_status = String()\r\n        system_status.data = f'LLM Planning System: {status}'\r\n        self.system_status_pub.publish(system_status)\r\n\r\n        # Check if we have more tasks to process\r\n        if self.task_queue and status.startswith('Plan completed'):\r\n            next_task = self.task_queue.pop(0)\r\n            task_msg = String()\r\n            task_msg.data = next_task\r\n            self.natural_task_pub.publish(task_msg)\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = TaskManagerNode()\r\n\r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        node.get_logger().info('Task manager node stopped by user')\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,t.jsx)(e.h3,{id:"creating-a-local-llm-integration-alternative-to-api-based",children:"Creating a Local LLM Integration (Alternative to API-based)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n\r\n"""\r\nLocal LLM integration using transformers library.\r\nThis provides an alternative to API-based LLMs for privacy or offline use.\r\n"""\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\nfrom transformers import AutoTokenizer, AutoModelForCausalLM\r\nimport torch\r\nimport json\r\nimport os\r\nfrom typing import Dict, List, Optional\r\n\r\n\r\nclass LocalLLMNode(Node):\r\n    """\r\n    Node to use local LLM for planning (privacy-preserving alternative).\r\n    """\r\n\r\n    def __init__(self):\r\n        super().__init__(\'local_llm_node\')\r\n\r\n        # Initialize local model (using a smaller, faster model for demonstration)\r\n        # For production, you might use models like Phi-3, TinyLlama, or others\r\n        try:\r\n            model_name = "microsoft/DialoGPT-small"  # Example - replace with appropriate model\r\n\r\n            # For this example, we\'ll use a mock approach since actual model loading\r\n            # might be resource-intensive for the documentation example\r\n            self.use_local_model = False\r\n            self.get_logger().info(\'Local LLM node initialized (mock mode)\')\r\n\r\n        except Exception as e:\r\n            self.get_logger().warn(f\'Could not load local model: {e}\')\r\n            self.use_local_model = False\r\n\r\n        # Create subscribers\r\n        self.task_sub = self.create_subscription(\r\n            String,\r\n            \'natural_language_task\',\r\n            self.task_callback,\r\n            10\r\n        )\r\n\r\n        # Create publishers\r\n        self.plan_pub = self.create_publisher(String, \'generated_plan\', 10)\r\n        self.response_pub = self.create_publisher(String, \'llm_response\', 10)\r\n\r\n        self.get_logger().info(\'Local LLM planning node initialized\')\r\n\r\n    def task_callback(self, msg):\r\n        """Handle incoming natural language tasks."""\r\n        task_description = msg.data\r\n        self.get_logger().info(f\'Received task (local): {task_description}\')\r\n\r\n        # Generate plan using local processing or mock\r\n        plan = self.generate_plan_local(task_description)\r\n\r\n        if plan:\r\n            # Publish the generated plan\r\n            plan_msg = String()\r\n            plan_msg.data = json.dumps(plan)\r\n            self.plan_pub.publish(plan_msg)\r\n\r\n            # Publish response\r\n            response_msg = String()\r\n            response_msg.data = f\'Generated plan with {len(plan)} steps for task: {task_description}\'\r\n            self.response_pub.publish(response_msg)\r\n\r\n            self.get_logger().info(f\'Published plan with {len(plan)} steps\')\r\n        else:\r\n            self.get_logger().error(\'Failed to generate plan locally\')\r\n\r\n    def generate_plan_local(self, task_description: str) -> Optional[List[Dict]]:\r\n        """Generate a plan locally (mock implementation)."""\r\n        # In a real implementation, you would use a local LLM\r\n        # For this example, we\'ll use rule-based generation with some ML concepts\r\n\r\n        # Define a simple rule-based planner for demonstration\r\n        task_lower = task_description.lower()\r\n\r\n        plan = []\r\n\r\n        # Rule-based planning logic\r\n        if \'kitchen\' in task_lower:\r\n            plan.extend([\r\n                {\r\n                    "action": "navigate_to",\r\n                    "parameters": {"location_name": "kitchen"},\r\n                    "description": "Navigate to the kitchen area"\r\n                },\r\n                {\r\n                    "action": "report_status",\r\n                    "parameters": {},\r\n                    "description": "Report arrival at kitchen"\r\n                }\r\n            ])\r\n        elif \'bedroom\' in task_lower:\r\n            plan.extend([\r\n                {\r\n                    "action": "navigate_to",\r\n                    "parameters": {"location_name": "bedroom"},\r\n                    "description": "Navigate to the bedroom area"\r\n                },\r\n                {\r\n                    "action": "report_status",\r\n                    "parameters": {},\r\n                    "description": "Report arrival at bedroom"\r\n                }\r\n            ])\r\n        elif \'pick\' in task_lower or \'grasp\' in task_lower:\r\n            # Extract object name if possible\r\n            import re\r\n            obj_match = re.search(r\'(?:pick|grasp|take)\\s+(?:up\\s+)?(\\w+)\', task_lower)\r\n            obj_name = obj_match.group(1) if obj_match else "object"\r\n\r\n            plan.extend([\r\n                {\r\n                    "action": "detect_object",\r\n                    "parameters": {"object_type": obj_name, "range": 1.0},\r\n                    "description": f"Detect the {obj_name} in the environment"\r\n                },\r\n                {\r\n                    "action": "pick_object",\r\n                    "parameters": {"object_id": obj_name, "height": 0.5},\r\n                    "description": f"Pick up the {obj_name}"\r\n                }\r\n            ])\r\n        else:\r\n            # Default action for unrecognized tasks\r\n            plan.append({\r\n                "action": "report_status",\r\n                "parameters": {},\r\n                "description": f"Received task: {task_description}"\r\n            })\r\n\r\n        return plan\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = LocalLLMNode()\r\n\r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        node.get_logger().info(\'Local LLM node stopped by user\')\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,t.jsx)(e.h3,{id:"creating-a-safety-and-validation-node",children:"Creating a Safety and Validation Node"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\r\n\"\"\"\r\nSafety and validation node for LLM-generated plans.\r\n\"\"\"\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\nfrom geometry_msgs.msg import Pose, Point\r\nfrom sensor_msgs.msg import LaserScan\r\nfrom nav_msgs.msg import OccupancyGrid\r\nimport json\r\nfrom typing import Dict, List, Optional\r\n\r\n\r\nclass SafetyValidatorNode(Node):\r\n    \"\"\"\r\n    Node to validate LLM-generated plans for safety and feasibility.\r\n    \"\"\"\r\n\r\n    def __init__(self):\r\n        super().__init__('safety_validator_node')\r\n\r\n        # Create subscribers\r\n        self.plan_sub = self.create_subscription(\r\n            String,\r\n            'generated_plan',\r\n            self.plan_callback,\r\n            10\r\n        )\r\n\r\n        self.laser_sub = self.create_subscription(\r\n            LaserScan,\r\n            '/scan',\r\n            self.laser_callback,\r\n            10\r\n        )\r\n\r\n        self.map_sub = self.create_subscription(\r\n            OccupancyGrid,\r\n            '/map',\r\n            self.map_callback,\r\n            10\r\n        )\r\n\r\n        # Create publishers\r\n        self.validated_plan_pub = self.create_publisher(String, 'validated_plan', 10)\r\n        self.safety_alert_pub = self.create_publisher(String, 'safety_alerts', 10)\r\n\r\n        # Initialize variables\r\n        self.laser_data = None\r\n        self.map_data = None\r\n        self.map_metadata = None\r\n\r\n        self.get_logger().info('Safety validator node initialized')\r\n\r\n    def plan_callback(self, msg):\r\n        \"\"\"Validate incoming plan.\"\"\"\r\n        try:\r\n            plan = json.loads(msg.data)\r\n            self.get_logger().info(f'Validating plan with {len(plan)} steps')\r\n\r\n            # Validate the plan\r\n            is_safe, validated_plan, alerts = self.validate_plan(plan)\r\n\r\n            if is_safe:\r\n                # Publish validated plan\r\n                validated_msg = String()\r\n                validated_msg.data = json.dumps(validated_plan)\r\n                self.validated_plan_pub.publish(validated_msg)\r\n\r\n                self.get_logger().info('Plan validated and published')\r\n            else:\r\n                # Publish safety alerts\r\n                for alert in alerts:\r\n                    alert_msg = String()\r\n                    alert_msg.data = alert\r\n                    self.safety_alert_pub.publish(alert_msg)\r\n\r\n                self.get_logger().warn(f'Plan rejected with {len(alerts)} safety issues')\r\n\r\n        except json.JSONDecodeError as e:\r\n            self.get_logger().error(f'Error decoding plan: {e}')\r\n        except Exception as e:\r\n            self.get_logger().error(f'Error validating plan: {e}')\r\n\r\n    def validate_plan(self, plan: List[Dict]) -> tuple:\r\n        \"\"\"Validate plan for safety and feasibility.\"\"\"\r\n        alerts = []\r\n        validated_plan = []\r\n\r\n        for i, step in enumerate(plan):\r\n            action = step['action']\r\n            params = step['parameters']\r\n\r\n            # Validate based on action type\r\n            if action == 'move_to':\r\n                is_valid, alert = self.validate_move_to(params)\r\n                if not is_valid:\r\n                    alerts.append(f'Step {i}: {alert}')\r\n                    continue  # Skip invalid step\r\n            elif action == 'navigate_to':\r\n                is_valid, alert = self.validate_navigate_to(params)\r\n                if not is_valid:\r\n                    alerts.append(f'Step {i}: {alert}')\r\n                    continue  # Skip invalid step\r\n\r\n            # Add valid step to validated plan\r\n            validated_plan.append(step)\r\n\r\n        is_safe = len(alerts) == 0\r\n        return is_safe, validated_plan, alerts\r\n\r\n    def validate_move_to(self, params: Dict) -> tuple:\r\n        \"\"\"Validate move_to action for safety.\"\"\"\r\n        try:\r\n            x = float(params.get('x', 0.0))\r\n            y = float(params.get('y', 0.0))\r\n\r\n            # Check if coordinates are within reasonable bounds\r\n            if abs(x) > 100 or abs(y) > 100:\r\n                return False, f'Coordinates ({x}, {y}) exceed safe operational bounds'\r\n\r\n            # Check if destination is in known map (if map is available)\r\n            if self.map_data and self.map_metadata:\r\n                if not self.is_location_traversable(x, y):\r\n                    return False, f'Destination ({x}, {y}) is not traversable'\r\n\r\n            # Check for immediate obstacles (using laser data if available)\r\n            if self.laser_data:\r\n                if self.has_immediate_obstacles(x, y):\r\n                    return False, f'Immediate obstacles detected near destination ({x}, {y})'\r\n\r\n            return True, \"\"\r\n\r\n        except (ValueError, TypeError) as e:\r\n            return False, f'Invalid coordinates in parameters: {e}'\r\n\r\n    def validate_navigate_to(self, params: Dict) -> tuple:\r\n        \"\"\"Validate navigate_to action for safety.\"\"\"\r\n        location_name = params.get('location_name', '').lower()\r\n\r\n        # Check if location name is valid\r\n        valid_locations = ['kitchen', 'bedroom', 'living room', 'office', 'charging_station']\r\n        if location_name not in valid_locations:\r\n            # For this example, we'll accept any location name\r\n            # In a real system, you'd validate against known locations\r\n            pass\r\n\r\n        # Additional validation can be added based on map data\r\n        if self.map_data and self.map_metadata:\r\n            if not self.is_known_location(location_name):\r\n                return False, f'Location \"{location_name}\" is not in known map'\r\n\r\n        return True, \"\"\r\n\r\n    def is_location_traversable(self, x: float, y: float) -> bool:\r\n        \"\"\"Check if a location is traversable based on map data.\"\"\"\r\n        if not self.map_data or not self.map_metadata:\r\n            return True  # Assume traversable if no map data\r\n\r\n        try:\r\n            # Convert world coordinates to map coordinates\r\n            origin_x = self.map_metadata.origin.position.x\r\n            origin_y = self.map_metadata.origin.position.y\r\n            resolution = self.map_metadata.resolution\r\n\r\n            map_x = int((x - origin_x) / resolution)\r\n            map_y = int((y - origin_y) / resolution)\r\n\r\n            # Check bounds\r\n            if (map_x < 0 or map_x >= self.map_metadata.width or\r\n                map_y < 0 or map_y >= self.map_metadata.height):\r\n                return False\r\n\r\n            # Check occupancy value (0 = free, 100 = occupied)\r\n            idx = map_y * self.map_metadata.width + map_x\r\n            if idx < len(self.map_data.data):\r\n                occupancy = self.map_data.data[idx]\r\n                return occupancy < 50  # Consider <50 as traversable\r\n\r\n        except Exception as e:\r\n            self.get_logger().warn(f'Error checking traversability: {e}')\r\n\r\n        return True\r\n\r\n    def has_immediate_obstacles(self, x: float, y: float) -> bool:\r\n        \"\"\"Check if there are immediate obstacles near destination.\"\"\"\r\n        if not self.laser_data:\r\n            return False\r\n\r\n        # This is a simplified check - in practice, you'd do more sophisticated analysis\r\n        # Check if any laser readings indicate close obstacles\r\n        min_distance = min(self.laser_data.ranges) if self.laser_data.ranges else float('inf')\r\n        return min_distance < 0.5  # Consider <0.5m as immediate obstacle\r\n\r\n    def is_known_location(self, location_name: str) -> bool:\r\n        \"\"\"Check if location is known in the map.\"\"\"\r\n        # In a real implementation, this would check against semantic map\r\n        # For this example, we'll return True to avoid blocking execution\r\n        return True\r\n\r\n    def laser_callback(self, msg):\r\n        \"\"\"Update laser data.\"\"\"\r\n        self.laser_data = msg\r\n\r\n    def map_callback(self, msg):\r\n        \"\"\"Update map data.\"\"\"\r\n        self.map_data = msg.data\r\n        self.map_metadata = msg.info\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = SafetyValidatorNode()\r\n\r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        node.get_logger().info('Safety validator node stopped by user')\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,t.jsx)(e.h3,{id:"creating-a-complete-llm-planning-package",children:"Creating a Complete LLM Planning Package"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Create the package:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"cd ~/ros2_ws/src\r\nros2 pkg create --build-type ament_python llm_planning\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Update package.xml:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\r\n<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>\r\n<package format="3">\r\n  <name>llm_planning</name>\r\n  <version>0.0.1</version>\r\n  <description>LLM-based planning for robotics</description>\r\n  <maintainer email="user@todo.todo">user</maintainer>\r\n  <license>Apache-2.0</license>\r\n\r\n  <depend>rclpy</depend>\r\n  <depend>std_msgs</depend>\r\n  <depend>geometry_msgs</depend>\r\n  <depend>nav_msgs</depend>\r\n  <depend>sensor_msgs</depend>\r\n\r\n  <export>\r\n    <build_type>ament_python</build_type>\r\n  </export>\r\n</package>\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Create setup.py:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"from setuptools import find_packages, setup\r\n\r\npackage_name = 'llm_planning'\r\n\r\nsetup(\r\n    name=package_name,\r\n    version='0.0.1',\r\n    packages=find_packages(exclude=['test']),\r\n    data_files=[\r\n        ('share/ament_index/resource_index/packages',\r\n            ['resource/' + package_name]),\r\n        ('share/' + package_name, ['package.xml']),\r\n    ],\r\n    install_requires=['setuptools'],\r\n    zip_safe=True,\r\n    maintainer='user',\r\n    maintainer_email='user@todo.todo',\r\n    description='LLM-based planning for robotics',\r\n    license='Apache-2.0',\r\n    tests_require=['pytest'],\r\n    entry_points={\r\n        'console_scripts': [\r\n            'llm_planning_node = llm_planning.llm_planning_node:main',\r\n            'plan_execution_node = llm_planning.plan_execution_node:main',\r\n            'task_manager_node = llm_planning.task_manager_node:main',\r\n            'local_llm_node = llm_planning.local_llm_node:main',\r\n            'safety_validator_node = llm_planning.safety_validator_node:main',\r\n        ],\r\n    },\r\n)\n"})}),"\n",(0,t.jsx)(e.h3,{id:"creating-a-launch-file",children:"Creating a Launch File"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Create launch/llm_planning_launch.py:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"from launch import LaunchDescription\r\nfrom launch.actions import DeclareLaunchArgument\r\nfrom launch.substitutions import LaunchConfiguration\r\nfrom launch_ros.actions import Node\r\n\r\n\r\ndef generate_launch_description():\r\n    # Declare launch arguments\r\n    use_sim_time = DeclareLaunchArgument(\r\n        'use_sim_time',\r\n        default_value='false',\r\n        description='Use simulation time if true'\r\n    )\r\n\r\n    # LLM planning node\r\n    llm_planning_node = Node(\r\n        package='llm_planning',\r\n        executable='llm_planning_node',\r\n        name='llm_planning_node',\r\n        parameters=[\r\n            {'use_sim_time': LaunchConfiguration('use_sim_time')}\r\n        ],\r\n        output='screen'\r\n    )\r\n\r\n    # Plan execution node\r\n    plan_execution_node = Node(\r\n        package='llm_planning',\r\n        executable='plan_execution_node',\r\n        name='plan_execution_node',\r\n        parameters=[\r\n            {'use_sim_time': LaunchConfiguration('use_sim_time')}\r\n        ],\r\n        output='screen'\r\n    )\r\n\r\n    # Task manager node\r\n    task_manager_node = Node(\r\n        package='llm_planning',\r\n        executable='task_manager_node',\r\n        name='task_manager_node',\r\n        parameters=[\r\n            {'use_sim_time': LaunchConfiguration('use_sim_time')}\r\n        ],\r\n        output='screen'\r\n    )\r\n\r\n    # Safety validator node\r\n    safety_validator_node = Node(\r\n        package='llm_planning',\r\n        executable='safety_validator_node',\r\n        name='safety_validator_node',\r\n        parameters=[\r\n            {'use_sim_time': LaunchConfiguration('use_sim_time')}\r\n        ],\r\n        output='screen'\r\n    )\r\n\r\n    return LaunchDescription([\r\n        use_sim_time,\r\n        llm_planning_node,\r\n        plan_execution_node,\r\n        task_manager_node,\r\n        safety_validator_node\r\n    ])\n"})}),"\n",(0,t.jsx)(e.h2,{id:"testing--verification",children:"Testing & Verification"}),"\n",(0,t.jsx)(e.h3,{id:"running-llm-planning-system",children:"Running LLM Planning System"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Set up your OpenAI API key (optional):"})}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:'# Create a .env file or export the key\r\nexport OPENAI_API_KEY="your-api-key-here"\n'})}),"\n",(0,t.jsxs)(e.ol,{start:"2",children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Install dependencies:"})}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"pip3 install openai anthropic transformers torch\n"})}),"\n",(0,t.jsxs)(e.ol,{start:"3",children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Build the package:"})}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"cd ~/ros2_ws\r\ncolcon build --packages-select llm_planning\r\nsource install/setup.bash\n"})}),"\n",(0,t.jsxs)(e.ol,{start:"4",children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Run the LLM planning system:"})}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"# Terminal 1: Launch the system\r\nros2 launch llm_planning llm_planning_launch.py\r\n\r\n# Terminal 2: Send a test task\r\nros2 topic pub /natural_language_task std_msgs/msg/String \"data: 'Go to the kitchen and wait there'\"\n"})}),"\n",(0,t.jsxs)(e.ol,{start:"5",children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Monitor the planning process:"})}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"# Check generated plans\r\nros2 topic echo /generated_plan\r\n\r\n# Check execution status\r\nros2 topic echo /execution_status\r\n\r\n# Check safety alerts\r\nros2 topic echo /safety_alerts\n"})}),"\n",(0,t.jsx)(e.h3,{id:"useful-llm-planning-commands",children:"Useful LLM Planning Commands"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Test with voice commands:"})}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"# If you have the voice command system running\r\nros2 topic pub /voice_commands std_msgs/msg/String \"data: 'move to kitchen'\"\n"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Monitor plan validation:"})}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"ros2 topic echo /validated_plan\n"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Check system status:"})}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"ros2 topic echo /system_status\n"})}),"\n",(0,t.jsx)(e.h3,{id:"performance-testing",children:"Performance Testing"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"# Test response times for different types of commands\r\n# Test with various levels of task complexity\r\n# Test safety validation effectiveness\r\n# Test integration with navigation system\n"})}),"\n",(0,t.jsx)(e.h2,{id:"common-issues",children:"Common Issues"}),"\n",(0,t.jsx)(e.h3,{id:"issue-api-rate-limits-or-costs-with-remote-llms",children:"Issue: API rate limits or costs with remote LLMs"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Solution"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Implement local models for frequently-used tasks"}),"\n",(0,t.jsx)(e.li,{children:"Use caching for repeated requests"}),"\n",(0,t.jsx)(e.li,{children:"Implement request queuing to respect rate limits"}),"\n",(0,t.jsx)(e.li,{children:"Consider hybrid approach with local models for simple tasks"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"issue-hallucinations-or-incorrect-plans-from-llm",children:"Issue: Hallucinations or incorrect plans from LLM"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Solution"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Implement safety validation layers"}),"\n",(0,t.jsx)(e.li,{children:"Use structured output formats (JSON)"}),"\n",(0,t.jsx)(e.li,{children:"Add domain-specific constraints"}),"\n",(0,t.jsx)(e.li,{children:"Implement plan verification before execution"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"issue-latency-in-plan-generation",children:"Issue: Latency in plan generation"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Solution"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Use smaller, faster models for real-time applications"}),"\n",(0,t.jsx)(e.li,{children:"Implement plan caching for common tasks"}),"\n",(0,t.jsx)(e.li,{children:"Use local inference where possible"}),"\n",(0,t.jsx)(e.li,{children:"Implement asynchronous processing"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"issue-safety-and-validation-challenges",children:"Issue: Safety and validation challenges"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Solution"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Implement multiple validation layers"}),"\n",(0,t.jsx)(e.li,{children:"Use formal methods for critical safety checks"}),"\n",(0,t.jsx)(e.li,{children:"Implement human-in-the-loop for high-risk actions"}),"\n",(0,t.jsx)(e.li,{children:"Maintain conservative safety margins"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"LLMs enable natural language task specification for robots"}),"\n",(0,t.jsx)(e.li,{children:"Safety validation is crucial for LLM-generated plans"}),"\n",(0,t.jsx)(e.li,{children:"Local models provide privacy and reliability benefits"}),"\n",(0,t.jsx)(e.li,{children:"Integration with existing ROS systems requires careful architecture"}),"\n",(0,t.jsx)(e.li,{children:"Hybrid approaches combine LLM flexibility with traditional planning"}),"\n",(0,t.jsx)(e.li,{children:"Human-robot collaboration is enhanced through cognitive planning"}),"\n",(0,t.jsx)(e.li,{children:"Proper error handling and fallback mechanisms are essential"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsx)(e.p,{children:"In the next chapter, you'll learn about integrating voice commands with LLM planning to create a complete Vision-Language-Action system."})]})}function d(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(p,{...n})}):p(n)}},7074:(n,e,r)=>{r.d(e,{R:()=>i,x:()=>l});var a=r(6540);const t={},s=a.createContext(t);function i(n){const e=a.useContext(s);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:i(n.components),a.createElement(s.Provider,{value:e},n.children)}}}]);