"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[3496],{5903:(n,r,e)=>{e.r(r),e.d(r,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>t,toc:()=>p});const t=JSON.parse('{"id":"isaac-platform/path-planning-algorithms","title":"Path Planning Algorithms Implementation","description":"Overview","source":"@site/docs/isaac-platform/path-planning-algorithms.md","sourceDirName":"isaac-platform","slug":"/isaac-platform/path-planning-algorithms","permalink":"/./docs/isaac-platform/path-planning-algorithms","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/isaac-platform/path-planning-algorithms.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Costmap Configuration for Obstacle Avoidance","permalink":"/./docs/isaac-platform/costmap-configuration"},"next":{"title":"Path Execution Controller for Robot Movement","permalink":"/./docs/isaac-platform/path-execution-controller"}}');var a=e(4848),o=e(7074);const i={},s="Path Planning Algorithms Implementation",l={},p=[{value:"Overview",id:"overview",level:2},{value:"Understanding Path Planning",id:"understanding-path-planning",level:2},{value:"Types of Path Planning Algorithms",id:"types-of-path-planning-algorithms",level:3},{value:"Common Algorithms",id:"common-algorithms",level:3},{value:"Built-in Navigation2 Planners",id:"built-in-navigation2-planners",level:2},{value:"1. NavFn Planner Configuration",id:"1-navfn-planner-configuration",level:3},{value:"2. A* Planner Configuration",id:"2-a-planner-configuration",level:3},{value:"3. Smoother Configuration",id:"3-smoother-configuration",level:3},{value:"Custom Path Planning Implementation",id:"custom-path-planning-implementation",level:2},{value:"1. A* Algorithm Implementation",id:"1-a-algorithm-implementation",level:3},{value:"2. Dijkstra Algorithm Implementation",id:"2-dijkstra-algorithm-implementation",level:3},{value:"3. Theta* Any-Angle Path Planning",id:"3-theta-any-angle-path-planning",level:3},{value:"Advanced Path Planning Features",id:"advanced-path-planning-features",level:2},{value:"1. Dynamic Path Planning with Obstacle Avoidance",id:"1-dynamic-path-planning-with-obstacle-avoidance",level:3},{value:"2. Multi-Goal Path Planning",id:"2-multi-goal-path-planning",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"1. Path Planning Performance Tuning",id:"1-path-planning-performance-tuning",level:3},{value:"2. Memory Management",id:"2-memory-management",level:3},{value:"Path Planning Quality Metrics",id:"path-planning-quality-metrics",level:2},{value:"1. Path Quality Assessment",id:"1-path-quality-assessment",level:3},{value:"Integration with Navigation System",id:"integration-with-navigation-system",level:2},{value:"1. Planner Integration Configuration",id:"1-planner-integration-configuration",level:3},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:2},{value:"1. Path Planning Failures",id:"1-path-planning-failures",level:3},{value:"Issue: Planner fails to find path",id:"issue-planner-fails-to-find-path",level:4},{value:"Issue: Path is not optimal",id:"issue-path-is-not-optimal",level:4},{value:"Issue: High CPU usage during planning",id:"issue-high-cpu-usage-during-planning",level:4},{value:"2. Performance Monitoring",id:"2-performance-monitoring",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Algorithm Selection Guidelines",id:"1-algorithm-selection-guidelines",level:3},{value:"2. Configuration Best Practices",id:"2-configuration-best-practices",level:3},{value:"3. Testing Strategies",id:"3-testing-strategies",level:3},{value:"Resources",id:"resources",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(n){const r={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(r.header,{children:(0,a.jsx)(r.h1,{id:"path-planning-algorithms-implementation",children:"Path Planning Algorithms Implementation"})}),"\n",(0,a.jsx)(r.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(r.p,{children:"This guide provides comprehensive instructions for implementing path planning algorithms in ROS 2 Navigation2. Path planning is a critical component of robot navigation that finds optimal or feasible paths from a start position to a goal while avoiding obstacles. This guide covers both built-in algorithms and custom implementations."}),"\n",(0,a.jsx)(r.h2,{id:"understanding-path-planning",children:"Understanding Path Planning"}),"\n",(0,a.jsx)(r.h3,{id:"types-of-path-planning-algorithms",children:"Types of Path Planning Algorithms"}),"\n",(0,a.jsxs)(r.ol,{children:["\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Global Path Planning"}),": Finds optimal path from start to goal using known map"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Local Path Planning"}),": Finds immediate path to follow global plan while avoiding dynamic obstacles"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Anytime Algorithms"}),": Provide initial solution quickly and improve over time"]}),"\n"]}),"\n",(0,a.jsx)(r.h3,{id:"common-algorithms",children:"Common Algorithms"}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:["*",(0,a.jsx)(r.em,{children:"A"})," (A-star)**: Optimal path with heuristic"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Dijkstra"}),": Optimal path without heuristic"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"NavFn"}),": Fast approximate path planning"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Theta"}),"*: Any-angle path planning"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"RRT"}),": Rapidly-exploring Random Tree (for complex environments)"]}),"\n"]}),"\n",(0,a.jsx)(r.h2,{id:"built-in-navigation2-planners",children:"Built-in Navigation2 Planners"}),"\n",(0,a.jsx)(r.h3,{id:"1-navfn-planner-configuration",children:"1. NavFn Planner Configuration"}),"\n",(0,a.jsx)(r.p,{children:"NavFn is the default global planner in Navigation2, based on Dijkstra's algorithm:"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-yaml",children:'planner_server:\r\n  ros__parameters:\r\n    expected_planner_frequency: 20.0\r\n    use_sim_time: false\r\n    planner_plugins: ["GridBased"]\r\n\r\n    GridBased:\r\n      plugin: "nav2_navfn_planner::NavfnPlanner"\r\n      tolerance: 0.5          # Distance to consider goal reached\r\n      use_astar: false        # Use A* instead of Dijkstra\r\n      allow_unknown: true     # Allow planning through unknown space\r\n      visualize_potential: false  # Publish potential field for visualization\n'})}),"\n",(0,a.jsx)(r.h3,{id:"2-a-planner-configuration",children:"2. A* Planner Configuration"}),"\n",(0,a.jsx)(r.p,{children:"For A* implementation (if available in your Navigation2 version):"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-yaml",children:'planner_server:\r\n  ros__parameters:\r\n    expected_planner_frequency: 20.0\r\n    use_sim_time: false\r\n    planner_plugins: ["GridBased"]\r\n\r\n    GridBased:\r\n      plugin: "nav2_navfn_planner::NavfnPlanner"\r\n      tolerance: 0.5\r\n      use_astar: true         # Use A* heuristic\r\n      allow_unknown: false    # Don\'t plan through unknown space\r\n      use_quadratic: true     # Use quadratic approximation\r\n      use_dijkstra: false     # Use Dijkstra instead of A*\r\n      use_grid_path: false    # Output grid path instead of smooth path\n'})}),"\n",(0,a.jsx)(r.h3,{id:"3-smoother-configuration",children:"3. Smoother Configuration"}),"\n",(0,a.jsx)(r.p,{children:"Path smoothing for better navigation:"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-yaml",children:'smoother_server:\r\n  ros__parameters:\r\n    use_sim_time: false\r\n    smoother_plugins: ["simple_smoother"]\r\n\r\n    simple_smoother:\r\n      plugin: "nav2_smoother::SimpleSmoother"\r\n      tolerance: 1.0e-10\r\n      max_its: 1000\r\n      w_smooth: 0.9          # Weight for smoothing\r\n      w_data: 0.1            # Weight for data fitting\n'})}),"\n",(0,a.jsx)(r.h2,{id:"custom-path-planning-implementation",children:"Custom Path Planning Implementation"}),"\n",(0,a.jsx)(r.h3,{id:"1-a-algorithm-implementation",children:"1. A* Algorithm Implementation"}),"\n",(0,a.jsxs)(r.p,{children:["Create a custom A* planner node ",(0,a.jsx)(r.code,{children:"custom_astar_planner.py"}),":"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n"""\r\nCustom A* Path Planner for ROS 2 Navigation2\r\n"""\r\nimport math\r\nfrom typing import List, Tuple, Optional\r\nimport numpy as np\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import PoseStamped, Point\r\nfrom nav_msgs.msg import OccupancyGrid, Path\r\nfrom nav2_msgs.action import ComputePathToPose\r\nfrom nav2_msgs.srv import GetCostmap\r\nfrom rclpy.action import ActionServer, GoalResponse\r\nfrom rclpy.callback_groups import ReentrantCallbackGroup\r\nfrom rclpy.executors import MultiThreadedExecutor\r\nfrom std_msgs.msg import Header\r\n\r\n\r\nclass Node:\r\n    """A* search node"""\r\n    def __init__(self, x, y, cost=0.0, heuristic=0.0, parent=None):\r\n        self.x = x\r\n        self.y = y\r\n        self.cost = cost  # g-cost (actual cost from start)\r\n        self.heuristic = heuristic  # h-cost (estimated cost to goal)\r\n        self.f_cost = cost + heuristic  # f-cost\r\n        self.parent = parent\r\n\r\n    def __lt__(self, other):\r\n        return self.f_cost < other.f_cost\r\n\r\n    def __eq__(self, other):\r\n        return self.x == other.x and self.y == other.y\r\n\r\n\r\nclass AStarPlanner(Node):\r\n    def __init__(self):\r\n        super().__init__(\'custom_astar_planner\')\r\n\r\n        # Action server for path computation\r\n        self._action_server = ActionServer(\r\n            self,\r\n            ComputePathToPose,\r\n            \'compute_path_to_pose\',\r\n            self.execute_callback,\r\n            callback_group=ReentrantCallbackGroup())\r\n\r\n        # Costmap service client\r\n        self.costmap_client = self.create_client(\r\n            GetCostmap, \'get_costmap\', callback_group=ReentrantCallbackGroup())\r\n\r\n        # Wait for costmap service\r\n        while not self.costmap_client.wait_for_service(timeout_sec=1.0):\r\n            self.get_logger().info(\'Costmap service not available, waiting...\')\r\n\r\n        # Path publisher\r\n        self.path_publisher = self.create_publisher(Path, \'plan\', 1)\r\n\r\n        self.get_logger().info(\'Custom A* Planner initialized\')\r\n\r\n    def execute_callback(self, goal_handle):\r\n        """Execute the path planning action"""\r\n        self.get_logger().info(\'Executing A* path planning...\')\r\n\r\n        # Get current costmap\r\n        costmap = self.get_current_costmap()\r\n        if costmap is None:\r\n            goal_handle.abort()\r\n            return ComputePathToPose.Result()\r\n\r\n        # Convert goal to grid coordinates\r\n        start_grid = self.world_to_grid(\r\n            goal_handle.request.start.pose.position.x,\r\n            goal_handle.request.start.pose.position.y,\r\n            costmap)\r\n\r\n        goal_grid = self.world_to_grid(\r\n            goal_handle.request.goal.pose.position.x,\r\n            goal_handle.request.goal.pose.position.y,\r\n            costmap)\r\n\r\n        # Plan path using A*\r\n        path_grid = self.astar_plan(start_grid, goal_grid, costmap)\r\n\r\n        if path_grid is None:\r\n            self.get_logger().warn(\'No path found\')\r\n            goal_handle.abort()\r\n            return ComputePathToPose.Result()\r\n\r\n        # Convert grid path to world coordinates\r\n        path_world = self.grid_path_to_world(path_grid, costmap)\r\n\r\n        # Create result\r\n        result = ComputePathToPose.Result()\r\n        result.path = path_world\r\n        goal_handle.succeed()\r\n\r\n        # Publish path\r\n        self.path_publisher.publish(path_world)\r\n\r\n        self.get_logger().info(\'A* path planning completed successfully\')\r\n        return result\r\n\r\n    def get_current_costmap(self):\r\n        """Get current costmap from service"""\r\n        request = GetCostmap.Request()\r\n        future = self.costmap_client.call_async(request)\r\n\r\n        # Wait for response (with timeout)\r\n        rclpy.spin_until_future_complete(self, future, timeout_sec=5.0)\r\n\r\n        if future.result() is not None:\r\n            return future.result().map\r\n        else:\r\n            self.get_logger().error(\'Failed to get costmap\')\r\n            return None\r\n\r\n    def world_to_grid(self, x_world, y_world, costmap):\r\n        """Convert world coordinates to grid coordinates"""\r\n        origin_x = costmap.info.origin.position.x\r\n        origin_y = costmap.info.origin.position.y\r\n        resolution = costmap.info.resolution\r\n\r\n        grid_x = int((x_world - origin_x) / resolution)\r\n        grid_y = int((y_world - origin_y) / resolution)\r\n\r\n        return (grid_x, grid_y)\r\n\r\n    def grid_to_world(self, grid_x, grid_y, costmap):\r\n        """Convert grid coordinates to world coordinates"""\r\n        origin_x = costmap.info.origin.position.x\r\n        origin_y = costmap.info.origin.position.y\r\n        resolution = costmap.info.resolution\r\n\r\n        world_x = grid_x * resolution + origin_x + resolution / 2.0\r\n        world_y = grid_y * resolution + origin_y + resolution / 2.0\r\n\r\n        return (world_x, world_y)\r\n\r\n    def grid_path_to_world(self, grid_path, costmap):\r\n        """Convert grid path to world path"""\r\n        path = Path()\r\n        path.header = Header()\r\n        path.header.stamp = self.get_clock().now().to_msg()\r\n        path.header.frame_id = costmap.header.frame_id\r\n\r\n        for grid_x, grid_y in grid_path:\r\n            world_x, world_y = self.grid_to_world(grid_x, grid_y, costmap)\r\n\r\n            pose = PoseStamped()\r\n            pose.header = Header()\r\n            pose.header.stamp = self.get_clock().now().to_msg()\r\n            pose.header.frame_id = costmap.header.frame_id\r\n            pose.pose.position.x = world_x\r\n            pose.pose.position.y = world_y\r\n            pose.pose.position.z = 0.0\r\n            pose.pose.orientation.w = 1.0  # No rotation\r\n\r\n            path.poses.append(pose)\r\n\r\n        return path\r\n\r\n    def heuristic(self, node, goal):\r\n        """Calculate heuristic (Manhattan distance)"""\r\n        return abs(node[0] - goal[0]) + abs(node[1] - goal[1])\r\n\r\n    def get_neighbors(self, node, costmap):\r\n        """Get valid neighbors for a node"""\r\n        neighbors = []\r\n        grid_width = costmap.info.width\r\n        grid_height = costmap.info.height\r\n\r\n        # 8-directional movement (can be changed to 4-directional)\r\n        directions = [\r\n            (-1, -1), (-1, 0), (-1, 1),\r\n            (0, -1),           (0, 1),\r\n            (1, -1),  (1, 0),  (1, 1)\r\n        ]\r\n\r\n        for dx, dy in directions:\r\n            new_x = node[0] + dx\r\n            new_y = node[1] + dy\r\n\r\n            # Check bounds\r\n            if 0 <= new_x < grid_width and 0 <= new_y < grid_height:\r\n                # Check if cell is free (cost < 50 to avoid unknown areas)\r\n                cost_index = new_y * grid_width + new_x\r\n                if costmap.data[cost_index] < 50:  # Free space threshold\r\n                    neighbors.append((new_x, new_y))\r\n\r\n        return neighbors\r\n\r\n    def astar_plan(self, start, goal, costmap):\r\n        """A* path planning algorithm"""\r\n        import heapq\r\n\r\n        # Check if start and goal are valid\r\n        start_cost_idx = start[1] * costmap.info.width + start[0]\r\n        goal_cost_idx = goal[1] * costmap.info.width + goal[0]\r\n\r\n        if (start_cost_idx >= len(costmap.data) or goal_cost_idx >= len(costmap.data) or\r\n            costmap.data[start_cost_idx] >= 50 or costmap.data[goal_cost_idx] >= 50):\r\n            self.get_logger().warn(\'Start or goal position is in obstacle\')\r\n            return None\r\n\r\n        # Initialize open and closed sets\r\n        open_set = []\r\n        closed_set = set()\r\n\r\n        # Create start node\r\n        start_node = (start[0], start[1], 0, self.heuristic(start, goal))\r\n        heapq.heappush(open_set, (start_node[2] + start_node[3], start_node))\r\n\r\n        # Track costs\r\n        g_costs = {start: 0}\r\n        parents = {start: None}\r\n\r\n        while open_set:\r\n            current_f, current = heapq.heappop(open_set)\r\n            current_pos = (current[0], current[1])\r\n\r\n            # Check if we reached the goal\r\n            if current_pos == goal:\r\n                # Reconstruct path\r\n                path = []\r\n                current_path = current_pos\r\n                while current_path is not None:\r\n                    path.append(current_path)\r\n                    current_path = parents[current_path]\r\n                path.reverse()\r\n                return path\r\n\r\n            closed_set.add(current_pos)\r\n\r\n            # Get neighbors\r\n            for neighbor in self.get_neighbors(current_pos, costmap):\r\n                if neighbor in closed_set:\r\n                    continue\r\n\r\n                # Calculate tentative g-cost\r\n                tentative_g = g_costs[current_pos] + 1  # Simple distance\r\n\r\n                # If this path is better than previous one\r\n                if neighbor not in g_costs or tentative_g < g_costs[neighbor]:\r\n                    g_costs[neighbor] = tentative_g\r\n                    h_cost = self.heuristic(neighbor, goal)\r\n                    f_cost = tentative_g + h_cost\r\n\r\n                    # Add to open set\r\n                    node_info = (neighbor[0], neighbor[1], tentative_g, h_cost)\r\n                    heapq.heappush(open_set, (f_cost, node_info))\r\n                    parents[neighbor] = current_pos\r\n\r\n        # No path found\r\n        self.get_logger().warn(\'A* failed to find a path\')\r\n        return None\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n\r\n    planner = AStarPlanner()\r\n\r\n    executor = MultiThreadedExecutor()\r\n    executor.add_node(planner)\r\n\r\n    try:\r\n        executor.spin()\r\n    except KeyboardInterrupt:\r\n        planner.get_logger().info(\'A* planner interrupted\')\r\n    finally:\r\n        planner.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,a.jsx)(r.h3,{id:"2-dijkstra-algorithm-implementation",children:"2. Dijkstra Algorithm Implementation"}),"\n",(0,a.jsxs)(r.p,{children:["Create a custom Dijkstra planner ",(0,a.jsx)(r.code,{children:"custom_dijkstra_planner.py"}),":"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n"""\r\nCustom Dijkstra Path Planner for ROS 2 Navigation2\r\n"""\r\nimport math\r\nfrom typing import List, Tuple, Optional\r\nimport numpy as np\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import PoseStamped, Point\r\nfrom nav_msgs.msg import OccupancyGrid, Path\r\nfrom nav2_msgs.action import ComputePathToPose\r\nfrom nav2_msgs.srv import GetCostmap\r\nfrom rclpy.action import ActionServer, GoalResponse\r\nfrom rclpy.callback_groups import ReentrantCallbackGroup\r\nfrom rclpy.executors import MultiThreadedExecutor\r\nfrom std_msgs.msg import Header\r\nimport heapq\r\n\r\n\r\nclass DijkstraPlanner(Node):\r\n    def __init__(self):\r\n        super().__init__(\'custom_dijkstra_planner\')\r\n\r\n        # Action server for path computation\r\n        self._action_server = ActionServer(\r\n            self,\r\n            ComputePathToPose,\r\n            \'compute_path_to_pose\',\r\n            self.execute_callback,\r\n            callback_group=ReentrantCallbackGroup())\r\n\r\n        # Costmap service client\r\n        self.costmap_client = self.create_client(\r\n            GetCostmap, \'get_costmap\', callback_group=ReentrantCallbackGroup())\r\n\r\n        # Wait for costmap service\r\n        while not self.costmap_client.wait_for_service(timeout_sec=1.0):\r\n            self.get_logger().info(\'Costmap service not available, waiting...\')\r\n\r\n        # Path publisher\r\n        self.path_publisher = self.create_publisher(Path, \'plan\', 1)\r\n\r\n        self.get_logger().info(\'Custom Dijkstra Planner initialized\')\r\n\r\n    def execute_callback(self, goal_handle):\r\n        """Execute the path planning action"""\r\n        self.get_logger().info(\'Executing Dijkstra path planning...\')\r\n\r\n        # Get current costmap\r\n        costmap = self.get_current_costmap()\r\n        if costmap is None:\r\n            goal_handle.abort()\r\n            return ComputePathToPose.Result()\r\n\r\n        # Convert goal to grid coordinates\r\n        start_grid = self.world_to_grid(\r\n            goal_handle.request.start.pose.position.x,\r\n            goal_handle.request.start.pose.position.y,\r\n            costmap)\r\n\r\n        goal_grid = self.world_to_grid(\r\n            goal_handle.request.goal.pose.position.x,\r\n            goal_handle.request.goal.pose.position.y,\r\n            costmap)\r\n\r\n        # Plan path using Dijkstra\r\n        path_grid = self.dijkstra_plan(start_grid, goal_grid, costmap)\r\n\r\n        if path_grid is None:\r\n            self.get_logger().warn(\'No path found\')\r\n            goal_handle.abort()\r\n            return ComputePathToPose.Result()\r\n\r\n        # Convert grid path to world coordinates\r\n        path_world = self.grid_path_to_world(path_grid, costmap)\r\n\r\n        # Create result\r\n        result = ComputePathToPose.Result()\r\n        result.path = path_world\r\n        goal_handle.succeed()\r\n\r\n        # Publish path\r\n        self.path_publisher.publish(path_world)\r\n\r\n        self.get_logger().info(\'Dijkstra path planning completed successfully\')\r\n        return result\r\n\r\n    def get_current_costmap(self):\r\n        """Get current costmap from service"""\r\n        request = GetCostmap.Request()\r\n        future = self.costmap_client.call_async(request)\r\n\r\n        # Wait for response (with timeout)\r\n        rclpy.spin_until_future_complete(self, future, timeout_sec=5.0)\r\n\r\n        if future.result() is not None:\r\n            return future.result().map\r\n        else:\r\n            self.get_logger().error(\'Failed to get costmap\')\r\n            return None\r\n\r\n    def world_to_grid(self, x_world, y_world, costmap):\r\n        """Convert world coordinates to grid coordinates"""\r\n        origin_x = costmap.info.origin.position.x\r\n        origin_y = costmap.info.origin.position.y\r\n        resolution = costmap.info.resolution\r\n\r\n        grid_x = int((x_world - origin_x) / resolution)\r\n        grid_y = int((y_world - origin_y) / resolution)\r\n\r\n        return (grid_x, grid_y)\r\n\r\n    def grid_to_world(self, grid_x, grid_y, costmap):\r\n        """Convert grid coordinates to world coordinates"""\r\n        origin_x = costmap.info.origin.position.x\r\n        origin_y = costmap.info.origin.position.y\r\n        resolution = costmap.info.resolution\r\n\r\n        world_x = grid_x * resolution + origin_x + resolution / 2.0\r\n        world_y = grid_y * resolution + origin_y + resolution / 2.0\r\n\r\n        return (world_x, world_y)\r\n\r\n    def grid_path_to_world(self, grid_path, costmap):\r\n        """Convert grid path to world path"""\r\n        path = Path()\r\n        path.header = Header()\r\n        path.header.stamp = self.get_clock().now().to_msg()\r\n        path.header.frame_id = costmap.header.frame_id\r\n\r\n        for grid_x, grid_y in grid_path:\r\n            world_x, world_y = self.grid_to_world(grid_x, grid_y, costmap)\r\n\r\n            pose = PoseStamped()\r\n            pose.header = Header()\r\n            pose.header.stamp = self.get_clock().now().to_msg()\r\n            pose.header.frame_id = costmap.header.frame_id\r\n            pose.pose.position.x = world_x\r\n            pose.pose.position.y = world_y\r\n            pose.pose.position.z = 0.0\r\n            pose.pose.orientation.w = 1.0  # No rotation\r\n\r\n            path.poses.append(pose)\r\n\r\n        return path\r\n\r\n    def get_neighbors(self, node, costmap):\r\n        """Get valid neighbors for a node"""\r\n        neighbors = []\r\n        grid_width = costmap.info.width\r\n        grid_height = costmap.info.height\r\n\r\n        # 8-directional movement\r\n        directions = [\r\n            (-1, -1), (-1, 0), (-1, 1),\r\n            (0, -1),           (0, 1),\r\n            (1, -1),  (1, 0),  (1, 1)\r\n        ]\r\n\r\n        for dx, dy in directions:\r\n            new_x = node[0] + dx\r\n            new_y = node[1] + dy\r\n\r\n            # Check bounds\r\n            if 0 <= new_x < grid_width and 0 <= new_y < grid_height:\r\n                # Check if cell is free (cost < 50 to avoid unknown areas)\r\n                cost_index = new_y * grid_width + new_x\r\n                if costmap.data[cost_index] < 50:  # Free space threshold\r\n                    # Calculate cost based on direction and terrain\r\n                    if abs(dx) + abs(dy) == 2:  # Diagonal move\r\n                        cost = math.sqrt(2)  # Diagonal distance\r\n                    else:  # Horizontal/vertical move\r\n                        cost = 1.0\r\n\r\n                    neighbors.append(((new_x, new_y), cost))\r\n\r\n        return neighbors\r\n\r\n    def dijkstra_plan(self, start, goal, costmap):\r\n        """Dijkstra path planning algorithm"""\r\n        # Check if start and goal are valid\r\n        start_cost_idx = start[1] * costmap.info.width + start[0]\r\n        goal_cost_idx = goal[1] * costmap.info.width + goal[0]\r\n\r\n        if (start_cost_idx >= len(costmap.data) or goal_cost_idx >= len(costmap.data) or\r\n            costmap.data[start_cost_idx] >= 50 or costmap.data[goal_cost_idx] >= 50):\r\n            self.get_logger().warn(\'Start or goal position is in obstacle\')\r\n            return None\r\n\r\n        # Initialize distances and priority queue\r\n        distances = {}\r\n        previous = {}\r\n        pq = []\r\n\r\n        # Set all distances to infinity except start\r\n        for y in range(costmap.info.height):\r\n            for x in range(costmap.info.width):\r\n                pos = (x, y)\r\n                distances[pos] = float(\'inf\')\r\n\r\n        # Set start distance to 0\r\n        distances[start] = 0\r\n        heapq.heappush(pq, (0, start))\r\n\r\n        while pq:\r\n            current_dist, current = heapq.heappop(pq)\r\n\r\n            # If we reached the goal, reconstruct path\r\n            if current == goal:\r\n                path = []\r\n                current_path = goal\r\n                while current_path is not None:\r\n                    path.append(current_path)\r\n                    current_path = previous.get(current_path)\r\n                path.reverse()\r\n                return path\r\n\r\n            # If we\'ve already processed this node with a shorter distance, skip\r\n            if current_dist > distances[current]:\r\n                continue\r\n\r\n            # Explore neighbors\r\n            for neighbor_pos, edge_cost in self.get_neighbors(current, costmap):\r\n                new_dist = distances[current] + edge_cost\r\n\r\n                if new_dist < distances[neighbor_pos]:\r\n                    distances[neighbor_pos] = new_dist\r\n                    previous[neighbor_pos] = current\r\n                    heapq.heappush(pq, (new_dist, neighbor_pos))\r\n\r\n        # No path found\r\n        self.get_logger().warn(\'Dijkstra failed to find a path\')\r\n        return None\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n\r\n    planner = DijkstraPlanner()\r\n\r\n    executor = MultiThreadedExecutor()\r\n    executor.add_node(planner)\r\n\r\n    try:\r\n        executor.spin()\r\n    except KeyboardInterrupt:\r\n        planner.get_logger().info(\'Dijkstra planner interrupted\')\r\n    finally:\r\n        planner.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,a.jsx)(r.h3,{id:"3-theta-any-angle-path-planning",children:"3. Theta* Any-Angle Path Planning"}),"\n",(0,a.jsx)(r.p,{children:"Create a custom Theta* planner for any-angle path planning:"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n"""\r\nCustom Theta* Any-Angle Path Planner for ROS 2 Navigation2\r\n"""\r\nimport math\r\nfrom typing import List, Tuple, Optional\r\nimport numpy as np\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import PoseStamped, Point\r\nfrom nav_msgs.msg import OccupancyGrid, Path\r\nfrom nav2_msgs.action import ComputePathToPose\r\nfrom nav2_msgs.srv import GetCostmap\r\nfrom rclpy.action import ActionServer, GoalResponse\r\nfrom rclpy.callback_groups import ReentrantCallbackGroup\r\nfrom rclpy.executors import MultiThreadedExecutor\r\nfrom std_msgs.msg import Header\r\nimport heapq\r\n\r\n\r\nclass ThetaStarPlanner(Node):\r\n    def __init__(self):\r\n        super().__init__(\'custom_theta_star_planner\')\r\n\r\n        # Action server for path computation\r\n        self._action_server = ActionServer(\r\n            self,\r\n            ComputePathToPose,\r\n            \'compute_path_to_pose\',\r\n            self.execute_callback,\r\n            callback_group=ReentrantCallbackGroup())\r\n\r\n        # Costmap service client\r\n        self.costmap_client = self.create_client(\r\n            GetCostmap, \'get_costmap\', callback_group=ReentrantCallbackGroup())\r\n\r\n        # Wait for costmap service\r\n        while not self.costmap_client.wait_for_service(timeout_sec=1.0):\r\n            self.get_logger().info(\'Costmap service not available, waiting...\')\r\n\r\n        # Path publisher\r\n        self.path_publisher = self.create_publisher(Path, \'plan\', 1)\r\n\r\n        self.get_logger().info(\'Custom Theta* Planner initialized\')\r\n\r\n    def execute_callback(self, goal_handle):\r\n        """Execute the path planning action"""\r\n        self.get_logger().info(\'Executing Theta* path planning...\')\r\n\r\n        # Get current costmap\r\n        costmap = self.get_current_costmap()\r\n        if costmap is None:\r\n            goal_handle.abort()\r\n            return ComputePathToPose.Result()\r\n\r\n        # Convert goal to grid coordinates\r\n        start_grid = self.world_to_grid(\r\n            goal_handle.request.start.pose.position.x,\r\n            goal_handle.request.start.pose.position.y,\r\n            costmap)\r\n\r\n        goal_grid = self.world_to_grid(\r\n            goal_handle.request.goal.pose.position.x,\r\n            goal_handle.request.goal.pose.position.y,\r\n            costmap)\r\n\r\n        # Plan path using Theta*\r\n        path_grid = self.theta_star_plan(start_grid, goal_grid, costmap)\r\n\r\n        if path_grid is None:\r\n            self.get_logger().warn(\'No path found\')\r\n            goal_handle.abort()\r\n            return ComputePathToPose.Result()\r\n\r\n        # Convert grid path to world coordinates\r\n        path_world = self.grid_path_to_world(path_grid, costmap)\r\n\r\n        # Create result\r\n        result = ComputePathToPose.Result()\r\n        result.path = path_world\r\n        goal_handle.succeed()\r\n\r\n        # Publish path\r\n        self.path_publisher.publish(path_world)\r\n\r\n        self.get_logger().info(\'Theta* path planning completed successfully\')\r\n        return result\r\n\r\n    def get_current_costmap(self):\r\n        """Get current costmap from service"""\r\n        request = GetCostmap.Request()\r\n        future = self.costmap_client.call_async(request)\r\n\r\n        # Wait for response (with timeout)\r\n        rclpy.spin_until_future_complete(self, future, timeout_sec=5.0)\r\n\r\n        if future.result() is not None:\r\n            return future.result().map\r\n        else:\r\n            self.get_logger().error(\'Failed to get costmap\')\r\n            return None\r\n\r\n    def world_to_grid(self, x_world, y_world, costmap):\r\n        """Convert world coordinates to grid coordinates"""\r\n        origin_x = costmap.info.origin.position.x\r\n        origin_y = costmap.info.origin.position.y\r\n        resolution = costmap.info.resolution\r\n\r\n        grid_x = int((x_world - origin_x) / resolution)\r\n        grid_y = int((y_world - origin_y) / resolution)\r\n\r\n        return (grid_x, grid_y)\r\n\r\n    def grid_to_world(self, grid_x, grid_y, costmap):\r\n        """Convert grid coordinates to world coordinates"""\r\n        origin_x = costmap.info.origin.position.x\r\n        origin_y = costmap.info.origin.position.y\r\n        resolution = costmap.info.resolution\r\n\r\n        world_x = grid_x * resolution + origin_x + resolution / 2.0\r\n        world_y = grid_y * resolution + origin_y + resolution / 2.0\r\n\r\n        return (world_x, world_y)\r\n\r\n    def grid_path_to_world(self, grid_path, costmap):\r\n        """Convert grid path to world path"""\r\n        path = Path()\r\n        path.header = Header()\r\n        path.header.stamp = self.get_clock().now().to_msg()\r\n        path.header.frame_id = costmap.header.frame_id\r\n\r\n        for grid_x, grid_y in grid_path:\r\n            world_x, world_y = self.grid_to_world(grid_x, grid_y, costmap)\r\n\r\n            pose = PoseStamped()\r\n            pose.header = Header()\r\n            pose.header.stamp = self.get_clock().now().to_msg()\r\n            pose.header.frame_id = costmap.header.frame_id\r\n            pose.pose.position.x = world_x\r\n            pose.pose.position.y = world_y\r\n            pose.pose.position.z = 0.0\r\n            pose.pose.orientation.w = 1.0  # No rotation\r\n\r\n            path.poses.append(pose)\r\n\r\n        return path\r\n\r\n    def line_of_sight(self, pos1, pos2, costmap):\r\n        """Check if there\'s a line of sight between two positions"""\r\n        x0, y0 = pos1\r\n        x1, y1 = pos2\r\n\r\n        # Bresenham\'s line algorithm\r\n        dx = abs(x1 - x0)\r\n        dy = abs(y1 - y0)\r\n        sx = 1 if x0 < x1 else -1\r\n        sy = 1 if y0 < y1 else -1\r\n        err = dx - dy\r\n\r\n        x, y = x0, y0\r\n\r\n        while True:\r\n            # Check if current point is an obstacle\r\n            if x >= 0 and x < costmap.info.width and y >= 0 and y < costmap.info.height:\r\n                cost_idx = y * costmap.info.width + x\r\n                if costmap.data[cost_idx] >= 50:  # Obstacle\r\n                    return False\r\n            else:\r\n                return False  # Out of bounds\r\n\r\n            if x == x1 and y == y1:\r\n                break\r\n\r\n            e2 = 2 * err\r\n            if e2 > -dy:\r\n                err -= dy\r\n                x += sx\r\n            if e2 < dx:\r\n                err += dx\r\n                y += sy\r\n\r\n        return True\r\n\r\n    def heuristic(self, pos1, pos2):\r\n        """Calculate Euclidean distance heuristic"""\r\n        return math.sqrt((pos1[0] - pos2[0])**2 + (pos1[1] - pos2[1])**2)\r\n\r\n    def get_neighbors(self, node, costmap):\r\n        """Get valid neighbors for a node"""\r\n        neighbors = []\r\n        grid_width = costmap.info.width\r\n        grid_height = costmap.info.height\r\n\r\n        # 8-directional movement\r\n        directions = [\r\n            (-1, -1), (-1, 0), (-1, 1),\r\n            (0, -1),           (0, 1),\r\n            (1, -1),  (1, 0),  (1, 1)\r\n        ]\r\n\r\n        for dx, dy in directions:\r\n            new_x = node[0] + dx\r\n            new_y = node[1] + dy\r\n\r\n            # Check bounds\r\n            if 0 <= new_x < grid_width and 0 <= new_y < grid_height:\r\n                # Check if cell is free (cost < 50 to avoid unknown areas)\r\n                cost_index = new_y * grid_width + new_x\r\n                if costmap.data[cost_index] < 50:  # Free space threshold\r\n                    # Calculate cost based on direction\r\n                    if abs(dx) + abs(dy) == 2:  # Diagonal move\r\n                        cost = math.sqrt(2)\r\n                    else:  # Horizontal/vertical move\r\n                        cost = 1.0\r\n\r\n                    neighbors.append(((new_x, new_y), cost))\r\n\r\n        return neighbors\r\n\r\n    def theta_star_plan(self, start, goal, costmap):\r\n        """Theta* path planning algorithm"""\r\n        # Check if start and goal are valid\r\n        start_cost_idx = start[1] * costmap.info.width + start[0]\r\n        goal_cost_idx = goal[1] * costmap.info.width + goal[0]\r\n\r\n        if (start_cost_idx >= len(costmap.data) or goal_cost_idx >= len(costmap.data) or\r\n            costmap.data[start_cost_idx] >= 50 or costmap.data[goal_cost_idx] >= 50):\r\n            self.get_logger().warn(\'Start or goal position is in obstacle\')\r\n            return None\r\n\r\n        # Initialize open and closed sets\r\n        open_set = []\r\n        closed_set = set()\r\n\r\n        # Initialize g-costs and parents\r\n        g_costs = {start: 0}\r\n        parents = {start: start}\r\n\r\n        # Add start node to open set\r\n        f_cost = self.heuristic(start, goal)\r\n        heapq.heappush(open_set, (f_cost, start))\r\n\r\n        while open_set:\r\n            current_f, current = heapq.heappop(open_set)\r\n            current = tuple(current)  # Ensure tuple type\r\n\r\n            if current in closed_set:\r\n                continue\r\n\r\n            closed_set.add(current)\r\n\r\n            if current == goal:\r\n                # Reconstruct path by following parent pointers\r\n                path = []\r\n                current_path = current\r\n                while current_path != parents[current_path]:\r\n                    path.append(current_path)\r\n                    current_path = parents[current_path]\r\n                path.append(start)\r\n                path.reverse()\r\n                return path\r\n\r\n            # Get neighbors\r\n            for neighbor, edge_cost in self.get_neighbors(current, costmap):\r\n                if neighbor in closed_set:\r\n                    continue\r\n\r\n                # Calculate tentative g-cost\r\n                parent = parents[current]\r\n\r\n                # Check line of sight from parent to neighbor\r\n                if self.line_of_sight(parent, neighbor, costmap):\r\n                    # Update through parent\r\n                    tentative_g = g_costs[parent] + self.heuristic(parent, neighbor)\r\n                else:\r\n                    # Update through current\r\n                    tentative_g = g_costs[current] + edge_cost\r\n\r\n                # If this path is better than previous one\r\n                if neighbor not in g_costs or tentative_g < g_costs[neighbor]:\r\n                    g_costs[neighbor] = tentative_g\r\n                    parents[neighbor] = parent if self.line_of_sight(parent, neighbor, costmap) else current\r\n                    f_cost = tentative_g + self.heuristic(neighbor, goal)\r\n                    heapq.heappush(open_set, (f_cost, neighbor))\r\n\r\n        # No path found\r\n        self.get_logger().warn(\'Theta* failed to find a path\')\r\n        return None\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n\r\n    planner = ThetaStarPlanner()\r\n\r\n    executor = MultiThreadedExecutor()\r\n    executor.add_node(planner)\r\n\r\n    try:\r\n        executor.spin()\r\n    except KeyboardInterrupt:\r\n        planner.get_logger().info(\'Theta* planner interrupted\')\r\n    finally:\r\n        planner.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,a.jsx)(r.h2,{id:"advanced-path-planning-features",children:"Advanced Path Planning Features"}),"\n",(0,a.jsx)(r.h3,{id:"1-dynamic-path-planning-with-obstacle-avoidance",children:"1. Dynamic Path Planning with Obstacle Avoidance"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-yaml",children:'# Configuration for dynamic path planning\r\nplanner_server:\r\n  ros__parameters:\r\n    expected_planner_frequency: 1.0\r\n    use_sim_time: false\r\n    planner_plugins: ["GridBased", "DynamicPlanner"]\r\n\r\n    GridBased:\r\n      plugin: "nav2_navfn_planner::NavfnPlanner"\r\n      tolerance: 0.5\r\n      use_astar: true\r\n      allow_unknown: false\r\n\r\n    DynamicPlanner:\r\n      plugin: "nav2_dynamic_planner::DynamicPlanner"\r\n      max_velocity_x: 0.5\r\n      min_velocity_x: 0.1\r\n      max_velocity_theta: 1.0\r\n      min_velocity_theta: 0.1\r\n      acc_lim_x: 2.5\r\n      acc_lim_theta: 3.2\r\n      decel_lim_x: -2.5\r\n      decel_lim_theta: -3.2\r\n      max_obstacle_height: 2.0\r\n      min_obstacle_height: 0.0\n'})}),"\n",(0,a.jsx)(r.h3,{id:"2-multi-goal-path-planning",children:"2. Multi-Goal Path Planning"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n"""\r\nMulti-Goal Path Planner\r\n"""\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import PoseStamped\r\nfrom nav2_msgs.action import ComputePathThroughPoses\r\nfrom rclpy.action import ActionServer\r\nfrom rclpy.callback_groups import ReentrantCallbackGroup\r\nfrom std_msgs.msg import Header\r\nimport math\r\n\r\n\r\nclass MultiGoalPlanner(Node):\r\n    def __init__(self):\r\n        super().__init__(\'multi_goal_planner\')\r\n\r\n        # Action server for multi-goal path computation\r\n        self._action_server = ActionServer(\r\n            self,\r\n            ComputePathThroughPoses,\r\n            \'compute_path_through_poses\',\r\n            self.execute_callback,\r\n            callback_group=ReentrantCallbackGroup())\r\n\r\n        self.get_logger().info(\'Multi-Goal Planner initialized\')\r\n\r\n    def execute_callback(self, goal_handle):\r\n        """Execute multi-goal path planning"""\r\n        self.get_logger().info(\'Executing multi-goal path planning...\')\r\n\r\n        # For simplicity, connect all goals with basic path planning\r\n        # In practice, you\'d implement more sophisticated multi-goal planning\r\n        total_path = []\r\n\r\n        # Start from initial pose\r\n        current_pose = goal_handle.request.start\r\n        total_path.append(current_pose)\r\n\r\n        # Plan to each goal sequentially\r\n        for goal_pose in goal_handle.request.poses:\r\n            # Here you would call your path planning algorithm\r\n            # For now, we\'ll just add the goal directly (not realistic)\r\n            # In practice, implement proper path planning between waypoints\r\n            path_segment = self.plan_between_poses(current_pose, goal_pose)\r\n            total_path.extend(path_segment.poses[1:])  # Skip first pose to avoid duplication\r\n            current_pose = goal_pose\r\n\r\n        # Create result\r\n        result = ComputePathThroughPoses.Result()\r\n        result.path.header = Header()\r\n        result.path.header.stamp = self.get_clock().now().to_msg()\r\n        result.path.header.frame_id = "map"\r\n        result.path.poses = total_path\r\n\r\n        goal_handle.succeed()\r\n        return result\r\n\r\n    def plan_between_poses(self, start, goal):\r\n        """Plan path between two poses (simplified implementation)"""\r\n        from nav_msgs.msg import Path\r\n        path = Path()\r\n        path.header = Header()\r\n        path.header.stamp = self.get_clock().now().to_msg()\r\n        path.header.frame_id = "map"\r\n\r\n        # Add start and goal as simple path (in practice, use actual path planning)\r\n        start_stamped = PoseStamped()\r\n        start_stamped.header = path.header\r\n        start_stamped.pose = start.pose\r\n        path.poses.append(start_stamped)\r\n\r\n        goal_stamped = PoseStamped()\r\n        goal_stamped.header = path.header\r\n        goal_stamped.pose = goal.pose\r\n        path.poses.append(goal_stamped)\r\n\r\n        return path\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    planner = MultiGoalPlanner()\r\n\r\n    try:\r\n        rclpy.spin(planner)\r\n    except KeyboardInterrupt:\r\n        planner.get_logger().info(\'Multi-goal planner interrupted\')\r\n    finally:\r\n        planner.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,a.jsx)(r.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,a.jsx)(r.h3,{id:"1-path-planning-performance-tuning",children:"1. Path Planning Performance Tuning"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-yaml",children:'# Optimized path planning configuration\r\nplanner_server:\r\n  ros__parameters:\r\n    expected_planner_frequency: 10.0  # Higher frequency for faster planning\r\n    use_sim_time: false\r\n    planner_plugins: ["GridBased"]\r\n\r\n    GridBased:\r\n      plugin: "nav2_navfn_planner::NavfnPlanner"\r\n      tolerance: 0.25          # Tighter tolerance for better accuracy\r\n      use_astar: true          # Use A* for faster convergence\r\n      allow_unknown: false     # Don\'t plan through unknown space\r\n      visualize_potential: false  # Disable visualization for performance\r\n      potential_scale: 3.0     # Scale for potential field\r\n      obstacle_scale: 1.0      # Scale for obstacle inflation\r\n      neutral_scale: 0.5       # Scale for neutral areas\n'})}),"\n",(0,a.jsx)(r.h3,{id:"2-memory-management",children:"2. Memory Management"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-yaml",children:'# Memory-optimized path planning\r\nplanner_server:\r\n  ros__parameters:\r\n    expected_planner_frequency: 1.0  # Lower frequency to reduce CPU usage\r\n    use_sim_time: false\r\n    planner_plugins: ["GridBased"]\r\n\r\n    GridBased:\r\n      plugin: "nav2_navfn_planner::NavfnPlanner"\r\n      tolerance: 1.0           # Larger tolerance for faster planning\r\n      use_astar: true\r\n      allow_unknown: true\r\n      memory_limit: 100        # Limit memory usage for large maps\n'})}),"\n",(0,a.jsx)(r.h2,{id:"path-planning-quality-metrics",children:"Path Planning Quality Metrics"}),"\n",(0,a.jsx)(r.h3,{id:"1-path-quality-assessment",children:"1. Path Quality Assessment"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\"\"\"\r\nPath Quality Assessment Tool\r\n\"\"\"\r\nimport math\r\nfrom typing import List\r\nfrom geometry_msgs.msg import PoseStamped\r\n\r\n\r\ndef calculate_path_metrics(path: List[PoseStamped]):\r\n    \"\"\"Calculate various path quality metrics\"\"\"\r\n    if len(path) < 2:\r\n        return {\r\n            'length': 0,\r\n            'smoothness': 0,\r\n            'curvature': 0,\r\n            'turning_points': 0\r\n        }\r\n\r\n    # Calculate path length\r\n    length = 0\r\n    for i in range(1, len(path)):\r\n        p1 = path[i-1].pose.position\r\n        p2 = path[i].pose.position\r\n        dist = math.sqrt((p2.x - p1.x)**2 + (p2.y - p1.y)**2)\r\n        length += dist\r\n\r\n    # Calculate smoothness (based on angle changes)\r\n    smoothness = 0\r\n    turning_points = 0\r\n    for i in range(1, len(path)-1):\r\n        p0 = path[i-1].pose.position\r\n        p1 = path[i].pose.position\r\n        p2 = path[i+1].pose.position\r\n\r\n        # Calculate vectors\r\n        v1_x, v1_y = p1.x - p0.x, p1.y - p0.y\r\n        v2_x, v2_y = p2.x - p1.x, p2.y - p1.y\r\n\r\n        # Calculate angle between vectors\r\n        dot_product = v1_x * v2_x + v1_y * v2_y\r\n        v1_mag = math.sqrt(v1_x**2 + v1_y**2)\r\n        v2_mag = math.sqrt(v2_x**2 + v2_y**2)\r\n\r\n        if v1_mag > 0 and v2_mag > 0:\r\n            cos_angle = dot_product / (v1_mag * v2_mag)\r\n            angle = math.acos(max(-1, min(1, cos_angle)))  # Clamp to [-1, 1]\r\n\r\n            if angle > 0.1:  # Consider significant turns\r\n                turning_points += 1\r\n                smoothness += angle\r\n\r\n    # Calculate average curvature\r\n    curvature = smoothness / max(1, turning_points) if turning_points > 0 else 0\r\n\r\n    return {\r\n        'length': length,\r\n        'smoothness': smoothness,\r\n        'curvature': curvature,\r\n        'turning_points': turning_points,\r\n        'average_segment_length': length / max(1, len(path) - 1)\r\n    }\r\n\r\n\r\ndef assess_path_quality(path: List[PoseStamped], max_length=None, max_turns=None):\r\n    \"\"\"Assess path quality against criteria\"\"\"\r\n    metrics = calculate_path_metrics(path)\r\n\r\n    quality_score = 1.0\r\n\r\n    # Length penalty\r\n    if max_length and metrics['length'] > max_length:\r\n        quality_score *= 0.5  # Reduce quality if path is too long\r\n\r\n    # Turn penalty\r\n    if max_turns and metrics['turning_points'] > max_turns:\r\n        quality_score *= 0.7  # Reduce quality if too many turns\r\n\r\n    # Smoothness bonus\r\n    if metrics['curvature'] < 0.5:  # Relatively straight path\r\n        quality_score *= 1.2  # Bonus for smooth paths\r\n\r\n    return {\r\n        'metrics': metrics,\r\n        'quality_score': min(quality_score, 1.0),  # Cap at 1.0\r\n        'is_acceptable': quality_score > 0.5\r\n    }\n"})}),"\n",(0,a.jsx)(r.h2,{id:"integration-with-navigation-system",children:"Integration with Navigation System"}),"\n",(0,a.jsx)(r.h3,{id:"1-planner-integration-configuration",children:"1. Planner Integration Configuration"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-yaml",children:'# Complete navigation configuration with custom planners\r\nplanner_server:\r\n  ros__parameters:\r\n    expected_planner_frequency: 20.0\r\n    use_sim_time: false\r\n    planner_plugins: ["GridBased"]\r\n\r\n    GridBased:\r\n      plugin: "nav2_navfn_planner::NavfnPlanner"\r\n      tolerance: 0.5\r\n      use_astar: true\r\n      allow_unknown: false\r\n\r\nbt_navigator:\r\n  ros__parameters:\r\n    use_sim_time: false\r\n    global_frame: map\r\n    robot_base_frame: base_link\r\n    odom_topic: /odom\r\n    bt_loop_duration: 10\r\n    default_server_timeout: 20\r\n    enable_groot_monitoring: true\r\n    navigate_through_poses: false\r\n    navigate_to_pose: true\r\n    behavior_tree_xml_filename: "navigate_w_replanning_and_recovery.xml"\r\n    plugin_lib_names:\r\n    - nav2_compute_path_to_pose_action_bt_node\r\n    - nav2_follow_path_action_bt_node\r\n    - nav2_back_up_action_bt_node\r\n    - nav2_spin_action_bt_node\r\n    - nav2_wait_action_bt_node\r\n    - nav2_clear_costmap_service_bt_node\r\n    - nav2_is_stuck_condition_bt_node\r\n    - nav2_goal_reached_condition_bt_node\r\n    - nav2_initial_pose_received_condition_bt_node\r\n    - nav2_reinitialize_global_localization_service_bt_node\n'})}),"\n",(0,a.jsx)(r.h2,{id:"troubleshooting-common-issues",children:"Troubleshooting Common Issues"}),"\n",(0,a.jsx)(r.h3,{id:"1-path-planning-failures",children:"1. Path Planning Failures"}),"\n",(0,a.jsx)(r.h4,{id:"issue-planner-fails-to-find-path",children:"Issue: Planner fails to find path"}),"\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Symptoms"}),': Navigation fails with "No valid path found"\r\n',(0,a.jsx)(r.strong,{children:"Solutions"}),":"]}),"\n",(0,a.jsxs)(r.ol,{children:["\n",(0,a.jsxs)(r.li,{children:["Increase planner tolerance:","\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-yaml",children:"tolerance: 1.0  # Increase from 0.5\n"})}),"\n"]}),"\n",(0,a.jsxs)(r.li,{children:["Allow planning through unknown space:","\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-yaml",children:"allow_unknown: true\n"})}),"\n"]}),"\n",(0,a.jsx)(r.li,{children:"Check costmap configuration for proper obstacle inflation"}),"\n"]}),"\n",(0,a.jsx)(r.h4,{id:"issue-path-is-not-optimal",children:"Issue: Path is not optimal"}),"\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Symptoms"}),": Robot takes unnecessarily long routes\r\n",(0,a.jsx)(r.strong,{children:"Solutions"}),":"]}),"\n",(0,a.jsxs)(r.ol,{children:["\n",(0,a.jsxs)(r.li,{children:["Use A* instead of Dijkstra:","\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-yaml",children:"use_astar: true\n"})}),"\n"]}),"\n",(0,a.jsx)(r.li,{children:"Adjust heuristic function"}),"\n",(0,a.jsx)(r.li,{children:"Increase planning frequency"}),"\n"]}),"\n",(0,a.jsx)(r.h4,{id:"issue-high-cpu-usage-during-planning",children:"Issue: High CPU usage during planning"}),"\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Symptoms"}),": System becomes unresponsive during path planning\r\n",(0,a.jsx)(r.strong,{children:"Solutions"}),":"]}),"\n",(0,a.jsxs)(r.ol,{children:["\n",(0,a.jsx)(r.li,{children:"Reduce map resolution for planning"}),"\n",(0,a.jsx)(r.li,{children:"Lower planning frequency"}),"\n",(0,a.jsx)(r.li,{children:"Use simpler planning algorithms for real-time applications"}),"\n"]}),"\n",(0,a.jsx)(r.h3,{id:"2-performance-monitoring",children:"2. Performance Monitoring"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-bash",children:"# Monitor path planning performance\r\nros2 action list | grep path\r\nros2 action info /compute_path_to_pose\r\n\r\n# Check planning execution time\r\nros2 topic echo /planning_time\r\n\r\n# Monitor path quality\r\nros2 run nav2_util path_analyzer\n"})}),"\n",(0,a.jsx)(r.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(r.h3,{id:"1-algorithm-selection-guidelines",children:"1. Algorithm Selection Guidelines"}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"A"}),"*: Best for optimal paths with good heuristics"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Dijkstra"}),": Good for guaranteed optimal paths without heuristics"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"NavFn"}),": Fast for large maps with approximate solutions"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Theta"}),"*: Best for any-angle paths with line-of-sight optimization"]}),"\n"]}),"\n",(0,a.jsx)(r.h3,{id:"2-configuration-best-practices",children:"2. Configuration Best Practices"}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsx)(r.li,{children:"Start with default Navigation2 configurations"}),"\n",(0,a.jsx)(r.li,{children:"Gradually tune parameters based on performance"}),"\n",(0,a.jsx)(r.li,{children:"Test with various map complexities"}),"\n",(0,a.jsx)(r.li,{children:"Monitor computational requirements"}),"\n",(0,a.jsx)(r.li,{children:"Validate path safety and optimality"}),"\n"]}),"\n",(0,a.jsx)(r.h3,{id:"3-testing-strategies",children:"3. Testing Strategies"}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsx)(r.li,{children:"Test with different map sizes and complexities"}),"\n",(0,a.jsx)(r.li,{children:"Validate behavior with dynamic obstacles"}),"\n",(0,a.jsx)(r.li,{children:"Check path quality metrics"}),"\n",(0,a.jsx)(r.li,{children:"Monitor computational performance"}),"\n",(0,a.jsx)(r.li,{children:"Test edge cases (narrow passages, dead ends)"}),"\n"]}),"\n",(0,a.jsx)(r.h2,{id:"resources",children:"Resources"}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://navigation.ros.org/configuration/packages/configuring-planners.html",children:"Navigation2 Path Planning Documentation"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://github.com/ros-planning/navigation2/tree/main/nav2_navfn",children:"Nav2 Planners Source Code"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://navigation.ros.org/tutorials/docs/path_planning_comparison.html",children:"Path Planning Algorithms Comparison"})}),"\n"]}),"\n",(0,a.jsx)(r.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(r.p,{children:"This guide provides comprehensive coverage of path planning algorithms for ROS 2 Navigation2. The choice of algorithm depends on your specific requirements for optimality, computation time, and path quality. Built-in planners like NavFn provide good performance for most applications, while custom implementations allow for specialized requirements. Proper configuration and tuning are essential for achieving optimal navigation performance in your specific environment and use case."})]})}function d(n={}){const{wrapper:r}={...(0,o.R)(),...n.components};return r?(0,a.jsx)(r,{...n,children:(0,a.jsx)(c,{...n})}):c(n)}},7074:(n,r,e)=>{e.d(r,{R:()=>i,x:()=>s});var t=e(6540);const a={},o=t.createContext(a);function i(n){const r=t.useContext(o);return t.useMemo(function(){return"function"==typeof n?n(r):{...r,...n}},[r,n])}function s(n){let r;return r=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:i(n.components),t.createElement(o.Provider,{value:r},n.children)}}}]);